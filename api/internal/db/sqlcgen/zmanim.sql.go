// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: zmanim.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addTagToPublisherZman = `-- name: AddTagToPublisherZman :exec
INSERT INTO publisher_zman_tags (publisher_zman_id, tag_id)
VALUES ($1, $2)
ON CONFLICT (publisher_zman_id, tag_id) DO NOTHING
`

type AddTagToPublisherZmanParams struct {
	PublisherZmanID string `json:"publisher_zman_id"`
	TagID           string `json:"tag_id"`
}

// Add a tag to a publisher zman
func (q *Queries) AddTagToPublisherZman(ctx context.Context, arg AddTagToPublisherZmanParams) error {
	_, err := q.db.Exec(ctx, addTagToPublisherZman, arg.PublisherZmanID, arg.TagID)
	return err
}

const browsePublicZmanim = `-- name: BrowsePublicZmanim :many

SELECT
    z.id, z.publisher_id, z.zman_key, z.hebrew_name, z.english_name,
    z.formula_dsl, z.category,
    p.name as publisher_name,
    COUNT(*) OVER (PARTITION BY z.zman_key) as usage_count
FROM publisher_zmanim z
JOIN publishers p ON p.id = z.publisher_id
WHERE z.is_visible = true
  AND z.is_published = true
  AND ($1::text IS NULL OR z.hebrew_name ILIKE '%' || $1 || '%' OR z.english_name ILIKE '%' || $1 || '%')
  AND ($2::text IS NULL OR z.category = $2)
ORDER BY usage_count DESC, z.hebrew_name
LIMIT 50
`

type BrowsePublicZmanimParams struct {
	Column1 string `json:"column_1"`
	Column2 string `json:"column_2"`
}

type BrowsePublicZmanimRow struct {
	ID            string `json:"id"`
	PublisherID   string `json:"publisher_id"`
	ZmanKey       string `json:"zman_key"`
	HebrewName    string `json:"hebrew_name"`
	EnglishName   string `json:"english_name"`
	FormulaDsl    string `json:"formula_dsl"`
	Category      string `json:"category"`
	PublisherName string `json:"publisher_name"`
	UsageCount    int64  `json:"usage_count"`
}

// Browse public zmanim --
func (q *Queries) BrowsePublicZmanim(ctx context.Context, arg BrowsePublicZmanimParams) ([]BrowsePublicZmanimRow, error) {
	rows, err := q.db.Query(ctx, browsePublicZmanim, arg.Column1, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []BrowsePublicZmanimRow{}
	for rows.Next() {
		var i BrowsePublicZmanimRow
		if err := rows.Scan(
			&i.ID,
			&i.PublisherID,
			&i.ZmanKey,
			&i.HebrewName,
			&i.EnglishName,
			&i.FormulaDsl,
			&i.Category,
			&i.PublisherName,
			&i.UsageCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

type BulkAddTagsToPublisherZmanParams struct {
	PublisherZmanID string `json:"publisher_zman_id"`
	TagID           string `json:"tag_id"`
}

const countPublisherZmanim = `-- name: CountPublisherZmanim :one
SELECT COUNT(*) FROM publisher_zmanim WHERE publisher_id = $1
`

func (q *Queries) CountPublisherZmanim(ctx context.Context, publisherID string) (int64, error) {
	row := q.db.QueryRow(ctx, countPublisherZmanim, publisherID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPublisherZman = `-- name: CreatePublisherZman :one
INSERT INTO publisher_zmanim (
    id, publisher_id, zman_key, hebrew_name, english_name,
    formula_dsl, ai_explanation, publisher_comment,
    is_enabled, is_visible, is_published, is_beta, is_custom, category,
    dependencies, master_zman_id, linked_publisher_zman_id, source_type
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18
)
RETURNING id, publisher_id, zman_key, hebrew_name, english_name,
    formula_dsl, ai_explanation, publisher_comment,
    is_enabled, is_visible, is_published, is_beta, is_custom, category,
    dependencies, master_zman_id, linked_publisher_zman_id, source_type,
    created_at, updated_at
`

type CreatePublisherZmanParams struct {
	ID                    string      `json:"id"`
	PublisherID           string      `json:"publisher_id"`
	ZmanKey               string      `json:"zman_key"`
	HebrewName            string      `json:"hebrew_name"`
	EnglishName           string      `json:"english_name"`
	FormulaDsl            string      `json:"formula_dsl"`
	AiExplanation         *string     `json:"ai_explanation"`
	PublisherComment      *string     `json:"publisher_comment"`
	IsEnabled             bool        `json:"is_enabled"`
	IsVisible             bool        `json:"is_visible"`
	IsPublished           bool        `json:"is_published"`
	IsBeta                bool        `json:"is_beta"`
	IsCustom              bool        `json:"is_custom"`
	Category              string      `json:"category"`
	Dependencies          []string    `json:"dependencies"`
	MasterZmanID          pgtype.UUID `json:"master_zman_id"`
	LinkedPublisherZmanID pgtype.UUID `json:"linked_publisher_zman_id"`
	SourceType            *string     `json:"source_type"`
}

type CreatePublisherZmanRow struct {
	ID                    string             `json:"id"`
	PublisherID           string             `json:"publisher_id"`
	ZmanKey               string             `json:"zman_key"`
	HebrewName            string             `json:"hebrew_name"`
	EnglishName           string             `json:"english_name"`
	FormulaDsl            string             `json:"formula_dsl"`
	AiExplanation         *string            `json:"ai_explanation"`
	PublisherComment      *string            `json:"publisher_comment"`
	IsEnabled             bool               `json:"is_enabled"`
	IsVisible             bool               `json:"is_visible"`
	IsPublished           bool               `json:"is_published"`
	IsBeta                bool               `json:"is_beta"`
	IsCustom              bool               `json:"is_custom"`
	Category              string             `json:"category"`
	Dependencies          []string           `json:"dependencies"`
	MasterZmanID          pgtype.UUID        `json:"master_zman_id"`
	LinkedPublisherZmanID pgtype.UUID        `json:"linked_publisher_zman_id"`
	SourceType            *string            `json:"source_type"`
	CreatedAt             pgtype.Timestamptz `json:"created_at"`
	UpdatedAt             pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreatePublisherZman(ctx context.Context, arg CreatePublisherZmanParams) (CreatePublisherZmanRow, error) {
	row := q.db.QueryRow(ctx, createPublisherZman,
		arg.ID,
		arg.PublisherID,
		arg.ZmanKey,
		arg.HebrewName,
		arg.EnglishName,
		arg.FormulaDsl,
		arg.AiExplanation,
		arg.PublisherComment,
		arg.IsEnabled,
		arg.IsVisible,
		arg.IsPublished,
		arg.IsBeta,
		arg.IsCustom,
		arg.Category,
		arg.Dependencies,
		arg.MasterZmanID,
		arg.LinkedPublisherZmanID,
		arg.SourceType,
	)
	var i CreatePublisherZmanRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.ZmanKey,
		&i.HebrewName,
		&i.EnglishName,
		&i.FormulaDsl,
		&i.AiExplanation,
		&i.PublisherComment,
		&i.IsEnabled,
		&i.IsVisible,
		&i.IsPublished,
		&i.IsBeta,
		&i.IsCustom,
		&i.Category,
		&i.Dependencies,
		&i.MasterZmanID,
		&i.LinkedPublisherZmanID,
		&i.SourceType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePublisherZman = `-- name: DeletePublisherZman :one
DELETE FROM publisher_zmanim
WHERE publisher_id = $1 AND zman_key = $2 AND is_custom = true
RETURNING id
`

type DeletePublisherZmanParams struct {
	PublisherID string `json:"publisher_id"`
	ZmanKey     string `json:"zman_key"`
}

func (q *Queries) DeletePublisherZman(ctx context.Context, arg DeletePublisherZmanParams) (string, error) {
	row := q.db.QueryRow(ctx, deletePublisherZman, arg.PublisherID, arg.ZmanKey)
	var id string
	err := row.Scan(&id)
	return id, err
}

const getPublisherZmanByID = `-- name: GetPublisherZmanByID :one
SELECT
    pz.id, pz.publisher_id, pz.zman_key, pz.hebrew_name, pz.english_name,
    pz.formula_dsl, pz.ai_explanation, pz.publisher_comment,
    pz.is_enabled, pz.is_visible, pz.is_published, pz.is_custom, pz.category,
    pz.dependencies, pz.master_zman_id, pz.linked_publisher_zman_id,
    pz.source_type, pz.deleted_at, pz.created_at, pz.updated_at,
    p.name AS publisher_name,
    p.is_verified AS publisher_is_verified
FROM publisher_zmanim pz
JOIN publishers p ON p.id = pz.publisher_id
WHERE pz.id = $1
`

type GetPublisherZmanByIDRow struct {
	ID                    string             `json:"id"`
	PublisherID           string             `json:"publisher_id"`
	ZmanKey               string             `json:"zman_key"`
	HebrewName            string             `json:"hebrew_name"`
	EnglishName           string             `json:"english_name"`
	FormulaDsl            string             `json:"formula_dsl"`
	AiExplanation         *string            `json:"ai_explanation"`
	PublisherComment      *string            `json:"publisher_comment"`
	IsEnabled             bool               `json:"is_enabled"`
	IsVisible             bool               `json:"is_visible"`
	IsPublished           bool               `json:"is_published"`
	IsCustom              bool               `json:"is_custom"`
	Category              string             `json:"category"`
	Dependencies          []string           `json:"dependencies"`
	MasterZmanID          pgtype.UUID        `json:"master_zman_id"`
	LinkedPublisherZmanID pgtype.UUID        `json:"linked_publisher_zman_id"`
	SourceType            *string            `json:"source_type"`
	DeletedAt             pgtype.Timestamptz `json:"deleted_at"`
	CreatedAt             pgtype.Timestamptz `json:"created_at"`
	UpdatedAt             pgtype.Timestamptz `json:"updated_at"`
	PublisherName         string             `json:"publisher_name"`
	PublisherIsVerified   bool               `json:"publisher_is_verified"`
}

// Get a specific zman by ID (for linking validation)
func (q *Queries) GetPublisherZmanByID(ctx context.Context, id string) (GetPublisherZmanByIDRow, error) {
	row := q.db.QueryRow(ctx, getPublisherZmanByID, id)
	var i GetPublisherZmanByIDRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.ZmanKey,
		&i.HebrewName,
		&i.EnglishName,
		&i.FormulaDsl,
		&i.AiExplanation,
		&i.PublisherComment,
		&i.IsEnabled,
		&i.IsVisible,
		&i.IsPublished,
		&i.IsCustom,
		&i.Category,
		&i.Dependencies,
		&i.MasterZmanID,
		&i.LinkedPublisherZmanID,
		&i.SourceType,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublisherName,
		&i.PublisherIsVerified,
	)
	return i, err
}

const getPublisherZmanByKey = `-- name: GetPublisherZmanByKey :one
SELECT
    pz.id, pz.publisher_id, pz.zman_key, pz.hebrew_name, pz.english_name,
    pz.transliteration, pz.description,
    COALESCE(linked_pz.formula_dsl, pz.formula_dsl) AS formula_dsl,
    pz.ai_explanation, pz.publisher_comment,
    pz.is_enabled, pz.is_visible, pz.is_published, pz.is_beta, pz.is_custom, pz.category,
    pz.dependencies, pz.created_at, pz.updated_at,
    pz.master_zman_id, pz.linked_publisher_zman_id, pz.source_type,
    -- Source/original values from registry or linked publisher (for diff/revert UI)
    COALESCE(mr.canonical_hebrew_name, linked_pz.hebrew_name) AS source_hebrew_name,
    COALESCE(mr.canonical_english_name, linked_pz.english_name) AS source_english_name,
    COALESCE(mr.transliteration, linked_pz.transliteration) AS source_transliteration,
    COALESCE(mr.description, linked_pz.description) AS source_description,
    COALESCE(mr.default_formula_dsl, linked_pz.formula_dsl) AS source_formula_dsl,
    -- Linked source info
    CASE WHEN pz.linked_publisher_zman_id IS NOT NULL THEN true ELSE false END AS is_linked,
    linked_pub.name AS linked_source_publisher_name,
    -- Time category for consistency
    COALESCE(mr.time_category, pz.category) AS time_category
FROM publisher_zmanim pz
LEFT JOIN publisher_zmanim linked_pz ON pz.linked_publisher_zman_id = linked_pz.id
LEFT JOIN publishers linked_pub ON linked_pz.publisher_id = linked_pub.id
LEFT JOIN master_zmanim_registry mr ON pz.master_zman_id = mr.id
WHERE pz.publisher_id = $1 AND pz.zman_key = $2 AND pz.deleted_at IS NULL
`

type GetPublisherZmanByKeyParams struct {
	PublisherID string `json:"publisher_id"`
	ZmanKey     string `json:"zman_key"`
}

type GetPublisherZmanByKeyRow struct {
	ID                        string             `json:"id"`
	PublisherID               string             `json:"publisher_id"`
	ZmanKey                   string             `json:"zman_key"`
	HebrewName                string             `json:"hebrew_name"`
	EnglishName               string             `json:"english_name"`
	Transliteration           *string            `json:"transliteration"`
	Description               *string            `json:"description"`
	FormulaDsl                string             `json:"formula_dsl"`
	AiExplanation             *string            `json:"ai_explanation"`
	PublisherComment          *string            `json:"publisher_comment"`
	IsEnabled                 bool               `json:"is_enabled"`
	IsVisible                 bool               `json:"is_visible"`
	IsPublished               bool               `json:"is_published"`
	IsBeta                    bool               `json:"is_beta"`
	IsCustom                  bool               `json:"is_custom"`
	Category                  string             `json:"category"`
	Dependencies              []string           `json:"dependencies"`
	CreatedAt                 pgtype.Timestamptz `json:"created_at"`
	UpdatedAt                 pgtype.Timestamptz `json:"updated_at"`
	MasterZmanID              pgtype.UUID        `json:"master_zman_id"`
	LinkedPublisherZmanID     pgtype.UUID        `json:"linked_publisher_zman_id"`
	SourceType                *string            `json:"source_type"`
	SourceHebrewName          string             `json:"source_hebrew_name"`
	SourceEnglishName         string             `json:"source_english_name"`
	SourceTransliteration     *string            `json:"source_transliteration"`
	SourceDescription         *string            `json:"source_description"`
	SourceFormulaDsl          string             `json:"source_formula_dsl"`
	IsLinked                  bool               `json:"is_linked"`
	LinkedSourcePublisherName *string            `json:"linked_source_publisher_name"`
	TimeCategory              string             `json:"time_category"`
}

func (q *Queries) GetPublisherZmanByKey(ctx context.Context, arg GetPublisherZmanByKeyParams) (GetPublisherZmanByKeyRow, error) {
	row := q.db.QueryRow(ctx, getPublisherZmanByKey, arg.PublisherID, arg.ZmanKey)
	var i GetPublisherZmanByKeyRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.ZmanKey,
		&i.HebrewName,
		&i.EnglishName,
		&i.Transliteration,
		&i.Description,
		&i.FormulaDsl,
		&i.AiExplanation,
		&i.PublisherComment,
		&i.IsEnabled,
		&i.IsVisible,
		&i.IsPublished,
		&i.IsBeta,
		&i.IsCustom,
		&i.Category,
		&i.Dependencies,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MasterZmanID,
		&i.LinkedPublisherZmanID,
		&i.SourceType,
		&i.SourceHebrewName,
		&i.SourceEnglishName,
		&i.SourceTransliteration,
		&i.SourceDescription,
		&i.SourceFormulaDsl,
		&i.IsLinked,
		&i.LinkedSourcePublisherName,
		&i.TimeCategory,
	)
	return i, err
}

const getPublisherZmanTags = `-- name: GetPublisherZmanTags :many

SELECT
    t.id, t.tag_key, t.name, t.display_name_hebrew, t.display_name_english,
    t.tag_type, t.description, t.sort_order
FROM publisher_zman_tags pzt
JOIN zman_tags t ON t.id = pzt.tag_id
WHERE pzt.publisher_zman_id = $1
ORDER BY t.sort_order, t.display_name_english
`

type GetPublisherZmanTagsRow struct {
	ID                 string  `json:"id"`
	TagKey             string  `json:"tag_key"`
	Name               string  `json:"name"`
	DisplayNameHebrew  string  `json:"display_name_hebrew"`
	DisplayNameEnglish string  `json:"display_name_english"`
	TagType            string  `json:"tag_type"`
	Description        *string `json:"description"`
	SortOrder          *int32  `json:"sort_order"`
}

// ============================================================================
// Publisher Zman Tags
// ============================================================================
// Get all tags for a specific publisher zman
func (q *Queries) GetPublisherZmanTags(ctx context.Context, publisherZmanID string) ([]GetPublisherZmanTagsRow, error) {
	rows, err := q.db.Query(ctx, getPublisherZmanTags, publisherZmanID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPublisherZmanTagsRow{}
	for rows.Next() {
		var i GetPublisherZmanTagsRow
		if err := rows.Scan(
			&i.ID,
			&i.TagKey,
			&i.Name,
			&i.DisplayNameHebrew,
			&i.DisplayNameEnglish,
			&i.TagType,
			&i.Description,
			&i.SortOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublisherZmanim = `-- name: GetPublisherZmanim :many


SELECT
    pz.id, pz.publisher_id, pz.zman_key, pz.hebrew_name, pz.english_name,
    pz.transliteration, pz.description,
    -- Resolve formula from linked source if applicable
    COALESCE(linked_pz.formula_dsl, pz.formula_dsl) AS formula_dsl,
    pz.ai_explanation, pz.publisher_comment,
    pz.is_enabled, pz.is_visible, pz.is_published, pz.is_beta, pz.is_custom, pz.category,
    pz.dependencies, pz.created_at, pz.updated_at,
    pz.master_zman_id, pz.linked_publisher_zman_id, pz.source_type,
    -- Source/original values from registry or linked publisher (for diff/revert UI)
    COALESCE(mr.canonical_hebrew_name, linked_pz.hebrew_name) AS source_hebrew_name,
    COALESCE(mr.canonical_english_name, linked_pz.english_name) AS source_english_name,
    COALESCE(mr.transliteration, linked_pz.transliteration) AS source_transliteration,
    COALESCE(mr.description, linked_pz.description) AS source_description,
    COALESCE(mr.default_formula_dsl, linked_pz.formula_dsl) AS source_formula_dsl,
    -- Check if this zman is an event zman (has event or behavior tags like is_candle_lighting, is_havdalah, etc.)
    EXISTS (
        SELECT 1 FROM (
            -- Check master zman tags
            SELECT zt.tag_type FROM master_zman_tags mzt
            JOIN zman_tags zt ON mzt.tag_id = zt.id
            WHERE mzt.master_zman_id = pz.master_zman_id
            UNION ALL
            -- Check publisher-specific tags
            SELECT zt.tag_type FROM publisher_zman_tags pzt
            JOIN zman_tags zt ON pzt.tag_id = zt.id
            WHERE pzt.publisher_zman_id = pz.id
        ) all_tags
        WHERE all_tags.tag_type IN ('event', 'behavior')
    ) AS is_event_zman,
    -- Tags from master zman AND publisher-specific tags (combined, deduplicated)
    COALESCE(
        (SELECT json_agg(DISTINCT json_build_object(
            'id', t.id,
            'tag_key', t.tag_key,
            'name', t.name,
            'display_name_hebrew', t.display_name_hebrew,
            'display_name_english', t.display_name_english,
            'tag_type', t.tag_type
        ))
        FROM (
            -- Master zman tags
            SELECT t.id, t.tag_key, t.name, t.display_name_hebrew, t.display_name_english, t.tag_type, t.description, t.color, t.sort_order, t.created_at FROM master_zman_tags mzt
            JOIN zman_tags t ON mzt.tag_id = t.id
            WHERE mzt.master_zman_id = pz.master_zman_id
            UNION
            -- Publisher-specific tags
            SELECT t.id, t.tag_key, t.name, t.display_name_hebrew, t.display_name_english, t.tag_type, t.description, t.color, t.sort_order, t.created_at FROM publisher_zman_tags pzt
            JOIN zman_tags t ON pzt.tag_id = t.id
            WHERE pzt.publisher_zman_id = pz.id
        ) t),
        '[]'::json
    ) AS tags,
    -- Linked source info
    CASE WHEN pz.linked_publisher_zman_id IS NOT NULL THEN true ELSE false END AS is_linked,
    linked_pub.name AS linked_source_publisher_name,
    CASE WHEN pz.linked_publisher_zman_id IS NOT NULL AND linked_pz.deleted_at IS NOT NULL
         THEN true ELSE false END AS linked_source_is_deleted,
    -- Time category for ordering (from registry or inferred from category)
    COALESCE(mr.time_category, pz.category) AS time_category
FROM publisher_zmanim pz
LEFT JOIN publisher_zmanim linked_pz ON pz.linked_publisher_zman_id = linked_pz.id
LEFT JOIN publishers linked_pub ON linked_pz.publisher_id = linked_pub.id
LEFT JOIN master_zmanim_registry mr ON pz.master_zman_id = mr.id
WHERE pz.publisher_id = $1
  AND pz.deleted_at IS NULL
ORDER BY
    CASE COALESCE(mr.time_category, pz.category)
        WHEN 'dawn' THEN 1
        WHEN 'sunrise' THEN 2
        WHEN 'morning' THEN 3
        WHEN 'midday' THEN 4
        WHEN 'afternoon' THEN 5
        WHEN 'sunset' THEN 6
        WHEN 'nightfall' THEN 7
        WHEN 'midnight' THEN 8
        ELSE 9
    END,
    pz.hebrew_name
`

type GetPublisherZmanimRow struct {
	ID                        string             `json:"id"`
	PublisherID               string             `json:"publisher_id"`
	ZmanKey                   string             `json:"zman_key"`
	HebrewName                string             `json:"hebrew_name"`
	EnglishName               string             `json:"english_name"`
	Transliteration           *string            `json:"transliteration"`
	Description               *string            `json:"description"`
	FormulaDsl                string             `json:"formula_dsl"`
	AiExplanation             *string            `json:"ai_explanation"`
	PublisherComment          *string            `json:"publisher_comment"`
	IsEnabled                 bool               `json:"is_enabled"`
	IsVisible                 bool               `json:"is_visible"`
	IsPublished               bool               `json:"is_published"`
	IsBeta                    bool               `json:"is_beta"`
	IsCustom                  bool               `json:"is_custom"`
	Category                  string             `json:"category"`
	Dependencies              []string           `json:"dependencies"`
	CreatedAt                 pgtype.Timestamptz `json:"created_at"`
	UpdatedAt                 pgtype.Timestamptz `json:"updated_at"`
	MasterZmanID              pgtype.UUID        `json:"master_zman_id"`
	LinkedPublisherZmanID     pgtype.UUID        `json:"linked_publisher_zman_id"`
	SourceType                *string            `json:"source_type"`
	SourceHebrewName          string             `json:"source_hebrew_name"`
	SourceEnglishName         string             `json:"source_english_name"`
	SourceTransliteration     *string            `json:"source_transliteration"`
	SourceDescription         *string            `json:"source_description"`
	SourceFormulaDsl          string             `json:"source_formula_dsl"`
	IsEventZman               bool               `json:"is_event_zman"`
	Tags                      interface{}        `json:"tags"`
	IsLinked                  bool               `json:"is_linked"`
	LinkedSourcePublisherName *string            `json:"linked_source_publisher_name"`
	LinkedSourceIsDeleted     bool               `json:"linked_source_is_deleted"`
	TimeCategory              string             `json:"time_category"`
}

// Zmanim SQL Queries
// SQLc will generate type-safe Go code from these queries
// Publisher Zmanim --
// Orders by time_category (chronological) then hebrew_name
func (q *Queries) GetPublisherZmanim(ctx context.Context, publisherID string) ([]GetPublisherZmanimRow, error) {
	rows, err := q.db.Query(ctx, getPublisherZmanim, publisherID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPublisherZmanimRow{}
	for rows.Next() {
		var i GetPublisherZmanimRow
		if err := rows.Scan(
			&i.ID,
			&i.PublisherID,
			&i.ZmanKey,
			&i.HebrewName,
			&i.EnglishName,
			&i.Transliteration,
			&i.Description,
			&i.FormulaDsl,
			&i.AiExplanation,
			&i.PublisherComment,
			&i.IsEnabled,
			&i.IsVisible,
			&i.IsPublished,
			&i.IsBeta,
			&i.IsCustom,
			&i.Category,
			&i.Dependencies,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.MasterZmanID,
			&i.LinkedPublisherZmanID,
			&i.SourceType,
			&i.SourceHebrewName,
			&i.SourceEnglishName,
			&i.SourceTransliteration,
			&i.SourceDescription,
			&i.SourceFormulaDsl,
			&i.IsEventZman,
			&i.Tags,
			&i.IsLinked,
			&i.LinkedSourcePublisherName,
			&i.LinkedSourceIsDeleted,
			&i.TimeCategory,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublisherZmanimForLinking = `-- name: GetPublisherZmanimForLinking :many
SELECT
    pz.id, pz.publisher_id, pz.zman_key, pz.hebrew_name, pz.english_name,
    pz.formula_dsl, pz.category, pz.source_type,
    p.name AS publisher_name
FROM publisher_zmanim pz
JOIN publishers p ON p.id = pz.publisher_id
WHERE pz.publisher_id = $1
  AND pz.is_published = true
  AND pz.is_enabled = true
  AND pz.deleted_at IS NULL
  AND ($2::text IS NULL OR pz.zman_key NOT IN (
      SELECT zman_key FROM publisher_zmanim WHERE publisher_id = $2 AND deleted_at IS NULL
  ))
ORDER BY
    CASE pz.category
        WHEN 'dawn' THEN 1
        WHEN 'sunrise' THEN 2
        WHEN 'morning' THEN 3
        WHEN 'midday' THEN 4
        WHEN 'afternoon' THEN 5
        WHEN 'sunset' THEN 6
        WHEN 'nightfall' THEN 7
        WHEN 'midnight' THEN 8
        ELSE 9
    END,
    pz.hebrew_name
`

type GetPublisherZmanimForLinkingParams struct {
	PublisherID string `json:"publisher_id"`
	Column2     string `json:"column_2"`
}

type GetPublisherZmanimForLinkingRow struct {
	ID            string  `json:"id"`
	PublisherID   string  `json:"publisher_id"`
	ZmanKey       string  `json:"zman_key"`
	HebrewName    string  `json:"hebrew_name"`
	EnglishName   string  `json:"english_name"`
	FormulaDsl    string  `json:"formula_dsl"`
	Category      string  `json:"category"`
	SourceType    *string `json:"source_type"`
	PublisherName string  `json:"publisher_name"`
}

// Get published zmanim from a specific publisher for copying/linking
// Orders by category chronologically then hebrew_name
func (q *Queries) GetPublisherZmanimForLinking(ctx context.Context, arg GetPublisherZmanimForLinkingParams) ([]GetPublisherZmanimForLinkingRow, error) {
	rows, err := q.db.Query(ctx, getPublisherZmanimForLinking, arg.PublisherID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPublisherZmanimForLinkingRow{}
	for rows.Next() {
		var i GetPublisherZmanimForLinkingRow
		if err := rows.Scan(
			&i.ID,
			&i.PublisherID,
			&i.ZmanKey,
			&i.HebrewName,
			&i.EnglishName,
			&i.FormulaDsl,
			&i.Category,
			&i.SourceType,
			&i.PublisherName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVerifiedPublishersForLinking = `-- name: GetVerifiedPublishersForLinking :many

SELECT
    p.id, p.name, p.logo_url,
    COUNT(pz.id) AS zmanim_count
FROM publishers p
JOIN publisher_zmanim pz ON pz.publisher_id = p.id
    AND pz.is_published = true
    AND pz.is_enabled = true
    AND pz.deleted_at IS NULL
WHERE p.is_verified = true
  AND p.status = 'active'
  AND p.id != $1  -- Exclude self
GROUP BY p.id, p.name, p.logo_url
HAVING COUNT(pz.id) > 0
ORDER BY p.name
`

type GetVerifiedPublishersForLinkingRow struct {
	ID          string  `json:"id"`
	Name        string  `json:"name"`
	LogoUrl     *string `json:"logo_url"`
	ZmanimCount int64   `json:"zmanim_count"`
}

// Linked Zmanim Support --
// Get verified publishers that current publisher can link to (excludes self)
func (q *Queries) GetVerifiedPublishersForLinking(ctx context.Context, id string) ([]GetVerifiedPublishersForLinkingRow, error) {
	rows, err := q.db.Query(ctx, getVerifiedPublishersForLinking, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetVerifiedPublishersForLinkingRow{}
	for rows.Next() {
		var i GetVerifiedPublishersForLinkingRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.LogoUrl,
			&i.ZmanimCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getZmanimTemplateByKey = `-- name: GetZmanimTemplateByKey :one
SELECT
    id, zman_key, hebrew_name, english_name, formula_dsl,
    category, description, is_required,
    created_at, updated_at
FROM zmanim_templates
WHERE zman_key = $1
`

func (q *Queries) GetZmanimTemplateByKey(ctx context.Context, zmanKey string) (ZmanimTemplate, error) {
	row := q.db.QueryRow(ctx, getZmanimTemplateByKey, zmanKey)
	var i ZmanimTemplate
	err := row.Scan(
		&i.ID,
		&i.ZmanKey,
		&i.HebrewName,
		&i.EnglishName,
		&i.FormulaDsl,
		&i.Category,
		&i.Description,
		&i.IsRequired,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getZmanimTemplates = `-- name: GetZmanimTemplates :many

SELECT
    id, zman_key, hebrew_name, english_name, formula_dsl,
    category, description, is_required,
    created_at, updated_at
FROM zmanim_templates
ORDER BY category, hebrew_name
`

// Zmanim Templates --
// Orders by category then hebrew_name
func (q *Queries) GetZmanimTemplates(ctx context.Context) ([]ZmanimTemplate, error) {
	rows, err := q.db.Query(ctx, getZmanimTemplates)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ZmanimTemplate{}
	for rows.Next() {
		var i ZmanimTemplate
		if err := rows.Scan(
			&i.ID,
			&i.ZmanKey,
			&i.HebrewName,
			&i.EnglishName,
			&i.FormulaDsl,
			&i.Category,
			&i.Description,
			&i.IsRequired,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getZmanimTemplatesByKeys = `-- name: GetZmanimTemplatesByKeys :many
SELECT
    id, zman_key, hebrew_name, english_name, formula_dsl,
    category, description, is_required,
    created_at, updated_at
FROM zmanim_templates
WHERE zman_key = ANY($1::text[])
`

func (q *Queries) GetZmanimTemplatesByKeys(ctx context.Context, dollar_1 []string) ([]ZmanimTemplate, error) {
	rows, err := q.db.Query(ctx, getZmanimTemplatesByKeys, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ZmanimTemplate{}
	for rows.Next() {
		var i ZmanimTemplate
		if err := rows.Scan(
			&i.ID,
			&i.ZmanKey,
			&i.HebrewName,
			&i.EnglishName,
			&i.FormulaDsl,
			&i.Category,
			&i.Description,
			&i.IsRequired,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const importZmanimFromTemplates = `-- name: ImportZmanimFromTemplates :many

INSERT INTO publisher_zmanim (
    id, publisher_id, zman_key, hebrew_name, english_name,
    formula_dsl, ai_explanation, publisher_comment,
    is_enabled, is_visible, is_published, is_custom, category,
    dependencies
)
SELECT
    gen_random_uuid(), $1, zman_key, hebrew_name, english_name,
    formula_dsl, NULL, NULL,
    true, true, false, false, category,
    '{}'
FROM zmanim_templates
ON CONFLICT (publisher_id, zman_key) DO NOTHING
RETURNING id, publisher_id, zman_key, hebrew_name, english_name,
    formula_dsl, ai_explanation, publisher_comment,
    is_enabled, is_visible, is_published, is_custom, category,
    dependencies, created_at, updated_at
`

type ImportZmanimFromTemplatesRow struct {
	ID               string             `json:"id"`
	PublisherID      string             `json:"publisher_id"`
	ZmanKey          string             `json:"zman_key"`
	HebrewName       string             `json:"hebrew_name"`
	EnglishName      string             `json:"english_name"`
	FormulaDsl       string             `json:"formula_dsl"`
	AiExplanation    *string            `json:"ai_explanation"`
	PublisherComment *string            `json:"publisher_comment"`
	IsEnabled        bool               `json:"is_enabled"`
	IsVisible        bool               `json:"is_visible"`
	IsPublished      bool               `json:"is_published"`
	IsCustom         bool               `json:"is_custom"`
	Category         string             `json:"category"`
	Dependencies     []string           `json:"dependencies"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
}

// Import from templates to publisher --
func (q *Queries) ImportZmanimFromTemplates(ctx context.Context, publisherID string) ([]ImportZmanimFromTemplatesRow, error) {
	rows, err := q.db.Query(ctx, importZmanimFromTemplates, publisherID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ImportZmanimFromTemplatesRow{}
	for rows.Next() {
		var i ImportZmanimFromTemplatesRow
		if err := rows.Scan(
			&i.ID,
			&i.PublisherID,
			&i.ZmanKey,
			&i.HebrewName,
			&i.EnglishName,
			&i.FormulaDsl,
			&i.AiExplanation,
			&i.PublisherComment,
			&i.IsEnabled,
			&i.IsVisible,
			&i.IsPublished,
			&i.IsCustom,
			&i.Category,
			&i.Dependencies,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const importZmanimFromTemplatesByKeys = `-- name: ImportZmanimFromTemplatesByKeys :many
INSERT INTO publisher_zmanim (
    id, publisher_id, zman_key, hebrew_name, english_name,
    formula_dsl, ai_explanation, publisher_comment,
    is_enabled, is_visible, is_published, is_custom, category,
    dependencies
)
SELECT
    gen_random_uuid(), $1, zman_key, hebrew_name, english_name,
    formula_dsl, NULL, NULL,
    true, true, false, false, category,
    '{}'
FROM zmanim_templates
WHERE zman_key = ANY($2::text[])
ON CONFLICT (publisher_id, zman_key) DO NOTHING
RETURNING id, publisher_id, zman_key, hebrew_name, english_name,
    formula_dsl, ai_explanation, publisher_comment,
    is_enabled, is_visible, is_published, is_custom, category,
    dependencies, created_at, updated_at
`

type ImportZmanimFromTemplatesByKeysParams struct {
	PublisherID string   `json:"publisher_id"`
	Column2     []string `json:"column_2"`
}

type ImportZmanimFromTemplatesByKeysRow struct {
	ID               string             `json:"id"`
	PublisherID      string             `json:"publisher_id"`
	ZmanKey          string             `json:"zman_key"`
	HebrewName       string             `json:"hebrew_name"`
	EnglishName      string             `json:"english_name"`
	FormulaDsl       string             `json:"formula_dsl"`
	AiExplanation    *string            `json:"ai_explanation"`
	PublisherComment *string            `json:"publisher_comment"`
	IsEnabled        bool               `json:"is_enabled"`
	IsVisible        bool               `json:"is_visible"`
	IsPublished      bool               `json:"is_published"`
	IsCustom         bool               `json:"is_custom"`
	Category         string             `json:"category"`
	Dependencies     []string           `json:"dependencies"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) ImportZmanimFromTemplatesByKeys(ctx context.Context, arg ImportZmanimFromTemplatesByKeysParams) ([]ImportZmanimFromTemplatesByKeysRow, error) {
	rows, err := q.db.Query(ctx, importZmanimFromTemplatesByKeys, arg.PublisherID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ImportZmanimFromTemplatesByKeysRow{}
	for rows.Next() {
		var i ImportZmanimFromTemplatesByKeysRow
		if err := rows.Scan(
			&i.ID,
			&i.PublisherID,
			&i.ZmanKey,
			&i.HebrewName,
			&i.EnglishName,
			&i.FormulaDsl,
			&i.AiExplanation,
			&i.PublisherComment,
			&i.IsEnabled,
			&i.IsVisible,
			&i.IsPublished,
			&i.IsCustom,
			&i.Category,
			&i.Dependencies,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const publishAllZmanim = `-- name: PublishAllZmanim :exec

UPDATE publisher_zmanim
SET is_published = true, updated_at = NOW()
WHERE publisher_id = $1 AND is_enabled = true
`

// Bulk publish/unpublish zmanim --
func (q *Queries) PublishAllZmanim(ctx context.Context, publisherID string) error {
	_, err := q.db.Exec(ctx, publishAllZmanim, publisherID)
	return err
}

const publishZmanimByKeys = `-- name: PublishZmanimByKeys :exec
UPDATE publisher_zmanim
SET is_published = true, updated_at = NOW()
WHERE publisher_id = $1 AND zman_key = ANY($2::text[])
`

type PublishZmanimByKeysParams struct {
	PublisherID string   `json:"publisher_id"`
	Column2     []string `json:"column_2"`
}

func (q *Queries) PublishZmanimByKeys(ctx context.Context, arg PublishZmanimByKeysParams) error {
	_, err := q.db.Exec(ctx, publishZmanimByKeys, arg.PublisherID, arg.Column2)
	return err
}

const removeTagFromPublisherZman = `-- name: RemoveTagFromPublisherZman :exec
DELETE FROM publisher_zman_tags
WHERE publisher_zman_id = $1 AND tag_id = $2
`

type RemoveTagFromPublisherZmanParams struct {
	PublisherZmanID string `json:"publisher_zman_id"`
	TagID           string `json:"tag_id"`
}

// Remove a tag from a publisher zman
func (q *Queries) RemoveTagFromPublisherZman(ctx context.Context, arg RemoveTagFromPublisherZmanParams) error {
	_, err := q.db.Exec(ctx, removeTagFromPublisherZman, arg.PublisherZmanID, arg.TagID)
	return err
}

const setPublisherZmanTags = `-- name: SetPublisherZmanTags :exec
DELETE FROM publisher_zman_tags WHERE publisher_zman_id = $1
`

// Replace all tags for a publisher zman (delete existing, insert new)
// First delete all existing tags for the zman
func (q *Queries) SetPublisherZmanTags(ctx context.Context, publisherZmanID string) error {
	_, err := q.db.Exec(ctx, setPublisherZmanTags, publisherZmanID)
	return err
}

const unpublishAllZmanim = `-- name: UnpublishAllZmanim :exec
UPDATE publisher_zmanim
SET is_published = false, updated_at = NOW()
WHERE publisher_id = $1
`

func (q *Queries) UnpublishAllZmanim(ctx context.Context, publisherID string) error {
	_, err := q.db.Exec(ctx, unpublishAllZmanim, publisherID)
	return err
}

const unpublishZmanimByKeys = `-- name: UnpublishZmanimByKeys :exec
UPDATE publisher_zmanim
SET is_published = false, updated_at = NOW()
WHERE publisher_id = $1 AND zman_key = ANY($2::text[])
`

type UnpublishZmanimByKeysParams struct {
	PublisherID string   `json:"publisher_id"`
	Column2     []string `json:"column_2"`
}

func (q *Queries) UnpublishZmanimByKeys(ctx context.Context, arg UnpublishZmanimByKeysParams) error {
	_, err := q.db.Exec(ctx, unpublishZmanimByKeys, arg.PublisherID, arg.Column2)
	return err
}

const updatePublisherZman = `-- name: UpdatePublisherZman :one
UPDATE publisher_zmanim
SET hebrew_name = COALESCE($3, hebrew_name),
    english_name = COALESCE($4, english_name),
    transliteration = COALESCE($5, transliteration),
    description = COALESCE($6, description),
    formula_dsl = COALESCE($7, formula_dsl),
    ai_explanation = COALESCE($8, ai_explanation),
    publisher_comment = COALESCE($9, publisher_comment),
    is_enabled = COALESCE($10, is_enabled),
    is_visible = COALESCE($11, is_visible),
    is_published = COALESCE($12, is_published),
    is_beta = COALESCE($13, is_beta),
    certified_at = CASE
        WHEN $13::boolean = false AND is_beta = true THEN NOW()
        ELSE certified_at
    END,
    category = COALESCE($14, category),
    dependencies = COALESCE($15, dependencies),
    updated_at = NOW()
WHERE publisher_id = $1 AND zman_key = $2
RETURNING id, publisher_id, zman_key, hebrew_name, english_name,
    transliteration, description, formula_dsl, ai_explanation, publisher_comment,
    is_enabled, is_visible, is_published, is_beta, is_custom, category,
    dependencies, created_at, updated_at
`

type UpdatePublisherZmanParams struct {
	PublisherID      string   `json:"publisher_id"`
	ZmanKey          string   `json:"zman_key"`
	HebrewName       *string  `json:"hebrew_name"`
	EnglishName      *string  `json:"english_name"`
	Transliteration  *string  `json:"transliteration"`
	Description      *string  `json:"description"`
	FormulaDsl       *string  `json:"formula_dsl"`
	AiExplanation    *string  `json:"ai_explanation"`
	PublisherComment *string  `json:"publisher_comment"`
	IsEnabled        *bool    `json:"is_enabled"`
	IsVisible        *bool    `json:"is_visible"`
	IsPublished      *bool    `json:"is_published"`
	IsBeta           *bool    `json:"is_beta"`
	Category         *string  `json:"category"`
	Dependencies     []string `json:"dependencies"`
}

type UpdatePublisherZmanRow struct {
	ID               string             `json:"id"`
	PublisherID      string             `json:"publisher_id"`
	ZmanKey          string             `json:"zman_key"`
	HebrewName       string             `json:"hebrew_name"`
	EnglishName      string             `json:"english_name"`
	Transliteration  *string            `json:"transliteration"`
	Description      *string            `json:"description"`
	FormulaDsl       string             `json:"formula_dsl"`
	AiExplanation    *string            `json:"ai_explanation"`
	PublisherComment *string            `json:"publisher_comment"`
	IsEnabled        bool               `json:"is_enabled"`
	IsVisible        bool               `json:"is_visible"`
	IsPublished      bool               `json:"is_published"`
	IsBeta           bool               `json:"is_beta"`
	IsCustom         bool               `json:"is_custom"`
	Category         string             `json:"category"`
	Dependencies     []string           `json:"dependencies"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) UpdatePublisherZman(ctx context.Context, arg UpdatePublisherZmanParams) (UpdatePublisherZmanRow, error) {
	row := q.db.QueryRow(ctx, updatePublisherZman,
		arg.PublisherID,
		arg.ZmanKey,
		arg.HebrewName,
		arg.EnglishName,
		arg.Transliteration,
		arg.Description,
		arg.FormulaDsl,
		arg.AiExplanation,
		arg.PublisherComment,
		arg.IsEnabled,
		arg.IsVisible,
		arg.IsPublished,
		arg.IsBeta,
		arg.Category,
		arg.Dependencies,
	)
	var i UpdatePublisherZmanRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.ZmanKey,
		&i.HebrewName,
		&i.EnglishName,
		&i.Transliteration,
		&i.Description,
		&i.FormulaDsl,
		&i.AiExplanation,
		&i.PublisherComment,
		&i.IsEnabled,
		&i.IsVisible,
		&i.IsPublished,
		&i.IsBeta,
		&i.IsCustom,
		&i.Category,
		&i.Dependencies,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
