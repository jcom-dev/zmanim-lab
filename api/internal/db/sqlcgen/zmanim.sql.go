// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: zmanim.sql

package sqlcgen

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const browsePublicZmanim = `-- name: BrowsePublicZmanim :many

SELECT
    z.id, z.publisher_id, z.zman_key, z.hebrew_name, z.english_name,
    z.formula_dsl, z.category,
    p.name as publisher_name,
    COUNT(*) OVER (PARTITION BY z.zman_key) as usage_count
FROM publisher_zmanim z
JOIN publishers p ON p.id = z.publisher_id
WHERE z.is_visible = true
  AND z.is_published = true
  AND ($1::text IS NULL OR z.hebrew_name ILIKE '%' || $1 || '%' OR z.english_name ILIKE '%' || $1 || '%')
  AND ($2::text IS NULL OR z.category = $2)
ORDER BY usage_count DESC, z.hebrew_name
LIMIT 50
`

type BrowsePublicZmanimParams struct {
	Column1 string `json:"column_1"`
	Column2 string `json:"column_2"`
}

type BrowsePublicZmanimRow struct {
	ID            string `json:"id"`
	PublisherID   string `json:"publisher_id"`
	ZmanKey       string `json:"zman_key"`
	HebrewName    string `json:"hebrew_name"`
	EnglishName   string `json:"english_name"`
	FormulaDsl    string `json:"formula_dsl"`
	Category      string `json:"category"`
	PublisherName string `json:"publisher_name"`
	UsageCount    int64  `json:"usage_count"`
}

// Browse public zmanim --
func (q *Queries) BrowsePublicZmanim(ctx context.Context, arg BrowsePublicZmanimParams) ([]BrowsePublicZmanimRow, error) {
	rows, err := q.db.Query(ctx, browsePublicZmanim, arg.Column1, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []BrowsePublicZmanimRow{}
	for rows.Next() {
		var i BrowsePublicZmanimRow
		if err := rows.Scan(
			&i.ID,
			&i.PublisherID,
			&i.ZmanKey,
			&i.HebrewName,
			&i.EnglishName,
			&i.FormulaDsl,
			&i.Category,
			&i.PublisherName,
			&i.UsageCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countPublisherZmanim = `-- name: CountPublisherZmanim :one
SELECT COUNT(*) FROM publisher_zmanim WHERE publisher_id = $1
`

func (q *Queries) CountPublisherZmanim(ctx context.Context, publisherID string) (int64, error) {
	row := q.db.QueryRow(ctx, countPublisherZmanim, publisherID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPublisherZman = `-- name: CreatePublisherZman :one
INSERT INTO publisher_zmanim (
    id, publisher_id, zman_key, hebrew_name, english_name,
    formula_dsl, ai_explanation, publisher_comment,
    is_enabled, is_visible, is_published, is_custom, category,
    dependencies, sort_order, master_zman_id, linked_publisher_zman_id, source_type
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18
)
RETURNING id, publisher_id, zman_key, hebrew_name, english_name,
    formula_dsl, ai_explanation, publisher_comment,
    is_enabled, is_visible, is_published, is_custom, category,
    dependencies, sort_order, master_zman_id, linked_publisher_zman_id, source_type,
    created_at, updated_at
`

type CreatePublisherZmanParams struct {
	ID                    string      `json:"id"`
	PublisherID           string      `json:"publisher_id"`
	ZmanKey               string      `json:"zman_key"`
	HebrewName            string      `json:"hebrew_name"`
	EnglishName           string      `json:"english_name"`
	FormulaDsl            string      `json:"formula_dsl"`
	AiExplanation         *string     `json:"ai_explanation"`
	PublisherComment      *string     `json:"publisher_comment"`
	IsEnabled             bool        `json:"is_enabled"`
	IsVisible             bool        `json:"is_visible"`
	IsPublished           bool        `json:"is_published"`
	IsCustom              bool        `json:"is_custom"`
	Category              string      `json:"category"`
	Dependencies          []string    `json:"dependencies"`
	SortOrder             int32       `json:"sort_order"`
	MasterZmanID          pgtype.UUID `json:"master_zman_id"`
	LinkedPublisherZmanID pgtype.UUID `json:"linked_publisher_zman_id"`
	SourceType            *string     `json:"source_type"`
}

type CreatePublisherZmanRow struct {
	ID                    string      `json:"id"`
	PublisherID           string      `json:"publisher_id"`
	ZmanKey               string      `json:"zman_key"`
	HebrewName            string      `json:"hebrew_name"`
	EnglishName           string      `json:"english_name"`
	FormulaDsl            string      `json:"formula_dsl"`
	AiExplanation         *string     `json:"ai_explanation"`
	PublisherComment      *string     `json:"publisher_comment"`
	IsEnabled             bool        `json:"is_enabled"`
	IsVisible             bool        `json:"is_visible"`
	IsPublished           bool        `json:"is_published"`
	IsCustom              bool        `json:"is_custom"`
	Category              string      `json:"category"`
	Dependencies          []string    `json:"dependencies"`
	SortOrder             int32       `json:"sort_order"`
	MasterZmanID          pgtype.UUID `json:"master_zman_id"`
	LinkedPublisherZmanID pgtype.UUID `json:"linked_publisher_zman_id"`
	SourceType            *string     `json:"source_type"`
	CreatedAt             time.Time   `json:"created_at"`
	UpdatedAt             time.Time   `json:"updated_at"`
}

func (q *Queries) CreatePublisherZman(ctx context.Context, arg CreatePublisherZmanParams) (CreatePublisherZmanRow, error) {
	row := q.db.QueryRow(ctx, createPublisherZman,
		arg.ID,
		arg.PublisherID,
		arg.ZmanKey,
		arg.HebrewName,
		arg.EnglishName,
		arg.FormulaDsl,
		arg.AiExplanation,
		arg.PublisherComment,
		arg.IsEnabled,
		arg.IsVisible,
		arg.IsPublished,
		arg.IsCustom,
		arg.Category,
		arg.Dependencies,
		arg.SortOrder,
		arg.MasterZmanID,
		arg.LinkedPublisherZmanID,
		arg.SourceType,
	)
	var i CreatePublisherZmanRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.ZmanKey,
		&i.HebrewName,
		&i.EnglishName,
		&i.FormulaDsl,
		&i.AiExplanation,
		&i.PublisherComment,
		&i.IsEnabled,
		&i.IsVisible,
		&i.IsPublished,
		&i.IsCustom,
		&i.Category,
		&i.Dependencies,
		&i.SortOrder,
		&i.MasterZmanID,
		&i.LinkedPublisherZmanID,
		&i.SourceType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePublisherZman = `-- name: DeletePublisherZman :one
DELETE FROM publisher_zmanim
WHERE publisher_id = $1 AND zman_key = $2 AND is_custom = true
RETURNING id
`

type DeletePublisherZmanParams struct {
	PublisherID string `json:"publisher_id"`
	ZmanKey     string `json:"zman_key"`
}

func (q *Queries) DeletePublisherZman(ctx context.Context, arg DeletePublisherZmanParams) (string, error) {
	row := q.db.QueryRow(ctx, deletePublisherZman, arg.PublisherID, arg.ZmanKey)
	var id string
	err := row.Scan(&id)
	return id, err
}

const getPublisherZmanByID = `-- name: GetPublisherZmanByID :one
SELECT
    pz.id, pz.publisher_id, pz.zman_key, pz.hebrew_name, pz.english_name,
    pz.formula_dsl, pz.ai_explanation, pz.publisher_comment,
    pz.is_enabled, pz.is_visible, pz.is_published, pz.is_custom, pz.category,
    pz.dependencies, pz.sort_order, pz.master_zman_id, pz.linked_publisher_zman_id,
    pz.source_type, pz.deleted_at, pz.created_at, pz.updated_at,
    p.name AS publisher_name,
    p.is_verified AS publisher_is_verified
FROM publisher_zmanim pz
JOIN publishers p ON p.id = pz.publisher_id
WHERE pz.id = $1
`

type GetPublisherZmanByIDRow struct {
	ID                    string             `json:"id"`
	PublisherID           string             `json:"publisher_id"`
	ZmanKey               string             `json:"zman_key"`
	HebrewName            string             `json:"hebrew_name"`
	EnglishName           string             `json:"english_name"`
	FormulaDsl            string             `json:"formula_dsl"`
	AiExplanation         *string            `json:"ai_explanation"`
	PublisherComment      *string            `json:"publisher_comment"`
	IsEnabled             bool               `json:"is_enabled"`
	IsVisible             bool               `json:"is_visible"`
	IsPublished           bool               `json:"is_published"`
	IsCustom              bool               `json:"is_custom"`
	Category              string             `json:"category"`
	Dependencies          []string           `json:"dependencies"`
	SortOrder             int32              `json:"sort_order"`
	MasterZmanID          pgtype.UUID        `json:"master_zman_id"`
	LinkedPublisherZmanID pgtype.UUID        `json:"linked_publisher_zman_id"`
	SourceType            *string            `json:"source_type"`
	DeletedAt             pgtype.Timestamptz `json:"deleted_at"`
	CreatedAt             time.Time          `json:"created_at"`
	UpdatedAt             time.Time          `json:"updated_at"`
	PublisherName         string             `json:"publisher_name"`
	PublisherIsVerified   bool               `json:"publisher_is_verified"`
}

// Get a specific zman by ID (for linking validation)
func (q *Queries) GetPublisherZmanByID(ctx context.Context, id string) (GetPublisherZmanByIDRow, error) {
	row := q.db.QueryRow(ctx, getPublisherZmanByID, id)
	var i GetPublisherZmanByIDRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.ZmanKey,
		&i.HebrewName,
		&i.EnglishName,
		&i.FormulaDsl,
		&i.AiExplanation,
		&i.PublisherComment,
		&i.IsEnabled,
		&i.IsVisible,
		&i.IsPublished,
		&i.IsCustom,
		&i.Category,
		&i.Dependencies,
		&i.SortOrder,
		&i.MasterZmanID,
		&i.LinkedPublisherZmanID,
		&i.SourceType,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublisherName,
		&i.PublisherIsVerified,
	)
	return i, err
}

const getPublisherZmanByKey = `-- name: GetPublisherZmanByKey :one
SELECT
    id, publisher_id, zman_key, hebrew_name, english_name,
    formula_dsl, ai_explanation, publisher_comment,
    is_enabled, is_visible, is_published, is_custom, category,
    dependencies, sort_order, created_at, updated_at
FROM publisher_zmanim
WHERE publisher_id = $1 AND zman_key = $2
`

type GetPublisherZmanByKeyParams struct {
	PublisherID string `json:"publisher_id"`
	ZmanKey     string `json:"zman_key"`
}

type GetPublisherZmanByKeyRow struct {
	ID               string    `json:"id"`
	PublisherID      string    `json:"publisher_id"`
	ZmanKey          string    `json:"zman_key"`
	HebrewName       string    `json:"hebrew_name"`
	EnglishName      string    `json:"english_name"`
	FormulaDsl       string    `json:"formula_dsl"`
	AiExplanation    *string   `json:"ai_explanation"`
	PublisherComment *string   `json:"publisher_comment"`
	IsEnabled        bool      `json:"is_enabled"`
	IsVisible        bool      `json:"is_visible"`
	IsPublished      bool      `json:"is_published"`
	IsCustom         bool      `json:"is_custom"`
	Category         string    `json:"category"`
	Dependencies     []string  `json:"dependencies"`
	SortOrder        int32     `json:"sort_order"`
	CreatedAt        time.Time `json:"created_at"`
	UpdatedAt        time.Time `json:"updated_at"`
}

func (q *Queries) GetPublisherZmanByKey(ctx context.Context, arg GetPublisherZmanByKeyParams) (GetPublisherZmanByKeyRow, error) {
	row := q.db.QueryRow(ctx, getPublisherZmanByKey, arg.PublisherID, arg.ZmanKey)
	var i GetPublisherZmanByKeyRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.ZmanKey,
		&i.HebrewName,
		&i.EnglishName,
		&i.FormulaDsl,
		&i.AiExplanation,
		&i.PublisherComment,
		&i.IsEnabled,
		&i.IsVisible,
		&i.IsPublished,
		&i.IsCustom,
		&i.Category,
		&i.Dependencies,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPublisherZmanim = `-- name: GetPublisherZmanim :many


SELECT
    pz.id, pz.publisher_id, pz.zman_key, pz.hebrew_name, pz.english_name,
    -- Resolve formula from linked source if applicable
    COALESCE(linked_pz.formula_dsl, pz.formula_dsl) AS formula_dsl,
    pz.ai_explanation, pz.publisher_comment,
    pz.is_enabled, pz.is_visible, pz.is_published, pz.is_custom, pz.category,
    pz.dependencies, pz.sort_order, pz.created_at, pz.updated_at,
    pz.master_zman_id, pz.linked_publisher_zman_id, pz.source_type,
    -- Check if this zman is linked to any events (daily zmanim have no event links)
    EXISTS (
        SELECT 1 FROM master_zman_events mze
        WHERE mze.master_zman_id = pz.master_zman_id
    ) AS is_event_zman,
    -- Tags from master zman (if from registry)
    COALESCE(
        (SELECT json_agg(json_build_object(
            'id', t.id,
            'tag_key', t.tag_key,
            'name', t.name,
            'display_name_hebrew', t.display_name_hebrew,
            'display_name_english', t.display_name_english,
            'tag_type', t.tag_type
        ) ORDER BY t.sort_order)
        FROM master_zman_tags mzt
        JOIN zman_tags t ON mzt.tag_id = t.id
        WHERE mzt.master_zman_id = pz.master_zman_id),
        '[]'::json
    ) AS tags,
    -- Linked source info
    CASE WHEN pz.linked_publisher_zman_id IS NOT NULL THEN true ELSE false END AS is_linked,
    linked_pub.name AS linked_source_publisher_name,
    CASE WHEN pz.linked_publisher_zman_id IS NOT NULL AND linked_pz.deleted_at IS NOT NULL
         THEN true ELSE false END AS linked_source_is_deleted
FROM publisher_zmanim pz
LEFT JOIN publisher_zmanim linked_pz ON pz.linked_publisher_zman_id = linked_pz.id
LEFT JOIN publishers linked_pub ON linked_pz.publisher_id = linked_pub.id
WHERE pz.publisher_id = $1
  AND pz.deleted_at IS NULL
ORDER BY pz.sort_order, pz.hebrew_name
`

type GetPublisherZmanimRow struct {
	ID                        string      `json:"id"`
	PublisherID               string      `json:"publisher_id"`
	ZmanKey                   string      `json:"zman_key"`
	HebrewName                string      `json:"hebrew_name"`
	EnglishName               string      `json:"english_name"`
	FormulaDsl                string      `json:"formula_dsl"`
	AiExplanation             *string     `json:"ai_explanation"`
	PublisherComment          *string     `json:"publisher_comment"`
	IsEnabled                 bool        `json:"is_enabled"`
	IsVisible                 bool        `json:"is_visible"`
	IsPublished               bool        `json:"is_published"`
	IsCustom                  bool        `json:"is_custom"`
	Category                  string      `json:"category"`
	Dependencies              []string    `json:"dependencies"`
	SortOrder                 int32       `json:"sort_order"`
	CreatedAt                 time.Time   `json:"created_at"`
	UpdatedAt                 time.Time   `json:"updated_at"`
	MasterZmanID              pgtype.UUID `json:"master_zman_id"`
	LinkedPublisherZmanID     pgtype.UUID `json:"linked_publisher_zman_id"`
	SourceType                *string     `json:"source_type"`
	IsEventZman               bool        `json:"is_event_zman"`
	Tags                      interface{} `json:"tags"`
	IsLinked                  bool        `json:"is_linked"`
	LinkedSourcePublisherName *string     `json:"linked_source_publisher_name"`
	LinkedSourceIsDeleted     bool        `json:"linked_source_is_deleted"`
}

// Zmanim SQL Queries
// SQLc will generate type-safe Go code from these queries
// Publisher Zmanim --
func (q *Queries) GetPublisherZmanim(ctx context.Context, publisherID string) ([]GetPublisherZmanimRow, error) {
	rows, err := q.db.Query(ctx, getPublisherZmanim, publisherID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPublisherZmanimRow{}
	for rows.Next() {
		var i GetPublisherZmanimRow
		if err := rows.Scan(
			&i.ID,
			&i.PublisherID,
			&i.ZmanKey,
			&i.HebrewName,
			&i.EnglishName,
			&i.FormulaDsl,
			&i.AiExplanation,
			&i.PublisherComment,
			&i.IsEnabled,
			&i.IsVisible,
			&i.IsPublished,
			&i.IsCustom,
			&i.Category,
			&i.Dependencies,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.MasterZmanID,
			&i.LinkedPublisherZmanID,
			&i.SourceType,
			&i.IsEventZman,
			&i.Tags,
			&i.IsLinked,
			&i.LinkedSourcePublisherName,
			&i.LinkedSourceIsDeleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublisherZmanimForLinking = `-- name: GetPublisherZmanimForLinking :many
SELECT
    pz.id, pz.publisher_id, pz.zman_key, pz.hebrew_name, pz.english_name,
    pz.formula_dsl, pz.category, pz.source_type,
    p.name AS publisher_name
FROM publisher_zmanim pz
JOIN publishers p ON p.id = pz.publisher_id
WHERE pz.publisher_id = $1
  AND pz.is_published = true
  AND pz.is_enabled = true
  AND pz.deleted_at IS NULL
  AND ($2::text IS NULL OR pz.zman_key NOT IN (
      SELECT zman_key FROM publisher_zmanim WHERE publisher_id = $2 AND deleted_at IS NULL
  ))
ORDER BY pz.sort_order, pz.hebrew_name
`

type GetPublisherZmanimForLinkingParams struct {
	PublisherID string `json:"publisher_id"`
	Column2     string `json:"column_2"`
}

type GetPublisherZmanimForLinkingRow struct {
	ID            string  `json:"id"`
	PublisherID   string  `json:"publisher_id"`
	ZmanKey       string  `json:"zman_key"`
	HebrewName    string  `json:"hebrew_name"`
	EnglishName   string  `json:"english_name"`
	FormulaDsl    string  `json:"formula_dsl"`
	Category      string  `json:"category"`
	SourceType    *string `json:"source_type"`
	PublisherName string  `json:"publisher_name"`
}

// Get published zmanim from a specific publisher for copying/linking
func (q *Queries) GetPublisherZmanimForLinking(ctx context.Context, arg GetPublisherZmanimForLinkingParams) ([]GetPublisherZmanimForLinkingRow, error) {
	rows, err := q.db.Query(ctx, getPublisherZmanimForLinking, arg.PublisherID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPublisherZmanimForLinkingRow{}
	for rows.Next() {
		var i GetPublisherZmanimForLinkingRow
		if err := rows.Scan(
			&i.ID,
			&i.PublisherID,
			&i.ZmanKey,
			&i.HebrewName,
			&i.EnglishName,
			&i.FormulaDsl,
			&i.Category,
			&i.SourceType,
			&i.PublisherName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVerifiedPublishersForLinking = `-- name: GetVerifiedPublishersForLinking :many

SELECT
    p.id, p.name, p.organization, p.logo_url,
    COUNT(pz.id) AS zmanim_count
FROM publishers p
JOIN publisher_zmanim pz ON pz.publisher_id = p.id
    AND pz.is_published = true
    AND pz.is_enabled = true
    AND pz.deleted_at IS NULL
WHERE p.is_verified = true
  AND p.status = 'active'
  AND p.id != $1  -- Exclude self
GROUP BY p.id, p.name, p.organization, p.logo_url
HAVING COUNT(pz.id) > 0
ORDER BY p.name
`

type GetVerifiedPublishersForLinkingRow struct {
	ID           string  `json:"id"`
	Name         string  `json:"name"`
	Organization *string `json:"organization"`
	LogoUrl      *string `json:"logo_url"`
	ZmanimCount  int64   `json:"zmanim_count"`
}

// Linked Zmanim Support --
// Get verified publishers that current publisher can link to (excludes self)
func (q *Queries) GetVerifiedPublishersForLinking(ctx context.Context, id string) ([]GetVerifiedPublishersForLinkingRow, error) {
	rows, err := q.db.Query(ctx, getVerifiedPublishersForLinking, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetVerifiedPublishersForLinkingRow{}
	for rows.Next() {
		var i GetVerifiedPublishersForLinkingRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Organization,
			&i.LogoUrl,
			&i.ZmanimCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getZmanimTemplateByKey = `-- name: GetZmanimTemplateByKey :one
SELECT
    id, zman_key, hebrew_name, english_name, formula_dsl,
    category, description, is_required, sort_order,
    created_at, updated_at
FROM zmanim_templates
WHERE zman_key = $1
`

func (q *Queries) GetZmanimTemplateByKey(ctx context.Context, zmanKey string) (ZmanimTemplate, error) {
	row := q.db.QueryRow(ctx, getZmanimTemplateByKey, zmanKey)
	var i ZmanimTemplate
	err := row.Scan(
		&i.ID,
		&i.ZmanKey,
		&i.HebrewName,
		&i.EnglishName,
		&i.FormulaDsl,
		&i.Category,
		&i.Description,
		&i.IsRequired,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getZmanimTemplates = `-- name: GetZmanimTemplates :many

SELECT
    id, zman_key, hebrew_name, english_name, formula_dsl,
    category, description, is_required, sort_order,
    created_at, updated_at
FROM zmanim_templates
ORDER BY category, sort_order, hebrew_name
`

// Zmanim Templates --
func (q *Queries) GetZmanimTemplates(ctx context.Context) ([]ZmanimTemplate, error) {
	rows, err := q.db.Query(ctx, getZmanimTemplates)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ZmanimTemplate{}
	for rows.Next() {
		var i ZmanimTemplate
		if err := rows.Scan(
			&i.ID,
			&i.ZmanKey,
			&i.HebrewName,
			&i.EnglishName,
			&i.FormulaDsl,
			&i.Category,
			&i.Description,
			&i.IsRequired,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getZmanimTemplatesByKeys = `-- name: GetZmanimTemplatesByKeys :many
SELECT
    id, zman_key, hebrew_name, english_name, formula_dsl,
    category, description, is_required, sort_order,
    created_at, updated_at
FROM zmanim_templates
WHERE zman_key = ANY($1::text[])
`

func (q *Queries) GetZmanimTemplatesByKeys(ctx context.Context, dollar_1 []string) ([]ZmanimTemplate, error) {
	rows, err := q.db.Query(ctx, getZmanimTemplatesByKeys, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ZmanimTemplate{}
	for rows.Next() {
		var i ZmanimTemplate
		if err := rows.Scan(
			&i.ID,
			&i.ZmanKey,
			&i.HebrewName,
			&i.EnglishName,
			&i.FormulaDsl,
			&i.Category,
			&i.Description,
			&i.IsRequired,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const importZmanimFromTemplates = `-- name: ImportZmanimFromTemplates :many

INSERT INTO publisher_zmanim (
    id, publisher_id, zman_key, hebrew_name, english_name,
    formula_dsl, ai_explanation, publisher_comment,
    is_enabled, is_visible, is_published, is_custom, category,
    dependencies, sort_order
)
SELECT
    gen_random_uuid(), $1, zman_key, hebrew_name, english_name,
    formula_dsl, NULL, NULL,
    true, true, false, false, category,
    '{}', sort_order
FROM zmanim_templates
ON CONFLICT (publisher_id, zman_key) DO NOTHING
RETURNING id, publisher_id, zman_key, hebrew_name, english_name,
    formula_dsl, ai_explanation, publisher_comment,
    is_enabled, is_visible, is_published, is_custom, category,
    dependencies, sort_order, created_at, updated_at
`

type ImportZmanimFromTemplatesRow struct {
	ID               string    `json:"id"`
	PublisherID      string    `json:"publisher_id"`
	ZmanKey          string    `json:"zman_key"`
	HebrewName       string    `json:"hebrew_name"`
	EnglishName      string    `json:"english_name"`
	FormulaDsl       string    `json:"formula_dsl"`
	AiExplanation    *string   `json:"ai_explanation"`
	PublisherComment *string   `json:"publisher_comment"`
	IsEnabled        bool      `json:"is_enabled"`
	IsVisible        bool      `json:"is_visible"`
	IsPublished      bool      `json:"is_published"`
	IsCustom         bool      `json:"is_custom"`
	Category         string    `json:"category"`
	Dependencies     []string  `json:"dependencies"`
	SortOrder        int32     `json:"sort_order"`
	CreatedAt        time.Time `json:"created_at"`
	UpdatedAt        time.Time `json:"updated_at"`
}

// Import from templates to publisher --
func (q *Queries) ImportZmanimFromTemplates(ctx context.Context, publisherID string) ([]ImportZmanimFromTemplatesRow, error) {
	rows, err := q.db.Query(ctx, importZmanimFromTemplates, publisherID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ImportZmanimFromTemplatesRow{}
	for rows.Next() {
		var i ImportZmanimFromTemplatesRow
		if err := rows.Scan(
			&i.ID,
			&i.PublisherID,
			&i.ZmanKey,
			&i.HebrewName,
			&i.EnglishName,
			&i.FormulaDsl,
			&i.AiExplanation,
			&i.PublisherComment,
			&i.IsEnabled,
			&i.IsVisible,
			&i.IsPublished,
			&i.IsCustom,
			&i.Category,
			&i.Dependencies,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const importZmanimFromTemplatesByKeys = `-- name: ImportZmanimFromTemplatesByKeys :many
INSERT INTO publisher_zmanim (
    id, publisher_id, zman_key, hebrew_name, english_name,
    formula_dsl, ai_explanation, publisher_comment,
    is_enabled, is_visible, is_published, is_custom, category,
    dependencies, sort_order
)
SELECT
    gen_random_uuid(), $1, zman_key, hebrew_name, english_name,
    formula_dsl, NULL, NULL,
    true, true, false, false, category,
    '{}', sort_order
FROM zmanim_templates
WHERE zman_key = ANY($2::text[])
ON CONFLICT (publisher_id, zman_key) DO NOTHING
RETURNING id, publisher_id, zman_key, hebrew_name, english_name,
    formula_dsl, ai_explanation, publisher_comment,
    is_enabled, is_visible, is_published, is_custom, category,
    dependencies, sort_order, created_at, updated_at
`

type ImportZmanimFromTemplatesByKeysParams struct {
	PublisherID string   `json:"publisher_id"`
	Column2     []string `json:"column_2"`
}

type ImportZmanimFromTemplatesByKeysRow struct {
	ID               string    `json:"id"`
	PublisherID      string    `json:"publisher_id"`
	ZmanKey          string    `json:"zman_key"`
	HebrewName       string    `json:"hebrew_name"`
	EnglishName      string    `json:"english_name"`
	FormulaDsl       string    `json:"formula_dsl"`
	AiExplanation    *string   `json:"ai_explanation"`
	PublisherComment *string   `json:"publisher_comment"`
	IsEnabled        bool      `json:"is_enabled"`
	IsVisible        bool      `json:"is_visible"`
	IsPublished      bool      `json:"is_published"`
	IsCustom         bool      `json:"is_custom"`
	Category         string    `json:"category"`
	Dependencies     []string  `json:"dependencies"`
	SortOrder        int32     `json:"sort_order"`
	CreatedAt        time.Time `json:"created_at"`
	UpdatedAt        time.Time `json:"updated_at"`
}

func (q *Queries) ImportZmanimFromTemplatesByKeys(ctx context.Context, arg ImportZmanimFromTemplatesByKeysParams) ([]ImportZmanimFromTemplatesByKeysRow, error) {
	rows, err := q.db.Query(ctx, importZmanimFromTemplatesByKeys, arg.PublisherID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ImportZmanimFromTemplatesByKeysRow{}
	for rows.Next() {
		var i ImportZmanimFromTemplatesByKeysRow
		if err := rows.Scan(
			&i.ID,
			&i.PublisherID,
			&i.ZmanKey,
			&i.HebrewName,
			&i.EnglishName,
			&i.FormulaDsl,
			&i.AiExplanation,
			&i.PublisherComment,
			&i.IsEnabled,
			&i.IsVisible,
			&i.IsPublished,
			&i.IsCustom,
			&i.Category,
			&i.Dependencies,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const publishAllZmanim = `-- name: PublishAllZmanim :exec

UPDATE publisher_zmanim
SET is_published = true, updated_at = NOW()
WHERE publisher_id = $1 AND is_enabled = true
`

// Bulk publish/unpublish zmanim --
func (q *Queries) PublishAllZmanim(ctx context.Context, publisherID string) error {
	_, err := q.db.Exec(ctx, publishAllZmanim, publisherID)
	return err
}

const publishZmanimByKeys = `-- name: PublishZmanimByKeys :exec
UPDATE publisher_zmanim
SET is_published = true, updated_at = NOW()
WHERE publisher_id = $1 AND zman_key = ANY($2::text[])
`

type PublishZmanimByKeysParams struct {
	PublisherID string   `json:"publisher_id"`
	Column2     []string `json:"column_2"`
}

func (q *Queries) PublishZmanimByKeys(ctx context.Context, arg PublishZmanimByKeysParams) error {
	_, err := q.db.Exec(ctx, publishZmanimByKeys, arg.PublisherID, arg.Column2)
	return err
}

const unpublishAllZmanim = `-- name: UnpublishAllZmanim :exec
UPDATE publisher_zmanim
SET is_published = false, updated_at = NOW()
WHERE publisher_id = $1
`

func (q *Queries) UnpublishAllZmanim(ctx context.Context, publisherID string) error {
	_, err := q.db.Exec(ctx, unpublishAllZmanim, publisherID)
	return err
}

const unpublishZmanimByKeys = `-- name: UnpublishZmanimByKeys :exec
UPDATE publisher_zmanim
SET is_published = false, updated_at = NOW()
WHERE publisher_id = $1 AND zman_key = ANY($2::text[])
`

type UnpublishZmanimByKeysParams struct {
	PublisherID string   `json:"publisher_id"`
	Column2     []string `json:"column_2"`
}

func (q *Queries) UnpublishZmanimByKeys(ctx context.Context, arg UnpublishZmanimByKeysParams) error {
	_, err := q.db.Exec(ctx, unpublishZmanimByKeys, arg.PublisherID, arg.Column2)
	return err
}

const updatePublisherZman = `-- name: UpdatePublisherZman :one
UPDATE publisher_zmanim
SET hebrew_name = COALESCE($3, hebrew_name),
    english_name = COALESCE($4, english_name),
    formula_dsl = COALESCE($5, formula_dsl),
    ai_explanation = COALESCE($6, ai_explanation),
    publisher_comment = COALESCE($7, publisher_comment),
    is_enabled = COALESCE($8, is_enabled),
    is_visible = COALESCE($9, is_visible),
    is_published = COALESCE($10, is_published),
    category = COALESCE($11, category),
    sort_order = COALESCE($12, sort_order),
    dependencies = COALESCE($13, dependencies),
    updated_at = NOW()
WHERE publisher_id = $1 AND zman_key = $2
RETURNING id, publisher_id, zman_key, hebrew_name, english_name,
    formula_dsl, ai_explanation, publisher_comment,
    is_enabled, is_visible, is_published, is_custom, category,
    dependencies, sort_order, created_at, updated_at
`

type UpdatePublisherZmanParams struct {
	PublisherID      string   `json:"publisher_id"`
	ZmanKey          string   `json:"zman_key"`
	HebrewName       *string  `json:"hebrew_name"`
	EnglishName      *string  `json:"english_name"`
	FormulaDsl       *string  `json:"formula_dsl"`
	AiExplanation    *string  `json:"ai_explanation"`
	PublisherComment *string  `json:"publisher_comment"`
	IsEnabled        *bool    `json:"is_enabled"`
	IsVisible        *bool    `json:"is_visible"`
	IsPublished      *bool    `json:"is_published"`
	Category         *string  `json:"category"`
	SortOrder        *int32   `json:"sort_order"`
	Dependencies     []string `json:"dependencies"`
}

type UpdatePublisherZmanRow struct {
	ID               string    `json:"id"`
	PublisherID      string    `json:"publisher_id"`
	ZmanKey          string    `json:"zman_key"`
	HebrewName       string    `json:"hebrew_name"`
	EnglishName      string    `json:"english_name"`
	FormulaDsl       string    `json:"formula_dsl"`
	AiExplanation    *string   `json:"ai_explanation"`
	PublisherComment *string   `json:"publisher_comment"`
	IsEnabled        bool      `json:"is_enabled"`
	IsVisible        bool      `json:"is_visible"`
	IsPublished      bool      `json:"is_published"`
	IsCustom         bool      `json:"is_custom"`
	Category         string    `json:"category"`
	Dependencies     []string  `json:"dependencies"`
	SortOrder        int32     `json:"sort_order"`
	CreatedAt        time.Time `json:"created_at"`
	UpdatedAt        time.Time `json:"updated_at"`
}

func (q *Queries) UpdatePublisherZman(ctx context.Context, arg UpdatePublisherZmanParams) (UpdatePublisherZmanRow, error) {
	row := q.db.QueryRow(ctx, updatePublisherZman,
		arg.PublisherID,
		arg.ZmanKey,
		arg.HebrewName,
		arg.EnglishName,
		arg.FormulaDsl,
		arg.AiExplanation,
		arg.PublisherComment,
		arg.IsEnabled,
		arg.IsVisible,
		arg.IsPublished,
		arg.Category,
		arg.SortOrder,
		arg.Dependencies,
	)
	var i UpdatePublisherZmanRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.ZmanKey,
		&i.HebrewName,
		&i.EnglishName,
		&i.FormulaDsl,
		&i.AiExplanation,
		&i.PublisherComment,
		&i.IsEnabled,
		&i.IsVisible,
		&i.IsPublished,
		&i.IsCustom,
		&i.Category,
		&i.Dependencies,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
