// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: cities.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countCities = `-- name: CountCities :one
SELECT COUNT(*)
FROM cities
WHERE 1=1
  AND ($1::text IS NULL OR country_code = $1)
  AND ($2::text IS NULL OR region = $2)
  AND ($3::text IS NULL OR name ILIKE '%' || $3 || '%')
`

type CountCitiesParams struct {
	Column1 string `json:"column_1"`
	Column2 string `json:"column_2"`
	Column3 string `json:"column_3"`
}

func (q *Queries) CountCities(ctx context.Context, arg CountCitiesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countCities, arg.Column1, arg.Column2, arg.Column3)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCitiesForCoverage = `-- name: GetCitiesForCoverage :many
SELECT DISTINCT c.id, c.name, c.country, c.country_code, c.region, c.latitude, c.longitude, c.timezone
FROM cities c
WHERE c.country_code = $1
  AND ($2::text IS NULL OR c.region = $2)
ORDER BY c.name
`

type GetCitiesForCoverageParams struct {
	CountryCode string `json:"country_code"`
	Column2     string `json:"column_2"`
}

type GetCitiesForCoverageRow struct {
	ID          string         `json:"id"`
	Name        string         `json:"name"`
	Country     string         `json:"country"`
	CountryCode string         `json:"country_code"`
	Region      *string        `json:"region"`
	Latitude    pgtype.Numeric `json:"latitude"`
	Longitude   pgtype.Numeric `json:"longitude"`
	Timezone    string         `json:"timezone"`
}

func (q *Queries) GetCitiesForCoverage(ctx context.Context, arg GetCitiesForCoverageParams) ([]GetCitiesForCoverageRow, error) {
	rows, err := q.db.Query(ctx, getCitiesForCoverage, arg.CountryCode, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCitiesForCoverageRow{}
	for rows.Next() {
		var i GetCitiesForCoverageRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Country,
			&i.CountryCode,
			&i.Region,
			&i.Latitude,
			&i.Longitude,
			&i.Timezone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCityByID = `-- name: GetCityByID :one
SELECT id, name, country, country_code, region, latitude, longitude, timezone, population
FROM cities
WHERE id = $1
`

type GetCityByIDRow struct {
	ID          string         `json:"id"`
	Name        string         `json:"name"`
	Country     string         `json:"country"`
	CountryCode string         `json:"country_code"`
	Region      *string        `json:"region"`
	Latitude    pgtype.Numeric `json:"latitude"`
	Longitude   pgtype.Numeric `json:"longitude"`
	Timezone    string         `json:"timezone"`
	Population  *int32         `json:"population"`
}

func (q *Queries) GetCityByID(ctx context.Context, id string) (GetCityByIDRow, error) {
	row := q.db.QueryRow(ctx, getCityByID, id)
	var i GetCityByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Country,
		&i.CountryCode,
		&i.Region,
		&i.Latitude,
		&i.Longitude,
		&i.Timezone,
		&i.Population,
	)
	return i, err
}

const getCityByName = `-- name: GetCityByName :one
SELECT id, name, country, country_code, region, latitude, longitude, timezone, population
FROM cities
WHERE name = $1
LIMIT 1
`

type GetCityByNameRow struct {
	ID          string         `json:"id"`
	Name        string         `json:"name"`
	Country     string         `json:"country"`
	CountryCode string         `json:"country_code"`
	Region      *string        `json:"region"`
	Latitude    pgtype.Numeric `json:"latitude"`
	Longitude   pgtype.Numeric `json:"longitude"`
	Timezone    string         `json:"timezone"`
	Population  *int32         `json:"population"`
}

func (q *Queries) GetCityByName(ctx context.Context, name string) (GetCityByNameRow, error) {
	row := q.db.QueryRow(ctx, getCityByName, name)
	var i GetCityByNameRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Country,
		&i.CountryCode,
		&i.Region,
		&i.Latitude,
		&i.Longitude,
		&i.Timezone,
		&i.Population,
	)
	return i, err
}

const getCountries = `-- name: GetCountries :many
SELECT DISTINCT country_code, country
FROM cities
ORDER BY country
`

type GetCountriesRow struct {
	CountryCode string `json:"country_code"`
	Country     string `json:"country"`
}

func (q *Queries) GetCountries(ctx context.Context) ([]GetCountriesRow, error) {
	rows, err := q.db.Query(ctx, getCountries)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCountriesRow{}
	for rows.Next() {
		var i GetCountriesRow
		if err := rows.Scan(&i.CountryCode, &i.Country); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRegionsByCountry = `-- name: GetRegionsByCountry :many
SELECT DISTINCT region
FROM cities
WHERE country_code = $1 AND region IS NOT NULL AND region != ''
ORDER BY region
`

func (q *Queries) GetRegionsByCountry(ctx context.Context, countryCode string) ([]*string, error) {
	rows, err := q.db.Query(ctx, getRegionsByCountry, countryCode)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*string{}
	for rows.Next() {
		var region *string
		if err := rows.Scan(&region); err != nil {
			return nil, err
		}
		items = append(items, region)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCitiesByCountry = `-- name: ListCitiesByCountry :many
SELECT id, name, country, country_code, region, latitude, longitude, timezone, population
FROM cities
WHERE country_code = $1
ORDER BY population DESC NULLS LAST, name
LIMIT $2
`

type ListCitiesByCountryParams struct {
	CountryCode string `json:"country_code"`
	Limit       int32  `json:"limit"`
}

type ListCitiesByCountryRow struct {
	ID          string         `json:"id"`
	Name        string         `json:"name"`
	Country     string         `json:"country"`
	CountryCode string         `json:"country_code"`
	Region      *string        `json:"region"`
	Latitude    pgtype.Numeric `json:"latitude"`
	Longitude   pgtype.Numeric `json:"longitude"`
	Timezone    string         `json:"timezone"`
	Population  *int32         `json:"population"`
}

func (q *Queries) ListCitiesByCountry(ctx context.Context, arg ListCitiesByCountryParams) ([]ListCitiesByCountryRow, error) {
	rows, err := q.db.Query(ctx, listCitiesByCountry, arg.CountryCode, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCitiesByCountryRow{}
	for rows.Next() {
		var i ListCitiesByCountryRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Country,
			&i.CountryCode,
			&i.Region,
			&i.Latitude,
			&i.Longitude,
			&i.Timezone,
			&i.Population,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCitiesByRegion = `-- name: ListCitiesByRegion :many
SELECT id, name, country, country_code, region, latitude, longitude, timezone, population
FROM cities
WHERE country_code = $1 AND region = $2
ORDER BY population DESC NULLS LAST, name
LIMIT $3
`

type ListCitiesByRegionParams struct {
	CountryCode string  `json:"country_code"`
	Region      *string `json:"region"`
	Limit       int32   `json:"limit"`
}

type ListCitiesByRegionRow struct {
	ID          string         `json:"id"`
	Name        string         `json:"name"`
	Country     string         `json:"country"`
	CountryCode string         `json:"country_code"`
	Region      *string        `json:"region"`
	Latitude    pgtype.Numeric `json:"latitude"`
	Longitude   pgtype.Numeric `json:"longitude"`
	Timezone    string         `json:"timezone"`
	Population  *int32         `json:"population"`
}

func (q *Queries) ListCitiesByRegion(ctx context.Context, arg ListCitiesByRegionParams) ([]ListCitiesByRegionRow, error) {
	rows, err := q.db.Query(ctx, listCitiesByRegion, arg.CountryCode, arg.Region, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCitiesByRegionRow{}
	for rows.Next() {
		var i ListCitiesByRegionRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Country,
			&i.CountryCode,
			&i.Region,
			&i.Latitude,
			&i.Longitude,
			&i.Timezone,
			&i.Population,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchCities = `-- name: SearchCities :many

SELECT id, name, country, country_code, region, latitude, longitude, timezone, population
FROM cities
WHERE 1=1
  AND ($1::text IS NULL OR country_code = $1)
  AND ($2::text IS NULL OR region = $2)
  AND ($3::text IS NULL OR name ILIKE '%' || $3 || '%')
ORDER BY population DESC NULLS LAST, name
LIMIT $4 OFFSET $5
`

type SearchCitiesParams struct {
	Column1 string `json:"column_1"`
	Column2 string `json:"column_2"`
	Column3 string `json:"column_3"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type SearchCitiesRow struct {
	ID          string         `json:"id"`
	Name        string         `json:"name"`
	Country     string         `json:"country"`
	CountryCode string         `json:"country_code"`
	Region      *string        `json:"region"`
	Latitude    pgtype.Numeric `json:"latitude"`
	Longitude   pgtype.Numeric `json:"longitude"`
	Timezone    string         `json:"timezone"`
	Population  *int32         `json:"population"`
}

// Cities SQL Queries
// SQLc will generate type-safe Go code from these queries
func (q *Queries) SearchCities(ctx context.Context, arg SearchCitiesParams) ([]SearchCitiesRow, error) {
	rows, err := q.db.Query(ctx, searchCities,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchCitiesRow{}
	for rows.Next() {
		var i SearchCitiesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Country,
			&i.CountryCode,
			&i.Region,
			&i.Latitude,
			&i.Longitude,
			&i.Timezone,
			&i.Population,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
