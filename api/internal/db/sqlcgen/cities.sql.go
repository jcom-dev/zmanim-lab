// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: cities.sql

package sqlcgen

import (
	"context"
)

const countCities = `-- name: CountCities :one
SELECT COUNT(*)
FROM cities c
JOIN geo_countries co ON c.country_id = co.id
JOIN geo_continents ct ON co.continent_id = ct.id
LEFT JOIN geo_regions r ON c.region_id = r.id
WHERE 1=1
  AND ($1::text IS NULL OR ct.name = $1)
  AND ($2::text IS NULL OR co.code = $2)
  AND ($3::text IS NULL OR r.name = $3)
  AND ($4::text IS NULL OR c.name ILIKE '%' || $4 || '%')
`

type CountCitiesParams struct {
	Column1 string `json:"column_1"`
	Column2 string `json:"column_2"`
	Column3 string `json:"column_3"`
	Column4 string `json:"column_4"`
}

func (q *Queries) CountCities(ctx context.Context, arg CountCitiesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countCities,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteAllCities = `-- name: DeleteAllCities :exec
DELETE FROM cities
`

func (q *Queries) DeleteAllCities(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteAllCities)
	return err
}

const getCitiesForCoverage = `-- name: GetCitiesForCoverage :many
SELECT
    c.id, c.name,
    co.code as country_code, co.name as country,
    r.name as region,
    c.latitude, c.longitude, c.timezone, c.elevation
FROM cities c
JOIN geo_countries co ON c.country_id = co.id
LEFT JOIN geo_regions r ON c.region_id = r.id
WHERE co.code = $1
  AND ($2::text IS NULL OR r.name = $2)
ORDER BY c.name
`

type GetCitiesForCoverageParams struct {
	Code    string `json:"code"`
	Column2 string `json:"column_2"`
}

type GetCitiesForCoverageRow struct {
	ID          string  `json:"id"`
	Name        string  `json:"name"`
	CountryCode string  `json:"country_code"`
	Country     string  `json:"country"`
	Region      *string `json:"region"`
	Latitude    float64 `json:"latitude"`
	Longitude   float64 `json:"longitude"`
	Timezone    string  `json:"timezone"`
	Elevation   *int32  `json:"elevation"`
}

func (q *Queries) GetCitiesForCoverage(ctx context.Context, arg GetCitiesForCoverageParams) ([]GetCitiesForCoverageRow, error) {
	rows, err := q.db.Query(ctx, getCitiesForCoverage, arg.Code, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCitiesForCoverageRow{}
	for rows.Next() {
		var i GetCitiesForCoverageRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CountryCode,
			&i.Country,
			&i.Region,
			&i.Latitude,
			&i.Longitude,
			&i.Timezone,
			&i.Elevation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCityByID = `-- name: GetCityByID :one
SELECT
    c.id, c.name, c.hebrew_name,
    co.code as country_code, co.name as country,
    r.name as region,
    ct.name as continent,
    c.latitude, c.longitude, c.timezone,
    c.population, c.elevation, c.geonameid
FROM cities c
JOIN geo_countries co ON c.country_id = co.id
JOIN geo_continents ct ON co.continent_id = ct.id
LEFT JOIN geo_regions r ON c.region_id = r.id
WHERE c.id = $1
`

type GetCityByIDRow struct {
	ID          string  `json:"id"`
	Name        string  `json:"name"`
	HebrewName  *string `json:"hebrew_name"`
	CountryCode string  `json:"country_code"`
	Country     string  `json:"country"`
	Region      *string `json:"region"`
	Continent   string  `json:"continent"`
	Latitude    float64 `json:"latitude"`
	Longitude   float64 `json:"longitude"`
	Timezone    string  `json:"timezone"`
	Population  *int32  `json:"population"`
	Elevation   *int32  `json:"elevation"`
	Geonameid   *int32  `json:"geonameid"`
}

func (q *Queries) GetCityByID(ctx context.Context, id string) (GetCityByIDRow, error) {
	row := q.db.QueryRow(ctx, getCityByID, id)
	var i GetCityByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.HebrewName,
		&i.CountryCode,
		&i.Country,
		&i.Region,
		&i.Continent,
		&i.Latitude,
		&i.Longitude,
		&i.Timezone,
		&i.Population,
		&i.Elevation,
		&i.Geonameid,
	)
	return i, err
}

const getCityByName = `-- name: GetCityByName :one
SELECT
    c.id, c.name, c.hebrew_name,
    co.code as country_code, co.name as country,
    r.name as region,
    ct.name as continent,
    c.latitude, c.longitude, c.timezone,
    c.population, c.elevation, c.geonameid
FROM cities c
JOIN geo_countries co ON c.country_id = co.id
JOIN geo_continents ct ON co.continent_id = ct.id
LEFT JOIN geo_regions r ON c.region_id = r.id
WHERE c.name = $1
LIMIT 1
`

type GetCityByNameRow struct {
	ID          string  `json:"id"`
	Name        string  `json:"name"`
	HebrewName  *string `json:"hebrew_name"`
	CountryCode string  `json:"country_code"`
	Country     string  `json:"country"`
	Region      *string `json:"region"`
	Continent   string  `json:"continent"`
	Latitude    float64 `json:"latitude"`
	Longitude   float64 `json:"longitude"`
	Timezone    string  `json:"timezone"`
	Population  *int32  `json:"population"`
	Elevation   *int32  `json:"elevation"`
	Geonameid   *int32  `json:"geonameid"`
}

func (q *Queries) GetCityByName(ctx context.Context, name string) (GetCityByNameRow, error) {
	row := q.db.QueryRow(ctx, getCityByName, name)
	var i GetCityByNameRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.HebrewName,
		&i.CountryCode,
		&i.Country,
		&i.Region,
		&i.Continent,
		&i.Latitude,
		&i.Longitude,
		&i.Timezone,
		&i.Population,
		&i.Elevation,
		&i.Geonameid,
	)
	return i, err
}

const getContinents = `-- name: GetContinents :many
SELECT ct.id, ct.code, ct.name, COUNT(c.id) as city_count
FROM geo_continents ct
LEFT JOIN geo_countries co ON co.continent_id = ct.id
LEFT JOIN cities c ON c.country_id = co.id
GROUP BY ct.id, ct.code, ct.name
ORDER BY ct.name
`

type GetContinentsRow struct {
	ID        int16  `json:"id"`
	Code      string `json:"code"`
	Name      string `json:"name"`
	CityCount int64  `json:"city_count"`
}

func (q *Queries) GetContinents(ctx context.Context) ([]GetContinentsRow, error) {
	rows, err := q.db.Query(ctx, getContinents)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetContinentsRow{}
	for rows.Next() {
		var i GetContinentsRow
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.CityCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCountries = `-- name: GetCountries :many
SELECT co.id, co.code as country_code, co.name as country
FROM geo_countries co
ORDER BY co.name
`

type GetCountriesRow struct {
	ID          int16  `json:"id"`
	CountryCode string `json:"country_code"`
	Country     string `json:"country"`
}

func (q *Queries) GetCountries(ctx context.Context) ([]GetCountriesRow, error) {
	rows, err := q.db.Query(ctx, getCountries)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCountriesRow{}
	for rows.Next() {
		var i GetCountriesRow
		if err := rows.Scan(&i.ID, &i.CountryCode, &i.Country); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCountriesByContinent = `-- name: GetCountriesByContinent :many
SELECT co.id, co.code as country_code, co.name as country, COUNT(c.id) as city_count
FROM geo_countries co
JOIN geo_continents ct ON co.continent_id = ct.id
LEFT JOIN cities c ON c.country_id = co.id
WHERE ct.name = $1
GROUP BY co.id, co.code, co.name
ORDER BY co.name
`

type GetCountriesByContinentRow struct {
	ID          int16  `json:"id"`
	CountryCode string `json:"country_code"`
	Country     string `json:"country"`
	CityCount   int64  `json:"city_count"`
}

func (q *Queries) GetCountriesByContinent(ctx context.Context, name string) ([]GetCountriesByContinentRow, error) {
	rows, err := q.db.Query(ctx, getCountriesByContinent, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCountriesByContinentRow{}
	for rows.Next() {
		var i GetCountriesByContinentRow
		if err := rows.Scan(
			&i.ID,
			&i.CountryCode,
			&i.Country,
			&i.CityCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCountryByCode = `-- name: GetCountryByCode :one

SELECT id, code, name, continent_id
FROM geo_countries
WHERE code = $1
`

// Lookup table queries for seeding
func (q *Queries) GetCountryByCode(ctx context.Context, code string) (GeoCountry, error) {
	row := q.db.QueryRow(ctx, getCountryByCode, code)
	var i GeoCountry
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.ContinentID,
	)
	return i, err
}

const getRegionByCountryAndCode = `-- name: GetRegionByCountryAndCode :one
SELECT r.id, r.country_id, r.code, r.name
FROM geo_regions r
JOIN geo_countries co ON r.country_id = co.id
WHERE co.code = $1 AND r.code = $2
`

type GetRegionByCountryAndCodeParams struct {
	Code   string `json:"code"`
	Code_2 string `json:"code_2"`
}

func (q *Queries) GetRegionByCountryAndCode(ctx context.Context, arg GetRegionByCountryAndCodeParams) (GeoRegion, error) {
	row := q.db.QueryRow(ctx, getRegionByCountryAndCode, arg.Code, arg.Code_2)
	var i GeoRegion
	err := row.Scan(
		&i.ID,
		&i.CountryID,
		&i.Code,
		&i.Name,
	)
	return i, err
}

const getRegionsByCountry = `-- name: GetRegionsByCountry :many
SELECT r.id, r.code, r.name
FROM geo_regions r
JOIN geo_countries co ON r.country_id = co.id
WHERE co.code = $1
ORDER BY r.name
`

type GetRegionsByCountryRow struct {
	ID   int32  `json:"id"`
	Code string `json:"code"`
	Name string `json:"name"`
}

func (q *Queries) GetRegionsByCountry(ctx context.Context, code string) ([]GetRegionsByCountryRow, error) {
	rows, err := q.db.Query(ctx, getRegionsByCountry, code)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRegionsByCountryRow{}
	for rows.Next() {
		var i GetRegionsByCountryRow
		if err := rows.Scan(&i.ID, &i.Code, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertCountry = `-- name: InsertCountry :one
INSERT INTO geo_countries (code, name, continent_id)
VALUES ($1, $2, $3)
RETURNING id
`

type InsertCountryParams struct {
	Code        string `json:"code"`
	Name        string `json:"name"`
	ContinentID int16  `json:"continent_id"`
}

func (q *Queries) InsertCountry(ctx context.Context, arg InsertCountryParams) (int16, error) {
	row := q.db.QueryRow(ctx, insertCountry, arg.Code, arg.Name, arg.ContinentID)
	var id int16
	err := row.Scan(&id)
	return id, err
}

const insertRegion = `-- name: InsertRegion :one
INSERT INTO geo_regions (country_id, code, name)
VALUES ($1, $2, $3)
RETURNING id
`

type InsertRegionParams struct {
	CountryID int16  `json:"country_id"`
	Code      string `json:"code"`
	Name      string `json:"name"`
}

func (q *Queries) InsertRegion(ctx context.Context, arg InsertRegionParams) (int32, error) {
	row := q.db.QueryRow(ctx, insertRegion, arg.CountryID, arg.Code, arg.Name)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const listCitiesByContinent = `-- name: ListCitiesByContinent :many
SELECT
    c.id, c.name, c.hebrew_name,
    co.code as country_code, co.name as country,
    r.name as region,
    ct.name as continent,
    c.latitude, c.longitude, c.timezone,
    c.population, c.elevation, c.geonameid
FROM cities c
JOIN geo_countries co ON c.country_id = co.id
JOIN geo_continents ct ON co.continent_id = ct.id
LEFT JOIN geo_regions r ON c.region_id = r.id
WHERE ct.name = $1
ORDER BY c.population DESC NULLS LAST, c.name
LIMIT $2 OFFSET $3
`

type ListCitiesByContinentParams struct {
	Name   string `json:"name"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

type ListCitiesByContinentRow struct {
	ID          string  `json:"id"`
	Name        string  `json:"name"`
	HebrewName  *string `json:"hebrew_name"`
	CountryCode string  `json:"country_code"`
	Country     string  `json:"country"`
	Region      *string `json:"region"`
	Continent   string  `json:"continent"`
	Latitude    float64 `json:"latitude"`
	Longitude   float64 `json:"longitude"`
	Timezone    string  `json:"timezone"`
	Population  *int32  `json:"population"`
	Elevation   *int32  `json:"elevation"`
	Geonameid   *int32  `json:"geonameid"`
}

func (q *Queries) ListCitiesByContinent(ctx context.Context, arg ListCitiesByContinentParams) ([]ListCitiesByContinentRow, error) {
	rows, err := q.db.Query(ctx, listCitiesByContinent, arg.Name, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCitiesByContinentRow{}
	for rows.Next() {
		var i ListCitiesByContinentRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.HebrewName,
			&i.CountryCode,
			&i.Country,
			&i.Region,
			&i.Continent,
			&i.Latitude,
			&i.Longitude,
			&i.Timezone,
			&i.Population,
			&i.Elevation,
			&i.Geonameid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCitiesByCountry = `-- name: ListCitiesByCountry :many
SELECT
    c.id, c.name, c.hebrew_name,
    co.code as country_code, co.name as country,
    r.name as region,
    ct.name as continent,
    c.latitude, c.longitude, c.timezone,
    c.population, c.elevation, c.geonameid
FROM cities c
JOIN geo_countries co ON c.country_id = co.id
JOIN geo_continents ct ON co.continent_id = ct.id
LEFT JOIN geo_regions r ON c.region_id = r.id
WHERE co.code = $1
ORDER BY c.population DESC NULLS LAST, c.name
LIMIT $2
`

type ListCitiesByCountryParams struct {
	Code  string `json:"code"`
	Limit int32  `json:"limit"`
}

type ListCitiesByCountryRow struct {
	ID          string  `json:"id"`
	Name        string  `json:"name"`
	HebrewName  *string `json:"hebrew_name"`
	CountryCode string  `json:"country_code"`
	Country     string  `json:"country"`
	Region      *string `json:"region"`
	Continent   string  `json:"continent"`
	Latitude    float64 `json:"latitude"`
	Longitude   float64 `json:"longitude"`
	Timezone    string  `json:"timezone"`
	Population  *int32  `json:"population"`
	Elevation   *int32  `json:"elevation"`
	Geonameid   *int32  `json:"geonameid"`
}

func (q *Queries) ListCitiesByCountry(ctx context.Context, arg ListCitiesByCountryParams) ([]ListCitiesByCountryRow, error) {
	rows, err := q.db.Query(ctx, listCitiesByCountry, arg.Code, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCitiesByCountryRow{}
	for rows.Next() {
		var i ListCitiesByCountryRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.HebrewName,
			&i.CountryCode,
			&i.Country,
			&i.Region,
			&i.Continent,
			&i.Latitude,
			&i.Longitude,
			&i.Timezone,
			&i.Population,
			&i.Elevation,
			&i.Geonameid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCitiesByRegion = `-- name: ListCitiesByRegion :many
SELECT
    c.id, c.name, c.hebrew_name,
    co.code as country_code, co.name as country,
    r.name as region,
    ct.name as continent,
    c.latitude, c.longitude, c.timezone,
    c.population, c.elevation, c.geonameid
FROM cities c
JOIN geo_countries co ON c.country_id = co.id
JOIN geo_continents ct ON co.continent_id = ct.id
JOIN geo_regions r ON c.region_id = r.id
WHERE co.code = $1 AND r.name = $2
ORDER BY c.population DESC NULLS LAST, c.name
LIMIT $3
`

type ListCitiesByRegionParams struct {
	Code  string `json:"code"`
	Name  string `json:"name"`
	Limit int32  `json:"limit"`
}

type ListCitiesByRegionRow struct {
	ID          string  `json:"id"`
	Name        string  `json:"name"`
	HebrewName  *string `json:"hebrew_name"`
	CountryCode string  `json:"country_code"`
	Country     string  `json:"country"`
	Region      string  `json:"region"`
	Continent   string  `json:"continent"`
	Latitude    float64 `json:"latitude"`
	Longitude   float64 `json:"longitude"`
	Timezone    string  `json:"timezone"`
	Population  *int32  `json:"population"`
	Elevation   *int32  `json:"elevation"`
	Geonameid   *int32  `json:"geonameid"`
}

func (q *Queries) ListCitiesByRegion(ctx context.Context, arg ListCitiesByRegionParams) ([]ListCitiesByRegionRow, error) {
	rows, err := q.db.Query(ctx, listCitiesByRegion, arg.Code, arg.Name, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCitiesByRegionRow{}
	for rows.Next() {
		var i ListCitiesByRegionRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.HebrewName,
			&i.CountryCode,
			&i.Country,
			&i.Region,
			&i.Continent,
			&i.Latitude,
			&i.Longitude,
			&i.Timezone,
			&i.Population,
			&i.Elevation,
			&i.Geonameid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchCities = `-- name: SearchCities :many

SELECT
    c.id, c.name, c.hebrew_name, c.name_ascii,
    co.code as country_code, co.name as country,
    r.name as region, r.code as region_code,
    ct.name as continent,
    c.latitude, c.longitude, c.timezone,
    c.population, c.elevation, c.geonameid
FROM cities c
JOIN geo_countries co ON c.country_id = co.id
JOIN geo_continents ct ON co.continent_id = ct.id
LEFT JOIN geo_regions r ON c.region_id = r.id
WHERE 1=1
  AND ($1::text IS NULL OR ct.name = $1)
  AND ($2::text IS NULL OR co.code = $2)
  AND ($3::text IS NULL OR r.name = $3)
  AND ($4::text IS NULL OR c.name ILIKE '%' || $4 || '%')
ORDER BY c.population DESC NULLS LAST, c.name
LIMIT $5 OFFSET $6
`

type SearchCitiesParams struct {
	Column1 string `json:"column_1"`
	Column2 string `json:"column_2"`
	Column3 string `json:"column_3"`
	Column4 string `json:"column_4"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type SearchCitiesRow struct {
	ID          string  `json:"id"`
	Name        string  `json:"name"`
	HebrewName  *string `json:"hebrew_name"`
	NameAscii   *string `json:"name_ascii"`
	CountryCode string  `json:"country_code"`
	Country     string  `json:"country"`
	Region      *string `json:"region"`
	RegionCode  *string `json:"region_code"`
	Continent   string  `json:"continent"`
	Latitude    float64 `json:"latitude"`
	Longitude   float64 `json:"longitude"`
	Timezone    string  `json:"timezone"`
	Population  *int32  `json:"population"`
	Elevation   *int32  `json:"elevation"`
	Geonameid   *int32  `json:"geonameid"`
}

// Cities SQL Queries (Normalized Schema)
// SQLc will generate type-safe Go code from these queries
// Uses JOINs to geo_continents, geo_countries, and geo_regions lookup tables
func (q *Queries) SearchCities(ctx context.Context, arg SearchCitiesParams) ([]SearchCitiesRow, error) {
	rows, err := q.db.Query(ctx, searchCities,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchCitiesRow{}
	for rows.Next() {
		var i SearchCitiesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.HebrewName,
			&i.NameAscii,
			&i.CountryCode,
			&i.Country,
			&i.Region,
			&i.RegionCode,
			&i.Continent,
			&i.Latitude,
			&i.Longitude,
			&i.Timezone,
			&i.Population,
			&i.Elevation,
			&i.Geonameid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCityFKs = `-- name: UpdateCityFKs :exec
UPDATE cities
SET country_id = $2, region_id = $3
WHERE id = $1
`

type UpdateCityFKsParams struct {
	ID        string `json:"id"`
	CountryID int16  `json:"country_id"`
	RegionID  *int32 `json:"region_id"`
}

func (q *Queries) UpdateCityFKs(ctx context.Context, arg UpdateCityFKsParams) error {
	_, err := q.db.Exec(ctx, updateCityFKs, arg.ID, arg.CountryID, arg.RegionID)
	return err
}
