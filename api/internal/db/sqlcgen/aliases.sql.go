// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: aliases.sql

package sqlcgen

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const deletePublisherZmanAlias = `-- name: DeletePublisherZmanAlias :exec
DELETE FROM publisher_zman_aliases pza
USING publisher_zmanim pz
WHERE pza.publisher_zman_id = pz.id
  AND pza.publisher_id = $1
  AND pz.zman_key = $2
`

type DeletePublisherZmanAliasParams struct {
	PublisherID string `json:"publisher_id"`
	ZmanKey     string `json:"zman_key"`
}

// Delete an alias by publisher_id and zman_key
func (q *Queries) DeletePublisherZmanAlias(ctx context.Context, arg DeletePublisherZmanAliasParams) error {
	_, err := q.db.Exec(ctx, deletePublisherZmanAlias, arg.PublisherID, arg.ZmanKey)
	return err
}

const getAllPublisherZmanAliases = `-- name: GetAllPublisherZmanAliases :many
SELECT
    pza.id,
    pza.publisher_id,
    pza.publisher_zman_id,
    pza.custom_hebrew_name,
    pza.custom_english_name,
    pza.custom_transliteration,
    pza.is_active,
    pza.created_at,
    pza.updated_at,
    pz.zman_key,
    mzr.canonical_hebrew_name,
    mzr.canonical_english_name
FROM publisher_zman_aliases pza
JOIN publisher_zmanim pz ON pza.publisher_zman_id = pz.id
JOIN master_zmanim_registry mzr ON pz.zman_key = mzr.zman_key
WHERE pza.publisher_id = $1 AND pza.is_active = true
ORDER BY pz.sort_order
`

type GetAllPublisherZmanAliasesRow struct {
	ID                    string    `json:"id"`
	PublisherID           string    `json:"publisher_id"`
	PublisherZmanID       string    `json:"publisher_zman_id"`
	CustomHebrewName      string    `json:"custom_hebrew_name"`
	CustomEnglishName     string    `json:"custom_english_name"`
	CustomTransliteration *string   `json:"custom_transliteration"`
	IsActive              bool      `json:"is_active"`
	CreatedAt             time.Time `json:"created_at"`
	UpdatedAt             time.Time `json:"updated_at"`
	ZmanKey               string    `json:"zman_key"`
	CanonicalHebrewName   string    `json:"canonical_hebrew_name"`
	CanonicalEnglishName  string    `json:"canonical_english_name"`
}

// Get all active aliases for a publisher with canonical names included
func (q *Queries) GetAllPublisherZmanAliases(ctx context.Context, publisherID string) ([]GetAllPublisherZmanAliasesRow, error) {
	rows, err := q.db.Query(ctx, getAllPublisherZmanAliases, publisherID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllPublisherZmanAliasesRow{}
	for rows.Next() {
		var i GetAllPublisherZmanAliasesRow
		if err := rows.Scan(
			&i.ID,
			&i.PublisherID,
			&i.PublisherZmanID,
			&i.CustomHebrewName,
			&i.CustomEnglishName,
			&i.CustomTransliteration,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ZmanKey,
			&i.CanonicalHebrewName,
			&i.CanonicalEnglishName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublisherZmanAlias = `-- name: GetPublisherZmanAlias :one

SELECT
    pza.id,
    pza.publisher_id,
    pza.publisher_zman_id,
    pza.custom_hebrew_name,
    pza.custom_english_name,
    pza.custom_transliteration,
    pza.is_active,
    pza.created_at,
    pza.updated_at,
    pz.zman_key,
    mzr.canonical_hebrew_name,
    mzr.canonical_english_name
FROM publisher_zman_aliases pza
JOIN publisher_zmanim pz ON pza.publisher_zman_id = pz.id
JOIN master_zmanim_registry mzr ON pz.zman_key = mzr.zman_key
WHERE pza.publisher_id = $1 AND pz.zman_key = $2 AND pza.is_active = true
`

type GetPublisherZmanAliasParams struct {
	PublisherID string `json:"publisher_id"`
	ZmanKey     string `json:"zman_key"`
}

type GetPublisherZmanAliasRow struct {
	ID                    string    `json:"id"`
	PublisherID           string    `json:"publisher_id"`
	PublisherZmanID       string    `json:"publisher_zman_id"`
	CustomHebrewName      string    `json:"custom_hebrew_name"`
	CustomEnglishName     string    `json:"custom_english_name"`
	CustomTransliteration *string   `json:"custom_transliteration"`
	IsActive              bool      `json:"is_active"`
	CreatedAt             time.Time `json:"created_at"`
	UpdatedAt             time.Time `json:"updated_at"`
	ZmanKey               string    `json:"zman_key"`
	CanonicalHebrewName   string    `json:"canonical_hebrew_name"`
	CanonicalEnglishName  string    `json:"canonical_english_name"`
}

// Alias CRUD Queries
// Epic 5, Story 5.0: Publisher Zman Aliases
// Get a specific alias for a publisher's zman by zman_key
func (q *Queries) GetPublisherZmanAlias(ctx context.Context, arg GetPublisherZmanAliasParams) (GetPublisherZmanAliasRow, error) {
	row := q.db.QueryRow(ctx, getPublisherZmanAlias, arg.PublisherID, arg.ZmanKey)
	var i GetPublisherZmanAliasRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.PublisherZmanID,
		&i.CustomHebrewName,
		&i.CustomEnglishName,
		&i.CustomTransliteration,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ZmanKey,
		&i.CanonicalHebrewName,
		&i.CanonicalEnglishName,
	)
	return i, err
}

const getZmanimWithAliases = `-- name: GetZmanimWithAliases :many
SELECT
    pz.id as publisher_zman_id,
    pz.zman_key,
    pz.formula_dsl,
    pz.is_enabled,
    pz.sort_order,
    mzr.canonical_hebrew_name,
    mzr.canonical_english_name,
    pza.id as alias_id,
    pza.custom_hebrew_name,
    pza.custom_english_name,
    pza.custom_transliteration
FROM publisher_zmanim pz
JOIN master_zmanim_registry mzr ON pz.zman_key = mzr.zman_key
LEFT JOIN publisher_zman_aliases pza ON pza.publisher_zman_id = pz.id AND pza.is_active = true
WHERE pz.publisher_id = $1 AND pz.is_enabled = true
ORDER BY pz.sort_order
`

type GetZmanimWithAliasesRow struct {
	PublisherZmanID       string      `json:"publisher_zman_id"`
	ZmanKey               string      `json:"zman_key"`
	FormulaDsl            string      `json:"formula_dsl"`
	IsEnabled             bool        `json:"is_enabled"`
	SortOrder             int32       `json:"sort_order"`
	CanonicalHebrewName   string      `json:"canonical_hebrew_name"`
	CanonicalEnglishName  string      `json:"canonical_english_name"`
	AliasID               pgtype.UUID `json:"alias_id"`
	CustomHebrewName      *string     `json:"custom_hebrew_name"`
	CustomEnglishName     *string     `json:"custom_english_name"`
	CustomTransliteration *string     `json:"custom_transliteration"`
}

// Get all of a publisher's zmanim with their aliases (if any)
func (q *Queries) GetZmanimWithAliases(ctx context.Context, publisherID string) ([]GetZmanimWithAliasesRow, error) {
	rows, err := q.db.Query(ctx, getZmanimWithAliases, publisherID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetZmanimWithAliasesRow{}
	for rows.Next() {
		var i GetZmanimWithAliasesRow
		if err := rows.Scan(
			&i.PublisherZmanID,
			&i.ZmanKey,
			&i.FormulaDsl,
			&i.IsEnabled,
			&i.SortOrder,
			&i.CanonicalHebrewName,
			&i.CanonicalEnglishName,
			&i.AliasID,
			&i.CustomHebrewName,
			&i.CustomEnglishName,
			&i.CustomTransliteration,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertPublisherZmanAlias = `-- name: UpsertPublisherZmanAlias :one
INSERT INTO publisher_zman_aliases (
    publisher_id,
    publisher_zman_id,
    custom_hebrew_name,
    custom_english_name,
    custom_transliteration
)
SELECT $1, pz.id, $3, $4, $5
FROM publisher_zmanim pz
WHERE pz.publisher_id = $1 AND pz.zman_key = $2
ON CONFLICT (publisher_id, publisher_zman_id) DO UPDATE SET
    custom_hebrew_name = EXCLUDED.custom_hebrew_name,
    custom_english_name = EXCLUDED.custom_english_name,
    custom_transliteration = EXCLUDED.custom_transliteration,
    is_active = true,
    updated_at = NOW()
RETURNING id, publisher_id, publisher_zman_id, custom_hebrew_name, custom_english_name, custom_transliteration, is_active, created_at, updated_at
`

type UpsertPublisherZmanAliasParams struct {
	PublisherID           string  `json:"publisher_id"`
	ZmanKey               string  `json:"zman_key"`
	CustomHebrewName      string  `json:"custom_hebrew_name"`
	CustomEnglishName     string  `json:"custom_english_name"`
	CustomTransliteration *string `json:"custom_transliteration"`
}

// Create or update an alias for a publisher's zman
func (q *Queries) UpsertPublisherZmanAlias(ctx context.Context, arg UpsertPublisherZmanAliasParams) (PublisherZmanAlias, error) {
	row := q.db.QueryRow(ctx, upsertPublisherZmanAlias,
		arg.PublisherID,
		arg.ZmanKey,
		arg.CustomHebrewName,
		arg.CustomEnglishName,
		arg.CustomTransliteration,
	)
	var i PublisherZmanAlias
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.PublisherZmanID,
		&i.CustomHebrewName,
		&i.CustomEnglishName,
		&i.CustomTransliteration,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
