// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: aliases.sql

package sqlcgen

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPublisherZmanAlias = `-- name: CreatePublisherZmanAlias :one
INSERT INTO publisher_zman_aliases (
    publisher_id,
    publisher_zman_id,
    alias_hebrew,
    alias_english,
    alias_transliteration,
    context,
    is_primary,
    sort_order
)
SELECT $1, pz.id, $3, $4, $5, $6, $7, $8
FROM publisher_zmanim pz
WHERE pz.publisher_id = $1 AND pz.zman_key = $2
RETURNING id, publisher_id, publisher_zman_id, alias_hebrew, alias_english, alias_transliteration, context, is_primary, sort_order, created_at
`

type CreatePublisherZmanAliasParams struct {
	PublisherID          string  `json:"publisher_id"`
	ZmanKey              string  `json:"zman_key"`
	AliasHebrew          string  `json:"alias_hebrew"`
	AliasEnglish         *string `json:"alias_english"`
	AliasTransliteration *string `json:"alias_transliteration"`
	Context              *string `json:"context"`
	IsPrimary            bool    `json:"is_primary"`
	SortOrder            *int32  `json:"sort_order"`
}

type CreatePublisherZmanAliasRow struct {
	ID                   string    `json:"id"`
	PublisherID          string    `json:"publisher_id"`
	PublisherZmanID      string    `json:"publisher_zman_id"`
	AliasHebrew          string    `json:"alias_hebrew"`
	AliasEnglish         *string   `json:"alias_english"`
	AliasTransliteration *string   `json:"alias_transliteration"`
	Context              *string   `json:"context"`
	IsPrimary            bool      `json:"is_primary"`
	SortOrder            *int32    `json:"sort_order"`
	CreatedAt            time.Time `json:"created_at"`
}

// Create an alias for a publisher's zman
func (q *Queries) CreatePublisherZmanAlias(ctx context.Context, arg CreatePublisherZmanAliasParams) (CreatePublisherZmanAliasRow, error) {
	row := q.db.QueryRow(ctx, createPublisherZmanAlias,
		arg.PublisherID,
		arg.ZmanKey,
		arg.AliasHebrew,
		arg.AliasEnglish,
		arg.AliasTransliteration,
		arg.Context,
		arg.IsPrimary,
		arg.SortOrder,
	)
	var i CreatePublisherZmanAliasRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.PublisherZmanID,
		&i.AliasHebrew,
		&i.AliasEnglish,
		&i.AliasTransliteration,
		&i.Context,
		&i.IsPrimary,
		&i.SortOrder,
		&i.CreatedAt,
	)
	return i, err
}

const deletePublisherZmanAlias = `-- name: DeletePublisherZmanAlias :exec
DELETE FROM publisher_zman_aliases WHERE id = $1
`

// Delete an alias by ID
func (q *Queries) DeletePublisherZmanAlias(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deletePublisherZmanAlias, id)
	return err
}

const deletePublisherZmanAliasByZmanKey = `-- name: DeletePublisherZmanAliasByZmanKey :exec
DELETE FROM publisher_zman_aliases pza
USING publisher_zmanim pz
WHERE pza.publisher_zman_id = pz.id
  AND pza.publisher_id = $1
  AND pz.zman_key = $2
`

type DeletePublisherZmanAliasByZmanKeyParams struct {
	PublisherID string `json:"publisher_id"`
	ZmanKey     string `json:"zman_key"`
}

// Delete all aliases for a specific zman_key
func (q *Queries) DeletePublisherZmanAliasByZmanKey(ctx context.Context, arg DeletePublisherZmanAliasByZmanKeyParams) error {
	_, err := q.db.Exec(ctx, deletePublisherZmanAliasByZmanKey, arg.PublisherID, arg.ZmanKey)
	return err
}

const getAllPublisherZmanAliases = `-- name: GetAllPublisherZmanAliases :many
SELECT
    pza.id,
    pza.publisher_id,
    pza.publisher_zman_id,
    pza.alias_hebrew,
    pza.alias_english,
    pza.alias_transliteration,
    pza.context,
    pza.is_primary,
    pza.sort_order,
    pza.created_at,
    pz.zman_key,
    mzr.canonical_hebrew_name,
    mzr.canonical_english_name
FROM publisher_zman_aliases pza
JOIN publisher_zmanim pz ON pza.publisher_zman_id = pz.id
JOIN master_zmanim_registry mzr ON pz.zman_key = mzr.zman_key
WHERE pza.publisher_id = $1
ORDER BY
    CASE mzr.time_category
        WHEN 'dawn' THEN 1
        WHEN 'sunrise' THEN 2
        WHEN 'morning' THEN 3
        WHEN 'midday' THEN 4
        WHEN 'afternoon' THEN 5
        WHEN 'sunset' THEN 6
        WHEN 'nightfall' THEN 7
        WHEN 'midnight' THEN 8
        ELSE 9
    END,
    pza.sort_order,
    mzr.canonical_hebrew_name
`

type GetAllPublisherZmanAliasesRow struct {
	ID                   string    `json:"id"`
	PublisherID          string    `json:"publisher_id"`
	PublisherZmanID      string    `json:"publisher_zman_id"`
	AliasHebrew          string    `json:"alias_hebrew"`
	AliasEnglish         *string   `json:"alias_english"`
	AliasTransliteration *string   `json:"alias_transliteration"`
	Context              *string   `json:"context"`
	IsPrimary            bool      `json:"is_primary"`
	SortOrder            *int32    `json:"sort_order"`
	CreatedAt            time.Time `json:"created_at"`
	ZmanKey              string    `json:"zman_key"`
	CanonicalHebrewName  string    `json:"canonical_hebrew_name"`
	CanonicalEnglishName string    `json:"canonical_english_name"`
}

// Get all aliases for a publisher with canonical names included
// Orders by time_category (chronological) then hebrew_name
func (q *Queries) GetAllPublisherZmanAliases(ctx context.Context, publisherID string) ([]GetAllPublisherZmanAliasesRow, error) {
	rows, err := q.db.Query(ctx, getAllPublisherZmanAliases, publisherID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllPublisherZmanAliasesRow{}
	for rows.Next() {
		var i GetAllPublisherZmanAliasesRow
		if err := rows.Scan(
			&i.ID,
			&i.PublisherID,
			&i.PublisherZmanID,
			&i.AliasHebrew,
			&i.AliasEnglish,
			&i.AliasTransliteration,
			&i.Context,
			&i.IsPrimary,
			&i.SortOrder,
			&i.CreatedAt,
			&i.ZmanKey,
			&i.CanonicalHebrewName,
			&i.CanonicalEnglishName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublisherZmanAlias = `-- name: GetPublisherZmanAlias :one

SELECT
    pza.id,
    pza.publisher_id,
    pza.publisher_zman_id,
    pza.alias_hebrew,
    pza.alias_english,
    pza.alias_transliteration,
    pza.context,
    pza.is_primary,
    pza.sort_order,
    pza.created_at,
    pz.zman_key,
    mzr.canonical_hebrew_name,
    mzr.canonical_english_name
FROM publisher_zman_aliases pza
JOIN publisher_zmanim pz ON pza.publisher_zman_id = pz.id
JOIN master_zmanim_registry mzr ON pz.zman_key = mzr.zman_key
WHERE pza.publisher_id = $1 AND pz.zman_key = $2 AND pza.is_primary = true
`

type GetPublisherZmanAliasParams struct {
	PublisherID string `json:"publisher_id"`
	ZmanKey     string `json:"zman_key"`
}

type GetPublisherZmanAliasRow struct {
	ID                   string    `json:"id"`
	PublisherID          string    `json:"publisher_id"`
	PublisherZmanID      string    `json:"publisher_zman_id"`
	AliasHebrew          string    `json:"alias_hebrew"`
	AliasEnglish         *string   `json:"alias_english"`
	AliasTransliteration *string   `json:"alias_transliteration"`
	Context              *string   `json:"context"`
	IsPrimary            bool      `json:"is_primary"`
	SortOrder            *int32    `json:"sort_order"`
	CreatedAt            time.Time `json:"created_at"`
	ZmanKey              string    `json:"zman_key"`
	CanonicalHebrewName  string    `json:"canonical_hebrew_name"`
	CanonicalEnglishName string    `json:"canonical_english_name"`
}

// Alias CRUD Queries
// Epic 5, Story 5.0: Publisher Zman Aliases
// Schema: id, publisher_zman_id, publisher_id, alias_hebrew, alias_english, alias_transliteration, context, is_primary, sort_order, created_at
// Get a specific alias for a publisher's zman by zman_key
func (q *Queries) GetPublisherZmanAlias(ctx context.Context, arg GetPublisherZmanAliasParams) (GetPublisherZmanAliasRow, error) {
	row := q.db.QueryRow(ctx, getPublisherZmanAlias, arg.PublisherID, arg.ZmanKey)
	var i GetPublisherZmanAliasRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.PublisherZmanID,
		&i.AliasHebrew,
		&i.AliasEnglish,
		&i.AliasTransliteration,
		&i.Context,
		&i.IsPrimary,
		&i.SortOrder,
		&i.CreatedAt,
		&i.ZmanKey,
		&i.CanonicalHebrewName,
		&i.CanonicalEnglishName,
	)
	return i, err
}

const getZmanimWithAliases = `-- name: GetZmanimWithAliases :many
SELECT
    pz.id as publisher_zman_id,
    pz.zman_key,
    pz.formula_dsl,
    pz.is_enabled,
    mzr.canonical_hebrew_name,
    mzr.canonical_english_name,
    pza.id as alias_id,
    pza.alias_hebrew,
    pza.alias_english,
    pza.alias_transliteration
FROM publisher_zmanim pz
JOIN master_zmanim_registry mzr ON pz.zman_key = mzr.zman_key
LEFT JOIN publisher_zman_aliases pza ON pza.publisher_zman_id = pz.id AND pza.is_primary = true
WHERE pz.publisher_id = $1 AND pz.is_enabled = true
ORDER BY
    CASE mzr.time_category
        WHEN 'dawn' THEN 1
        WHEN 'sunrise' THEN 2
        WHEN 'morning' THEN 3
        WHEN 'midday' THEN 4
        WHEN 'afternoon' THEN 5
        WHEN 'sunset' THEN 6
        WHEN 'nightfall' THEN 7
        WHEN 'midnight' THEN 8
        ELSE 9
    END,
    mzr.canonical_hebrew_name
`

type GetZmanimWithAliasesRow struct {
	PublisherZmanID      string      `json:"publisher_zman_id"`
	ZmanKey              string      `json:"zman_key"`
	FormulaDsl           string      `json:"formula_dsl"`
	IsEnabled            bool        `json:"is_enabled"`
	CanonicalHebrewName  string      `json:"canonical_hebrew_name"`
	CanonicalEnglishName string      `json:"canonical_english_name"`
	AliasID              pgtype.UUID `json:"alias_id"`
	AliasHebrew          *string     `json:"alias_hebrew"`
	AliasEnglish         *string     `json:"alias_english"`
	AliasTransliteration *string     `json:"alias_transliteration"`
}

// Get all of a publisher's zmanim with their primary alias (if any)
// Orders by time_category (chronological) then hebrew_name
func (q *Queries) GetZmanimWithAliases(ctx context.Context, publisherID string) ([]GetZmanimWithAliasesRow, error) {
	rows, err := q.db.Query(ctx, getZmanimWithAliases, publisherID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetZmanimWithAliasesRow{}
	for rows.Next() {
		var i GetZmanimWithAliasesRow
		if err := rows.Scan(
			&i.PublisherZmanID,
			&i.ZmanKey,
			&i.FormulaDsl,
			&i.IsEnabled,
			&i.CanonicalHebrewName,
			&i.CanonicalEnglishName,
			&i.AliasID,
			&i.AliasHebrew,
			&i.AliasEnglish,
			&i.AliasTransliteration,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePublisherZmanAlias = `-- name: UpdatePublisherZmanAlias :one
UPDATE publisher_zman_aliases
SET alias_hebrew = $2,
    alias_english = $3,
    alias_transliteration = $4,
    context = $5,
    is_primary = $6,
    sort_order = $7
WHERE id = $1
RETURNING id, publisher_id, publisher_zman_id, alias_hebrew, alias_english, alias_transliteration, context, is_primary, sort_order, created_at
`

type UpdatePublisherZmanAliasParams struct {
	ID                   string  `json:"id"`
	AliasHebrew          string  `json:"alias_hebrew"`
	AliasEnglish         *string `json:"alias_english"`
	AliasTransliteration *string `json:"alias_transliteration"`
	Context              *string `json:"context"`
	IsPrimary            bool    `json:"is_primary"`
	SortOrder            *int32  `json:"sort_order"`
}

type UpdatePublisherZmanAliasRow struct {
	ID                   string    `json:"id"`
	PublisherID          string    `json:"publisher_id"`
	PublisherZmanID      string    `json:"publisher_zman_id"`
	AliasHebrew          string    `json:"alias_hebrew"`
	AliasEnglish         *string   `json:"alias_english"`
	AliasTransliteration *string   `json:"alias_transliteration"`
	Context              *string   `json:"context"`
	IsPrimary            bool      `json:"is_primary"`
	SortOrder            *int32    `json:"sort_order"`
	CreatedAt            time.Time `json:"created_at"`
}

// Update an alias
func (q *Queries) UpdatePublisherZmanAlias(ctx context.Context, arg UpdatePublisherZmanAliasParams) (UpdatePublisherZmanAliasRow, error) {
	row := q.db.QueryRow(ctx, updatePublisherZmanAlias,
		arg.ID,
		arg.AliasHebrew,
		arg.AliasEnglish,
		arg.AliasTransliteration,
		arg.Context,
		arg.IsPrimary,
		arg.SortOrder,
	)
	var i UpdatePublisherZmanAliasRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.PublisherZmanID,
		&i.AliasHebrew,
		&i.AliasEnglish,
		&i.AliasTransliteration,
		&i.Context,
		&i.IsPrimary,
		&i.SortOrder,
		&i.CreatedAt,
	)
	return i, err
}
