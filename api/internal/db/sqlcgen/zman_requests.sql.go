// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: zman_requests.sql

package sqlcgen

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const addZmanRequestNewTag = `-- name: AddZmanRequestNewTag :one
INSERT INTO zman_request_tags (
    request_id,
    requested_tag_name,
    requested_tag_type,
    is_new_tag_request
) VALUES ($1, $2, $3, true)
RETURNING id, request_id, requested_tag_name, requested_tag_type, is_new_tag_request, created_at
`

type AddZmanRequestNewTagParams struct {
	RequestID        string  `json:"request_id"`
	RequestedTagName *string `json:"requested_tag_name"`
	RequestedTagType *string `json:"requested_tag_type"`
}

type AddZmanRequestNewTagRow struct {
	ID               string    `json:"id"`
	RequestID        string    `json:"request_id"`
	RequestedTagName *string   `json:"requested_tag_name"`
	RequestedTagType *string   `json:"requested_tag_type"`
	IsNewTagRequest  bool      `json:"is_new_tag_request"`
	CreatedAt        time.Time `json:"created_at"`
}

// Request a new tag for a zman request
func (q *Queries) AddZmanRequestNewTag(ctx context.Context, arg AddZmanRequestNewTagParams) (AddZmanRequestNewTagRow, error) {
	row := q.db.QueryRow(ctx, addZmanRequestNewTag, arg.RequestID, arg.RequestedTagName, arg.RequestedTagType)
	var i AddZmanRequestNewTagRow
	err := row.Scan(
		&i.ID,
		&i.RequestID,
		&i.RequestedTagName,
		&i.RequestedTagType,
		&i.IsNewTagRequest,
		&i.CreatedAt,
	)
	return i, err
}

const addZmanRequestTag = `-- name: AddZmanRequestTag :one
INSERT INTO zman_request_tags (
    request_id,
    tag_id,
    is_new_tag_request
) VALUES ($1, $2, false)
RETURNING id, request_id, tag_id, is_new_tag_request, created_at
`

type AddZmanRequestTagParams struct {
	RequestID string      `json:"request_id"`
	TagID     pgtype.UUID `json:"tag_id"`
}

type AddZmanRequestTagRow struct {
	ID              string      `json:"id"`
	RequestID       string      `json:"request_id"`
	TagID           pgtype.UUID `json:"tag_id"`
	IsNewTagRequest bool        `json:"is_new_tag_request"`
	CreatedAt       time.Time   `json:"created_at"`
}

// Add an existing tag to a zman request
func (q *Queries) AddZmanRequestTag(ctx context.Context, arg AddZmanRequestTagParams) (AddZmanRequestTagRow, error) {
	row := q.db.QueryRow(ctx, addZmanRequestTag, arg.RequestID, arg.TagID)
	var i AddZmanRequestTagRow
	err := row.Scan(
		&i.ID,
		&i.RequestID,
		&i.TagID,
		&i.IsNewTagRequest,
		&i.CreatedAt,
	)
	return i, err
}

const approveTagRequest = `-- name: ApproveTagRequest :one
INSERT INTO zman_tags (
    tag_key,
    name,
    display_name_hebrew,
    display_name_english,
    tag_type
) VALUES (
    $1, -- tag_key (generated from requested_tag_name)
    $2, -- name (requested_tag_name)
    $3, -- display_name_hebrew (same as name for now)
    $4, -- display_name_english (same as name)
    $5  -- tag_type (from requested_tag_type)
)
RETURNING id, tag_key, name, display_name_hebrew, display_name_english, tag_type, created_at
`

type ApproveTagRequestParams struct {
	TagKey             string `json:"tag_key"`
	Name               string `json:"name"`
	DisplayNameHebrew  string `json:"display_name_hebrew"`
	DisplayNameEnglish string `json:"display_name_english"`
	TagType            string `json:"tag_type"`
}

type ApproveTagRequestRow struct {
	ID                 string    `json:"id"`
	TagKey             string    `json:"tag_key"`
	Name               string    `json:"name"`
	DisplayNameHebrew  string    `json:"display_name_hebrew"`
	DisplayNameEnglish string    `json:"display_name_english"`
	TagType            string    `json:"tag_type"`
	CreatedAt          time.Time `json:"created_at"`
}

// Approve a new tag request - creates the tag and updates the request
// Step 1: Create the new tag in zman_tags table
// This query only creates the tag, the caller must update the request separately
func (q *Queries) ApproveTagRequest(ctx context.Context, arg ApproveTagRequestParams) (ApproveTagRequestRow, error) {
	row := q.db.QueryRow(ctx, approveTagRequest,
		arg.TagKey,
		arg.Name,
		arg.DisplayNameHebrew,
		arg.DisplayNameEnglish,
		arg.TagType,
	)
	var i ApproveTagRequestRow
	err := row.Scan(
		&i.ID,
		&i.TagKey,
		&i.Name,
		&i.DisplayNameHebrew,
		&i.DisplayNameEnglish,
		&i.TagType,
		&i.CreatedAt,
	)
	return i, err
}

const approveZmanRequest = `-- name: ApproveZmanRequest :one
UPDATE zman_registry_requests
SET
    status = 'approved',
    reviewed_by = $2,
    reviewed_at = NOW(),
    reviewer_notes = $3
WHERE id = $1
RETURNING id, status, reviewed_by, reviewed_at, reviewer_notes, auto_add_on_approval, publisher_id
`

type ApproveZmanRequestParams struct {
	ID            string  `json:"id"`
	ReviewedBy    *string `json:"reviewed_by"`
	ReviewerNotes *string `json:"reviewer_notes"`
}

type ApproveZmanRequestRow struct {
	ID                string             `json:"id"`
	Status            string             `json:"status"`
	ReviewedBy        *string            `json:"reviewed_by"`
	ReviewedAt        pgtype.Timestamptz `json:"reviewed_at"`
	ReviewerNotes     *string            `json:"reviewer_notes"`
	AutoAddOnApproval *bool              `json:"auto_add_on_approval"`
	PublisherID       string             `json:"publisher_id"`
}

// Approve a zman request
func (q *Queries) ApproveZmanRequest(ctx context.Context, arg ApproveZmanRequestParams) (ApproveZmanRequestRow, error) {
	row := q.db.QueryRow(ctx, approveZmanRequest, arg.ID, arg.ReviewedBy, arg.ReviewerNotes)
	var i ApproveZmanRequestRow
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.ReviewerNotes,
		&i.AutoAddOnApproval,
		&i.PublisherID,
	)
	return i, err
}

const createPublisherZmanFromRequest = `-- name: CreatePublisherZmanFromRequest :one
INSERT INTO publisher_zmanim (
    id, publisher_id, zman_key, hebrew_name, english_name,
    transliteration, description,
    formula_dsl, ai_explanation, publisher_comment,
    is_enabled, is_visible, is_published, is_custom, category,
    dependencies, sort_order, current_version
)
SELECT
    gen_random_uuid() AS id,
    zrr.publisher_id AS publisher_id,
    zrr.requested_key AS zman_key,
    zrr.requested_hebrew_name AS hebrew_name,
    zrr.requested_english_name AS english_name,
    zrr.transliteration AS transliteration,
    zrr.description AS description,
    zrr.requested_formula_dsl AS formula_dsl,
    NULL AS ai_explanation,
    NULL AS publisher_comment,
    true AS is_enabled,
    true AS is_visible,
    false AS is_published,
    true AS is_custom,
    zrr.time_category AS category,
    '{}'::text[] AS dependencies,
    999 AS sort_order,
    1 AS current_version
FROM zman_registry_requests zrr
WHERE zrr.id = $1
ON CONFLICT (publisher_id, zman_key) DO NOTHING
RETURNING id, publisher_id, zman_key, hebrew_name, english_name,
    transliteration, description, formula_dsl, ai_explanation, publisher_comment,
    is_enabled, is_visible, is_published, is_custom, category,
    dependencies, sort_order, created_at, updated_at, current_version
`

type CreatePublisherZmanFromRequestRow struct {
	ID               string    `json:"id"`
	PublisherID      string    `json:"publisher_id"`
	ZmanKey          string    `json:"zman_key"`
	HebrewName       string    `json:"hebrew_name"`
	EnglishName      string    `json:"english_name"`
	Transliteration  *string   `json:"transliteration"`
	Description      *string   `json:"description"`
	FormulaDsl       string    `json:"formula_dsl"`
	AiExplanation    *string   `json:"ai_explanation"`
	PublisherComment *string   `json:"publisher_comment"`
	IsEnabled        bool      `json:"is_enabled"`
	IsVisible        bool      `json:"is_visible"`
	IsPublished      bool      `json:"is_published"`
	IsCustom         bool      `json:"is_custom"`
	Category         string    `json:"category"`
	Dependencies     []string  `json:"dependencies"`
	SortOrder        int32     `json:"sort_order"`
	CreatedAt        time.Time `json:"created_at"`
	UpdatedAt        time.Time `json:"updated_at"`
	CurrentVersion   *int32    `json:"current_version"`
}

// Create a publisher_zman entry from an approved zman request
// This is used when auto_add_on_approval is true
func (q *Queries) CreatePublisherZmanFromRequest(ctx context.Context, id string) (CreatePublisherZmanFromRequestRow, error) {
	row := q.db.QueryRow(ctx, createPublisherZmanFromRequest, id)
	var i CreatePublisherZmanFromRequestRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.ZmanKey,
		&i.HebrewName,
		&i.EnglishName,
		&i.Transliteration,
		&i.Description,
		&i.FormulaDsl,
		&i.AiExplanation,
		&i.PublisherComment,
		&i.IsEnabled,
		&i.IsVisible,
		&i.IsPublished,
		&i.IsCustom,
		&i.Category,
		&i.Dependencies,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CurrentVersion,
	)
	return i, err
}

const createZmanRequest = `-- name: CreateZmanRequest :one

INSERT INTO zman_registry_requests (
    publisher_id,
    requested_key,
    requested_hebrew_name,
    requested_english_name,
    transliteration,
    requested_formula_dsl,
    time_category,
    description,
    halachic_notes,
    halachic_source,
    publisher_email,
    publisher_name,
    auto_add_on_approval
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13
)
RETURNING id, publisher_id, requested_key, requested_hebrew_name, requested_english_name,
    transliteration, requested_formula_dsl, time_category, description,
    halachic_notes, halachic_source, publisher_email, publisher_name, auto_add_on_approval,
    status, created_at
`

type CreateZmanRequestParams struct {
	PublisherID          string  `json:"publisher_id"`
	RequestedKey         string  `json:"requested_key"`
	RequestedHebrewName  string  `json:"requested_hebrew_name"`
	RequestedEnglishName string  `json:"requested_english_name"`
	Transliteration      *string `json:"transliteration"`
	RequestedFormulaDsl  *string `json:"requested_formula_dsl"`
	TimeCategory         string  `json:"time_category"`
	Description          *string `json:"description"`
	HalachicNotes        *string `json:"halachic_notes"`
	HalachicSource       *string `json:"halachic_source"`
	PublisherEmail       *string `json:"publisher_email"`
	PublisherName        *string `json:"publisher_name"`
	AutoAddOnApproval    *bool   `json:"auto_add_on_approval"`
}

type CreateZmanRequestRow struct {
	ID                   string    `json:"id"`
	PublisherID          string    `json:"publisher_id"`
	RequestedKey         string    `json:"requested_key"`
	RequestedHebrewName  string    `json:"requested_hebrew_name"`
	RequestedEnglishName string    `json:"requested_english_name"`
	Transliteration      *string   `json:"transliteration"`
	RequestedFormulaDsl  *string   `json:"requested_formula_dsl"`
	TimeCategory         string    `json:"time_category"`
	Description          *string   `json:"description"`
	HalachicNotes        *string   `json:"halachic_notes"`
	HalachicSource       *string   `json:"halachic_source"`
	PublisherEmail       *string   `json:"publisher_email"`
	PublisherName        *string   `json:"publisher_name"`
	AutoAddOnApproval    *bool     `json:"auto_add_on_approval"`
	Status               string    `json:"status"`
	CreatedAt            time.Time `json:"created_at"`
}

// Zman Request Queries
// Epic 5, Story 5.0: Enhanced Zman Registry Requests
// Create a new zman request from a publisher
func (q *Queries) CreateZmanRequest(ctx context.Context, arg CreateZmanRequestParams) (CreateZmanRequestRow, error) {
	row := q.db.QueryRow(ctx, createZmanRequest,
		arg.PublisherID,
		arg.RequestedKey,
		arg.RequestedHebrewName,
		arg.RequestedEnglishName,
		arg.Transliteration,
		arg.RequestedFormulaDsl,
		arg.TimeCategory,
		arg.Description,
		arg.HalachicNotes,
		arg.HalachicSource,
		arg.PublisherEmail,
		arg.PublisherName,
		arg.AutoAddOnApproval,
	)
	var i CreateZmanRequestRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.RequestedKey,
		&i.RequestedHebrewName,
		&i.RequestedEnglishName,
		&i.Transliteration,
		&i.RequestedFormulaDsl,
		&i.TimeCategory,
		&i.Description,
		&i.HalachicNotes,
		&i.HalachicSource,
		&i.PublisherEmail,
		&i.PublisherName,
		&i.AutoAddOnApproval,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const deleteZmanRequestTags = `-- name: DeleteZmanRequestTags :exec
DELETE FROM zman_request_tags WHERE request_id = $1
`

// Delete all tags for a zman request (used when updating request)
func (q *Queries) DeleteZmanRequestTags(ctx context.Context, requestID string) error {
	_, err := q.db.Exec(ctx, deleteZmanRequestTags, requestID)
	return err
}

const findTagByName = `-- name: FindTagByName :one
SELECT id, tag_key, name, display_name_hebrew, display_name_english, tag_type, created_at
FROM zman_tags
WHERE LOWER(name) = LOWER($1)
LIMIT 1
`

type FindTagByNameRow struct {
	ID                 string    `json:"id"`
	TagKey             string    `json:"tag_key"`
	Name               string    `json:"name"`
	DisplayNameHebrew  string    `json:"display_name_hebrew"`
	DisplayNameEnglish string    `json:"display_name_english"`
	TagType            string    `json:"tag_type"`
	CreatedAt          time.Time `json:"created_at"`
}

// Find an existing tag by name (case-insensitive match)
func (q *Queries) FindTagByName(ctx context.Context, lower string) (FindTagByNameRow, error) {
	row := q.db.QueryRow(ctx, findTagByName, lower)
	var i FindTagByNameRow
	err := row.Scan(
		&i.ID,
		&i.TagKey,
		&i.Name,
		&i.DisplayNameHebrew,
		&i.DisplayNameEnglish,
		&i.TagType,
		&i.CreatedAt,
	)
	return i, err
}

const getAllZmanRequests = `-- name: GetAllZmanRequests :many
SELECT
    zrr.id,
    zrr.publisher_id,
    zrr.requested_key,
    zrr.requested_hebrew_name,
    zrr.requested_english_name,
    zrr.transliteration,
    zrr.time_category,
    zrr.status,
    zrr.reviewed_by,
    zrr.reviewed_at,
    zrr.created_at,
    p.name as publisher_name
FROM zman_registry_requests zrr
JOIN publishers p ON zrr.publisher_id = p.id
WHERE ($1::text IS NULL OR zrr.status = $1)
ORDER BY
    CASE WHEN zrr.status = 'pending' THEN 0 ELSE 1 END,
    zrr.created_at DESC
`

type GetAllZmanRequestsRow struct {
	ID                   string             `json:"id"`
	PublisherID          string             `json:"publisher_id"`
	RequestedKey         string             `json:"requested_key"`
	RequestedHebrewName  string             `json:"requested_hebrew_name"`
	RequestedEnglishName string             `json:"requested_english_name"`
	Transliteration      *string            `json:"transliteration"`
	TimeCategory         string             `json:"time_category"`
	Status               string             `json:"status"`
	ReviewedBy           *string            `json:"reviewed_by"`
	ReviewedAt           pgtype.Timestamptz `json:"reviewed_at"`
	CreatedAt            time.Time          `json:"created_at"`
	PublisherName        string             `json:"publisher_name"`
}

// Get all zman requests (for admin) with optional status filter
func (q *Queries) GetAllZmanRequests(ctx context.Context, dollar_1 string) ([]GetAllZmanRequestsRow, error) {
	rows, err := q.db.Query(ctx, getAllZmanRequests, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllZmanRequestsRow{}
	for rows.Next() {
		var i GetAllZmanRequestsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublisherID,
			&i.RequestedKey,
			&i.RequestedHebrewName,
			&i.RequestedEnglishName,
			&i.Transliteration,
			&i.TimeCategory,
			&i.Status,
			&i.ReviewedBy,
			&i.ReviewedAt,
			&i.CreatedAt,
			&i.PublisherName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingZmanRequestCount = `-- name: GetPendingZmanRequestCount :one
SELECT COUNT(*) as count
FROM zman_registry_requests
WHERE status = 'pending'
`

// Get count of pending zman requests (for admin dashboard)
func (q *Queries) GetPendingZmanRequestCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getPendingZmanRequestCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getPublisherZmanRequests = `-- name: GetPublisherZmanRequests :many
SELECT
    id,
    publisher_id,
    requested_key,
    requested_hebrew_name,
    requested_english_name,
    transliteration,
    time_category,
    status,
    reviewed_at,
    reviewer_notes,
    created_at
FROM zman_registry_requests
WHERE publisher_id = $1
ORDER BY created_at DESC
`

type GetPublisherZmanRequestsRow struct {
	ID                   string             `json:"id"`
	PublisherID          string             `json:"publisher_id"`
	RequestedKey         string             `json:"requested_key"`
	RequestedHebrewName  string             `json:"requested_hebrew_name"`
	RequestedEnglishName string             `json:"requested_english_name"`
	Transliteration      *string            `json:"transliteration"`
	TimeCategory         string             `json:"time_category"`
	Status               string             `json:"status"`
	ReviewedAt           pgtype.Timestamptz `json:"reviewed_at"`
	ReviewerNotes        *string            `json:"reviewer_notes"`
	CreatedAt            time.Time          `json:"created_at"`
}

// Get all zman requests for a specific publisher
func (q *Queries) GetPublisherZmanRequests(ctx context.Context, publisherID string) ([]GetPublisherZmanRequestsRow, error) {
	rows, err := q.db.Query(ctx, getPublisherZmanRequests, publisherID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPublisherZmanRequestsRow{}
	for rows.Next() {
		var i GetPublisherZmanRequestsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublisherID,
			&i.RequestedKey,
			&i.RequestedHebrewName,
			&i.RequestedEnglishName,
			&i.Transliteration,
			&i.TimeCategory,
			&i.Status,
			&i.ReviewedAt,
			&i.ReviewerNotes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getZmanRequest = `-- name: GetZmanRequest :one
SELECT
    zrr.id,
    zrr.publisher_id,
    zrr.requested_key,
    zrr.requested_hebrew_name,
    zrr.requested_english_name,
    zrr.transliteration,
    zrr.requested_formula_dsl,
    zrr.time_category,
    zrr.description,
    zrr.halachic_notes,
    zrr.halachic_source,
    zrr.publisher_email,
    zrr.publisher_name,
    zrr.auto_add_on_approval,
    zrr.status,
    zrr.reviewed_by,
    zrr.reviewed_at,
    zrr.reviewer_notes,
    zrr.created_at,
    p.name as submitter_name
FROM zman_registry_requests zrr
JOIN publishers p ON zrr.publisher_id = p.id
WHERE zrr.id = $1
`

type GetZmanRequestRow struct {
	ID                   string             `json:"id"`
	PublisherID          string             `json:"publisher_id"`
	RequestedKey         string             `json:"requested_key"`
	RequestedHebrewName  string             `json:"requested_hebrew_name"`
	RequestedEnglishName string             `json:"requested_english_name"`
	Transliteration      *string            `json:"transliteration"`
	RequestedFormulaDsl  *string            `json:"requested_formula_dsl"`
	TimeCategory         string             `json:"time_category"`
	Description          *string            `json:"description"`
	HalachicNotes        *string            `json:"halachic_notes"`
	HalachicSource       *string            `json:"halachic_source"`
	PublisherEmail       *string            `json:"publisher_email"`
	PublisherName        *string            `json:"publisher_name"`
	AutoAddOnApproval    *bool              `json:"auto_add_on_approval"`
	Status               string             `json:"status"`
	ReviewedBy           *string            `json:"reviewed_by"`
	ReviewedAt           pgtype.Timestamptz `json:"reviewed_at"`
	ReviewerNotes        *string            `json:"reviewer_notes"`
	CreatedAt            time.Time          `json:"created_at"`
	SubmitterName        string             `json:"submitter_name"`
}

// Get a specific zman request by ID
func (q *Queries) GetZmanRequest(ctx context.Context, id string) (GetZmanRequestRow, error) {
	row := q.db.QueryRow(ctx, getZmanRequest, id)
	var i GetZmanRequestRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.RequestedKey,
		&i.RequestedHebrewName,
		&i.RequestedEnglishName,
		&i.Transliteration,
		&i.RequestedFormulaDsl,
		&i.TimeCategory,
		&i.Description,
		&i.HalachicNotes,
		&i.HalachicSource,
		&i.PublisherEmail,
		&i.PublisherName,
		&i.AutoAddOnApproval,
		&i.Status,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.ReviewerNotes,
		&i.CreatedAt,
		&i.SubmitterName,
	)
	return i, err
}

const getZmanRequestTag = `-- name: GetZmanRequestTag :one
SELECT
    zrt.id,
    zrt.request_id,
    zrt.tag_id,
    zrt.requested_tag_name,
    zrt.requested_tag_type,
    zrt.is_new_tag_request,
    zrt.created_at
FROM zman_request_tags zrt
WHERE zrt.id = $1
`

// Get a specific tag request by ID
func (q *Queries) GetZmanRequestTag(ctx context.Context, id string) (ZmanRequestTag, error) {
	row := q.db.QueryRow(ctx, getZmanRequestTag, id)
	var i ZmanRequestTag
	err := row.Scan(
		&i.ID,
		&i.RequestID,
		&i.TagID,
		&i.RequestedTagName,
		&i.RequestedTagType,
		&i.IsNewTagRequest,
		&i.CreatedAt,
	)
	return i, err
}

const getZmanRequestTags = `-- name: GetZmanRequestTags :many
SELECT
    zrt.id,
    zrt.request_id,
    zrt.tag_id,
    zrt.requested_tag_name,
    zrt.requested_tag_type,
    zrt.is_new_tag_request,
    zrt.created_at,
    zt.tag_key as existing_tag_key,
    zt.name as existing_tag_name,
    zt.tag_type as existing_tag_type
FROM zman_request_tags zrt
LEFT JOIN zman_tags zt ON zrt.tag_id = zt.id
WHERE zrt.request_id = $1
`

type GetZmanRequestTagsRow struct {
	ID               string      `json:"id"`
	RequestID        string      `json:"request_id"`
	TagID            pgtype.UUID `json:"tag_id"`
	RequestedTagName *string     `json:"requested_tag_name"`
	RequestedTagType *string     `json:"requested_tag_type"`
	IsNewTagRequest  bool        `json:"is_new_tag_request"`
	CreatedAt        time.Time   `json:"created_at"`
	ExistingTagKey   *string     `json:"existing_tag_key"`
	ExistingTagName  *string     `json:"existing_tag_name"`
	ExistingTagType  *string     `json:"existing_tag_type"`
}

// Get all tags (existing and requested) for a zman request
func (q *Queries) GetZmanRequestTags(ctx context.Context, requestID string) ([]GetZmanRequestTagsRow, error) {
	rows, err := q.db.Query(ctx, getZmanRequestTags, requestID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetZmanRequestTagsRow{}
	for rows.Next() {
		var i GetZmanRequestTagsRow
		if err := rows.Scan(
			&i.ID,
			&i.RequestID,
			&i.TagID,
			&i.RequestedTagName,
			&i.RequestedTagType,
			&i.IsNewTagRequest,
			&i.CreatedAt,
			&i.ExistingTagKey,
			&i.ExistingTagName,
			&i.ExistingTagType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const linkTagToRequest = `-- name: LinkTagToRequest :exec
UPDATE zman_request_tags
SET
    tag_id = $2,
    is_new_tag_request = false,
    requested_tag_name = NULL,
    requested_tag_type = NULL
WHERE id = $1
`

type LinkTagToRequestParams struct {
	ID    string      `json:"id"`
	TagID pgtype.UUID `json:"tag_id"`
}

// Update the tag request to link the newly created tag
// Must also clear requested_tag_name to satisfy tag_reference_check constraint
func (q *Queries) LinkTagToRequest(ctx context.Context, arg LinkTagToRequestParams) error {
	_, err := q.db.Exec(ctx, linkTagToRequest, arg.ID, arg.TagID)
	return err
}

const rejectTagRequest = `-- name: RejectTagRequest :exec
DELETE FROM zman_request_tags
WHERE id = $1 AND is_new_tag_request = true
`

// Reject a new tag request by deleting it from zman_request_tags
func (q *Queries) RejectTagRequest(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, rejectTagRequest, id)
	return err
}

const rejectZmanRequest = `-- name: RejectZmanRequest :one
UPDATE zman_registry_requests
SET
    status = 'rejected',
    reviewed_by = $2,
    reviewed_at = NOW(),
    reviewer_notes = $3
WHERE id = $1
RETURNING id, status, reviewed_by, reviewed_at, reviewer_notes
`

type RejectZmanRequestParams struct {
	ID            string  `json:"id"`
	ReviewedBy    *string `json:"reviewed_by"`
	ReviewerNotes *string `json:"reviewer_notes"`
}

type RejectZmanRequestRow struct {
	ID            string             `json:"id"`
	Status        string             `json:"status"`
	ReviewedBy    *string            `json:"reviewed_by"`
	ReviewedAt    pgtype.Timestamptz `json:"reviewed_at"`
	ReviewerNotes *string            `json:"reviewer_notes"`
}

// Reject a zman request
func (q *Queries) RejectZmanRequest(ctx context.Context, arg RejectZmanRequestParams) (RejectZmanRequestRow, error) {
	row := q.db.QueryRow(ctx, rejectZmanRequest, arg.ID, arg.ReviewedBy, arg.ReviewerNotes)
	var i RejectZmanRequestRow
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.ReviewerNotes,
	)
	return i, err
}
