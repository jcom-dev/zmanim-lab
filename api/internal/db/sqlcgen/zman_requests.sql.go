// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: zman_requests.sql

package sqlcgen

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const addZmanRequestNewTag = `-- name: AddZmanRequestNewTag :one
INSERT INTO zman_request_tags (
    request_id,
    requested_tag_name,
    requested_tag_type,
    is_new_tag_request
) VALUES ($1, $2, $3, true)
RETURNING id, request_id, requested_tag_name, requested_tag_type, is_new_tag_request, created_at
`

type AddZmanRequestNewTagParams struct {
	RequestID        string  `json:"request_id"`
	RequestedTagName *string `json:"requested_tag_name"`
	RequestedTagType *string `json:"requested_tag_type"`
}

type AddZmanRequestNewTagRow struct {
	ID               string    `json:"id"`
	RequestID        string    `json:"request_id"`
	RequestedTagName *string   `json:"requested_tag_name"`
	RequestedTagType *string   `json:"requested_tag_type"`
	IsNewTagRequest  bool      `json:"is_new_tag_request"`
	CreatedAt        time.Time `json:"created_at"`
}

// Request a new tag for a zman request
func (q *Queries) AddZmanRequestNewTag(ctx context.Context, arg AddZmanRequestNewTagParams) (AddZmanRequestNewTagRow, error) {
	row := q.db.QueryRow(ctx, addZmanRequestNewTag, arg.RequestID, arg.RequestedTagName, arg.RequestedTagType)
	var i AddZmanRequestNewTagRow
	err := row.Scan(
		&i.ID,
		&i.RequestID,
		&i.RequestedTagName,
		&i.RequestedTagType,
		&i.IsNewTagRequest,
		&i.CreatedAt,
	)
	return i, err
}

const addZmanRequestTag = `-- name: AddZmanRequestTag :one
INSERT INTO zman_request_tags (
    request_id,
    tag_id,
    is_new_tag_request
) VALUES ($1, $2, false)
RETURNING id, request_id, tag_id, is_new_tag_request, created_at
`

type AddZmanRequestTagParams struct {
	RequestID string      `json:"request_id"`
	TagID     pgtype.UUID `json:"tag_id"`
}

type AddZmanRequestTagRow struct {
	ID              string      `json:"id"`
	RequestID       string      `json:"request_id"`
	TagID           pgtype.UUID `json:"tag_id"`
	IsNewTagRequest bool        `json:"is_new_tag_request"`
	CreatedAt       time.Time   `json:"created_at"`
}

// Add an existing tag to a zman request
func (q *Queries) AddZmanRequestTag(ctx context.Context, arg AddZmanRequestTagParams) (AddZmanRequestTagRow, error) {
	row := q.db.QueryRow(ctx, addZmanRequestTag, arg.RequestID, arg.TagID)
	var i AddZmanRequestTagRow
	err := row.Scan(
		&i.ID,
		&i.RequestID,
		&i.TagID,
		&i.IsNewTagRequest,
		&i.CreatedAt,
	)
	return i, err
}

const approveZmanRequest = `-- name: ApproveZmanRequest :one
UPDATE zman_registry_requests
SET
    status = 'approved',
    reviewed_by = $2,
    reviewed_at = NOW(),
    reviewer_notes = $3
WHERE id = $1
RETURNING id, status, reviewed_by, reviewed_at, reviewer_notes, auto_add_on_approval, publisher_id
`

type ApproveZmanRequestParams struct {
	ID            string  `json:"id"`
	ReviewedBy    *string `json:"reviewed_by"`
	ReviewerNotes *string `json:"reviewer_notes"`
}

type ApproveZmanRequestRow struct {
	ID                string             `json:"id"`
	Status            string             `json:"status"`
	ReviewedBy        *string            `json:"reviewed_by"`
	ReviewedAt        pgtype.Timestamptz `json:"reviewed_at"`
	ReviewerNotes     *string            `json:"reviewer_notes"`
	AutoAddOnApproval *bool              `json:"auto_add_on_approval"`
	PublisherID       string             `json:"publisher_id"`
}

// Approve a zman request
func (q *Queries) ApproveZmanRequest(ctx context.Context, arg ApproveZmanRequestParams) (ApproveZmanRequestRow, error) {
	row := q.db.QueryRow(ctx, approveZmanRequest, arg.ID, arg.ReviewedBy, arg.ReviewerNotes)
	var i ApproveZmanRequestRow
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.ReviewerNotes,
		&i.AutoAddOnApproval,
		&i.PublisherID,
	)
	return i, err
}

const createZmanRequest = `-- name: CreateZmanRequest :one

INSERT INTO zman_registry_requests (
    publisher_id,
    requested_key,
    requested_hebrew_name,
    requested_english_name,
    transliteration,
    requested_formula_dsl,
    time_category,
    justification,
    description,
    halachic_notes,
    halachic_source,
    publisher_email,
    publisher_name,
    auto_add_on_approval
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14
)
RETURNING id, publisher_id, requested_key, requested_hebrew_name, requested_english_name,
    transliteration, requested_formula_dsl, time_category, justification, description,
    halachic_notes, halachic_source, publisher_email, publisher_name, auto_add_on_approval,
    status, created_at
`

type CreateZmanRequestParams struct {
	PublisherID          string  `json:"publisher_id"`
	RequestedKey         string  `json:"requested_key"`
	RequestedHebrewName  string  `json:"requested_hebrew_name"`
	RequestedEnglishName string  `json:"requested_english_name"`
	Transliteration      *string `json:"transliteration"`
	RequestedFormulaDsl  *string `json:"requested_formula_dsl"`
	TimeCategory         string  `json:"time_category"`
	Justification        string  `json:"justification"`
	Description          *string `json:"description"`
	HalachicNotes        *string `json:"halachic_notes"`
	HalachicSource       *string `json:"halachic_source"`
	PublisherEmail       *string `json:"publisher_email"`
	PublisherName        *string `json:"publisher_name"`
	AutoAddOnApproval    *bool   `json:"auto_add_on_approval"`
}

type CreateZmanRequestRow struct {
	ID                   string    `json:"id"`
	PublisherID          string    `json:"publisher_id"`
	RequestedKey         string    `json:"requested_key"`
	RequestedHebrewName  string    `json:"requested_hebrew_name"`
	RequestedEnglishName string    `json:"requested_english_name"`
	Transliteration      *string   `json:"transliteration"`
	RequestedFormulaDsl  *string   `json:"requested_formula_dsl"`
	TimeCategory         string    `json:"time_category"`
	Justification        string    `json:"justification"`
	Description          *string   `json:"description"`
	HalachicNotes        *string   `json:"halachic_notes"`
	HalachicSource       *string   `json:"halachic_source"`
	PublisherEmail       *string   `json:"publisher_email"`
	PublisherName        *string   `json:"publisher_name"`
	AutoAddOnApproval    *bool     `json:"auto_add_on_approval"`
	Status               string    `json:"status"`
	CreatedAt            time.Time `json:"created_at"`
}

// Zman Request Queries
// Epic 5, Story 5.0: Enhanced Zman Registry Requests
// Create a new zman request from a publisher
func (q *Queries) CreateZmanRequest(ctx context.Context, arg CreateZmanRequestParams) (CreateZmanRequestRow, error) {
	row := q.db.QueryRow(ctx, createZmanRequest,
		arg.PublisherID,
		arg.RequestedKey,
		arg.RequestedHebrewName,
		arg.RequestedEnglishName,
		arg.Transliteration,
		arg.RequestedFormulaDsl,
		arg.TimeCategory,
		arg.Justification,
		arg.Description,
		arg.HalachicNotes,
		arg.HalachicSource,
		arg.PublisherEmail,
		arg.PublisherName,
		arg.AutoAddOnApproval,
	)
	var i CreateZmanRequestRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.RequestedKey,
		&i.RequestedHebrewName,
		&i.RequestedEnglishName,
		&i.Transliteration,
		&i.RequestedFormulaDsl,
		&i.TimeCategory,
		&i.Justification,
		&i.Description,
		&i.HalachicNotes,
		&i.HalachicSource,
		&i.PublisherEmail,
		&i.PublisherName,
		&i.AutoAddOnApproval,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const deleteZmanRequestTags = `-- name: DeleteZmanRequestTags :exec
DELETE FROM zman_request_tags WHERE request_id = $1
`

// Delete all tags for a zman request (used when updating request)
func (q *Queries) DeleteZmanRequestTags(ctx context.Context, requestID string) error {
	_, err := q.db.Exec(ctx, deleteZmanRequestTags, requestID)
	return err
}

const getAllZmanRequests = `-- name: GetAllZmanRequests :many
SELECT
    zrr.id,
    zrr.publisher_id,
    zrr.requested_key,
    zrr.requested_hebrew_name,
    zrr.requested_english_name,
    zrr.transliteration,
    zrr.time_category,
    zrr.status,
    zrr.reviewed_by,
    zrr.reviewed_at,
    zrr.created_at,
    p.name as publisher_name,
    p.organization as publisher_organization
FROM zman_registry_requests zrr
JOIN publishers p ON zrr.publisher_id = p.id
WHERE ($1::text IS NULL OR zrr.status = $1)
ORDER BY
    CASE WHEN zrr.status = 'pending' THEN 0 ELSE 1 END,
    zrr.created_at DESC
`

type GetAllZmanRequestsRow struct {
	ID                    string             `json:"id"`
	PublisherID           string             `json:"publisher_id"`
	RequestedKey          string             `json:"requested_key"`
	RequestedHebrewName   string             `json:"requested_hebrew_name"`
	RequestedEnglishName  string             `json:"requested_english_name"`
	Transliteration       *string            `json:"transliteration"`
	TimeCategory          string             `json:"time_category"`
	Status                string             `json:"status"`
	ReviewedBy            *string            `json:"reviewed_by"`
	ReviewedAt            pgtype.Timestamptz `json:"reviewed_at"`
	CreatedAt             time.Time          `json:"created_at"`
	PublisherName         string             `json:"publisher_name"`
	PublisherOrganization *string            `json:"publisher_organization"`
}

// Get all zman requests (for admin) with optional status filter
func (q *Queries) GetAllZmanRequests(ctx context.Context, dollar_1 string) ([]GetAllZmanRequestsRow, error) {
	rows, err := q.db.Query(ctx, getAllZmanRequests, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllZmanRequestsRow{}
	for rows.Next() {
		var i GetAllZmanRequestsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublisherID,
			&i.RequestedKey,
			&i.RequestedHebrewName,
			&i.RequestedEnglishName,
			&i.Transliteration,
			&i.TimeCategory,
			&i.Status,
			&i.ReviewedBy,
			&i.ReviewedAt,
			&i.CreatedAt,
			&i.PublisherName,
			&i.PublisherOrganization,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingZmanRequestCount = `-- name: GetPendingZmanRequestCount :one
SELECT COUNT(*) as count
FROM zman_registry_requests
WHERE status = 'pending'
`

// Get count of pending zman requests (for admin dashboard)
func (q *Queries) GetPendingZmanRequestCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getPendingZmanRequestCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getPublisherZmanRequests = `-- name: GetPublisherZmanRequests :many
SELECT
    id,
    publisher_id,
    requested_key,
    requested_hebrew_name,
    requested_english_name,
    transliteration,
    time_category,
    status,
    reviewed_at,
    reviewer_notes,
    created_at
FROM zman_registry_requests
WHERE publisher_id = $1
ORDER BY created_at DESC
`

type GetPublisherZmanRequestsRow struct {
	ID                   string             `json:"id"`
	PublisherID          string             `json:"publisher_id"`
	RequestedKey         string             `json:"requested_key"`
	RequestedHebrewName  string             `json:"requested_hebrew_name"`
	RequestedEnglishName string             `json:"requested_english_name"`
	Transliteration      *string            `json:"transliteration"`
	TimeCategory         string             `json:"time_category"`
	Status               string             `json:"status"`
	ReviewedAt           pgtype.Timestamptz `json:"reviewed_at"`
	ReviewerNotes        *string            `json:"reviewer_notes"`
	CreatedAt            time.Time          `json:"created_at"`
}

// Get all zman requests for a specific publisher
func (q *Queries) GetPublisherZmanRequests(ctx context.Context, publisherID string) ([]GetPublisherZmanRequestsRow, error) {
	rows, err := q.db.Query(ctx, getPublisherZmanRequests, publisherID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPublisherZmanRequestsRow{}
	for rows.Next() {
		var i GetPublisherZmanRequestsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublisherID,
			&i.RequestedKey,
			&i.RequestedHebrewName,
			&i.RequestedEnglishName,
			&i.Transliteration,
			&i.TimeCategory,
			&i.Status,
			&i.ReviewedAt,
			&i.ReviewerNotes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getZmanRequest = `-- name: GetZmanRequest :one
SELECT
    zrr.id,
    zrr.publisher_id,
    zrr.requested_key,
    zrr.requested_hebrew_name,
    zrr.requested_english_name,
    zrr.transliteration,
    zrr.requested_formula_dsl,
    zrr.time_category,
    zrr.justification,
    zrr.description,
    zrr.halachic_notes,
    zrr.halachic_source,
    zrr.publisher_email,
    zrr.publisher_name,
    zrr.auto_add_on_approval,
    zrr.status,
    zrr.reviewed_by,
    zrr.reviewed_at,
    zrr.reviewer_notes,
    zrr.created_at,
    p.name as submitter_name,
    p.organization as submitter_organization
FROM zman_registry_requests zrr
JOIN publishers p ON zrr.publisher_id = p.id
WHERE zrr.id = $1
`

type GetZmanRequestRow struct {
	ID                    string             `json:"id"`
	PublisherID           string             `json:"publisher_id"`
	RequestedKey          string             `json:"requested_key"`
	RequestedHebrewName   string             `json:"requested_hebrew_name"`
	RequestedEnglishName  string             `json:"requested_english_name"`
	Transliteration       *string            `json:"transliteration"`
	RequestedFormulaDsl   *string            `json:"requested_formula_dsl"`
	TimeCategory          string             `json:"time_category"`
	Justification         string             `json:"justification"`
	Description           *string            `json:"description"`
	HalachicNotes         *string            `json:"halachic_notes"`
	HalachicSource        *string            `json:"halachic_source"`
	PublisherEmail        *string            `json:"publisher_email"`
	PublisherName         *string            `json:"publisher_name"`
	AutoAddOnApproval     *bool              `json:"auto_add_on_approval"`
	Status                string             `json:"status"`
	ReviewedBy            *string            `json:"reviewed_by"`
	ReviewedAt            pgtype.Timestamptz `json:"reviewed_at"`
	ReviewerNotes         *string            `json:"reviewer_notes"`
	CreatedAt             time.Time          `json:"created_at"`
	SubmitterName         string             `json:"submitter_name"`
	SubmitterOrganization *string            `json:"submitter_organization"`
}

// Get a specific zman request by ID
func (q *Queries) GetZmanRequest(ctx context.Context, id string) (GetZmanRequestRow, error) {
	row := q.db.QueryRow(ctx, getZmanRequest, id)
	var i GetZmanRequestRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.RequestedKey,
		&i.RequestedHebrewName,
		&i.RequestedEnglishName,
		&i.Transliteration,
		&i.RequestedFormulaDsl,
		&i.TimeCategory,
		&i.Justification,
		&i.Description,
		&i.HalachicNotes,
		&i.HalachicSource,
		&i.PublisherEmail,
		&i.PublisherName,
		&i.AutoAddOnApproval,
		&i.Status,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.ReviewerNotes,
		&i.CreatedAt,
		&i.SubmitterName,
		&i.SubmitterOrganization,
	)
	return i, err
}

const getZmanRequestTags = `-- name: GetZmanRequestTags :many
SELECT
    zrt.id,
    zrt.request_id,
    zrt.tag_id,
    zrt.requested_tag_name,
    zrt.requested_tag_type,
    zrt.is_new_tag_request,
    zrt.created_at,
    zt.tag_key as existing_tag_key,
    zt.name as existing_tag_name,
    zt.tag_type as existing_tag_type
FROM zman_request_tags zrt
LEFT JOIN zman_tags zt ON zrt.tag_id = zt.id
WHERE zrt.request_id = $1
`

type GetZmanRequestTagsRow struct {
	ID               string      `json:"id"`
	RequestID        string      `json:"request_id"`
	TagID            pgtype.UUID `json:"tag_id"`
	RequestedTagName *string     `json:"requested_tag_name"`
	RequestedTagType *string     `json:"requested_tag_type"`
	IsNewTagRequest  bool        `json:"is_new_tag_request"`
	CreatedAt        time.Time   `json:"created_at"`
	ExistingTagKey   *string     `json:"existing_tag_key"`
	ExistingTagName  *string     `json:"existing_tag_name"`
	ExistingTagType  *string     `json:"existing_tag_type"`
}

// Get all tags (existing and requested) for a zman request
func (q *Queries) GetZmanRequestTags(ctx context.Context, requestID string) ([]GetZmanRequestTagsRow, error) {
	rows, err := q.db.Query(ctx, getZmanRequestTags, requestID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetZmanRequestTagsRow{}
	for rows.Next() {
		var i GetZmanRequestTagsRow
		if err := rows.Scan(
			&i.ID,
			&i.RequestID,
			&i.TagID,
			&i.RequestedTagName,
			&i.RequestedTagType,
			&i.IsNewTagRequest,
			&i.CreatedAt,
			&i.ExistingTagKey,
			&i.ExistingTagName,
			&i.ExistingTagType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const rejectZmanRequest = `-- name: RejectZmanRequest :one
UPDATE zman_registry_requests
SET
    status = 'rejected',
    reviewed_by = $2,
    reviewed_at = NOW(),
    reviewer_notes = $3
WHERE id = $1
RETURNING id, status, reviewed_by, reviewed_at, reviewer_notes
`

type RejectZmanRequestParams struct {
	ID            string  `json:"id"`
	ReviewedBy    *string `json:"reviewed_by"`
	ReviewerNotes *string `json:"reviewer_notes"`
}

type RejectZmanRequestRow struct {
	ID            string             `json:"id"`
	Status        string             `json:"status"`
	ReviewedBy    *string            `json:"reviewed_by"`
	ReviewedAt    pgtype.Timestamptz `json:"reviewed_at"`
	ReviewerNotes *string            `json:"reviewer_notes"`
}

// Reject a zman request
func (q *Queries) RejectZmanRequest(ctx context.Context, arg RejectZmanRequestParams) (RejectZmanRequestRow, error) {
	row := q.db.QueryRow(ctx, rejectZmanRequest, arg.ID, arg.ReviewedBy, arg.ReviewerNotes)
	var i RejectZmanRequestRow
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.ReviewerNotes,
	)
	return i, err
}
