// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: tag_events.sql

package sqlcgen

import (
	"context"
)

const countTagsByType = `-- name: CountTagsByType :many
SELECT
    tag_type,
    COUNT(*) AS count
FROM zman_tags
GROUP BY tag_type
ORDER BY
    CASE tag_type
        WHEN 'behavior' THEN 1
        WHEN 'event' THEN 2
        WHEN 'jewish_day' THEN 3
        WHEN 'timing' THEN 4
        WHEN 'shita' THEN 5
        WHEN 'calculation' THEN 6
        WHEN 'category' THEN 7
        ELSE 8
    END
`

type CountTagsByTypeRow struct {
	TagType string `json:"tag_type"`
	Count   int64  `json:"count"`
}

// Get count of tags per type (for UI display)
func (q *Queries) CountTagsByType(ctx context.Context) ([]CountTagsByTypeRow, error) {
	rows, err := q.db.Query(ctx, countTagsByType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CountTagsByTypeRow{}
	for rows.Next() {
		var i CountTagsByTypeRow
		if err := rows.Scan(&i.TagType, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllTagsWithKey = `-- name: GetAllTagsWithKey :many

SELECT
    id,
    tag_key,
    name,
    display_name_hebrew,
    display_name_english,
    tag_type,
    description,
    color,
    sort_order
FROM zman_tags
ORDER BY
    CASE tag_type
        WHEN 'behavior' THEN 1
        WHEN 'event' THEN 2
        WHEN 'jewish_day' THEN 3
        WHEN 'timing' THEN 4
        WHEN 'shita' THEN 5
        WHEN 'calculation' THEN 6
        WHEN 'category' THEN 7
        ELSE 8
    END,
    sort_order,
    display_name_english
`

type GetAllTagsWithKeyRow struct {
	ID                 string  `json:"id"`
	TagKey             string  `json:"tag_key"`
	Name               string  `json:"name"`
	DisplayNameHebrew  string  `json:"display_name_hebrew"`
	DisplayNameEnglish string  `json:"display_name_english"`
	TagType            string  `json:"tag_type"`
	Description        *string `json:"description"`
	Color              *string `json:"color"`
	SortOrder          *int32  `json:"sort_order"`
}

// ============================================================================
// All Tags Queries (with tag_key - extends master_registry.sql queries)
// ============================================================================
// Get all tags ordered by type and sort order (includes tag_key)
func (q *Queries) GetAllTagsWithKey(ctx context.Context) ([]GetAllTagsWithKeyRow, error) {
	rows, err := q.db.Query(ctx, getAllTagsWithKey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllTagsWithKeyRow{}
	for rows.Next() {
		var i GetAllTagsWithKeyRow
		if err := rows.Scan(
			&i.ID,
			&i.TagKey,
			&i.Name,
			&i.DisplayNameHebrew,
			&i.DisplayNameEnglish,
			&i.TagType,
			&i.Description,
			&i.Color,
			&i.SortOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJewishDayTags = `-- name: GetJewishDayTags :many
SELECT
    id,
    tag_key,
    name,
    display_name_hebrew,
    display_name_english,
    tag_type,
    description,
    color,
    sort_order
FROM zman_tags
WHERE tag_type = 'jewish_day'
ORDER BY sort_order, display_name_english
`

type GetJewishDayTagsRow struct {
	ID                 string  `json:"id"`
	TagKey             string  `json:"tag_key"`
	Name               string  `json:"name"`
	DisplayNameHebrew  string  `json:"display_name_hebrew"`
	DisplayNameEnglish string  `json:"display_name_english"`
	TagType            string  `json:"tag_type"`
	Description        *string `json:"description"`
	Color              *string `json:"color"`
	SortOrder          *int32  `json:"sort_order"`
}

// Get all jewish_day type tags (for calendar filtering)
func (q *Queries) GetJewishDayTags(ctx context.Context) ([]GetJewishDayTagsRow, error) {
	rows, err := q.db.Query(ctx, getJewishDayTags)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetJewishDayTagsRow{}
	for rows.Next() {
		var i GetJewishDayTagsRow
		if err := rows.Scan(
			&i.ID,
			&i.TagKey,
			&i.Name,
			&i.DisplayNameHebrew,
			&i.DisplayNameEnglish,
			&i.TagType,
			&i.Description,
			&i.Color,
			&i.SortOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMasterZmanimByTags = `-- name: GetMasterZmanimByTags :many
SELECT DISTINCT
    mr.id,
    mr.zman_key,
    mr.canonical_hebrew_name,
    mr.canonical_english_name,
    mr.default_formula_dsl,
    mr.time_category,
    mr.is_core
FROM master_zmanim_registry mr
JOIN master_zman_tags mzt ON mzt.master_zman_id = mr.id
JOIN zman_tags t ON t.id = mzt.tag_id
WHERE t.tag_key = ANY($1::text[])
  AND mr.is_hidden = false
ORDER BY mr.canonical_hebrew_name
`

type GetMasterZmanimByTagsRow struct {
	ID                   string `json:"id"`
	ZmanKey              string `json:"zman_key"`
	CanonicalHebrewName  string `json:"canonical_hebrew_name"`
	CanonicalEnglishName string `json:"canonical_english_name"`
	DefaultFormulaDsl    string `json:"default_formula_dsl"`
	TimeCategory         string `json:"time_category"`
	IsCore               *bool  `json:"is_core"`
}

// Get master registry zmanim that have any of the specified tags
func (q *Queries) GetMasterZmanimByTags(ctx context.Context, dollar_1 []string) ([]GetMasterZmanimByTagsRow, error) {
	rows, err := q.db.Query(ctx, getMasterZmanimByTags, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMasterZmanimByTagsRow{}
	for rows.Next() {
		var i GetMasterZmanimByTagsRow
		if err := rows.Scan(
			&i.ID,
			&i.ZmanKey,
			&i.CanonicalHebrewName,
			&i.CanonicalEnglishName,
			&i.DefaultFormulaDsl,
			&i.TimeCategory,
			&i.IsCore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagByKey = `-- name: GetTagByKey :one
SELECT
    id,
    tag_key,
    name,
    display_name_hebrew,
    display_name_english,
    tag_type,
    description,
    color,
    sort_order
FROM zman_tags
WHERE tag_key = $1
`

type GetTagByKeyRow struct {
	ID                 string  `json:"id"`
	TagKey             string  `json:"tag_key"`
	Name               string  `json:"name"`
	DisplayNameHebrew  string  `json:"display_name_hebrew"`
	DisplayNameEnglish string  `json:"display_name_english"`
	TagType            string  `json:"tag_type"`
	Description        *string `json:"description"`
	Color              *string `json:"color"`
	SortOrder          *int32  `json:"sort_order"`
}

// Get a single tag by its key
func (q *Queries) GetTagByKey(ctx context.Context, tagKey string) (GetTagByKeyRow, error) {
	row := q.db.QueryRow(ctx, getTagByKey, tagKey)
	var i GetTagByKeyRow
	err := row.Scan(
		&i.ID,
		&i.TagKey,
		&i.Name,
		&i.DisplayNameHebrew,
		&i.DisplayNameEnglish,
		&i.TagType,
		&i.Description,
		&i.Color,
		&i.SortOrder,
	)
	return i, err
}

const getTagEventMappings = `-- name: GetTagEventMappings :many


SELECT
    t.tag_key,
    m.hebcal_event_pattern AS pattern,
    m.priority
FROM tag_event_mappings m
JOIN zman_tags t ON t.id = m.tag_id
WHERE m.hebcal_event_pattern IS NOT NULL
ORDER BY m.priority DESC
`

type GetTagEventMappingsRow struct {
	TagKey   string  `json:"tag_key"`
	Pattern  *string `json:"pattern"`
	Priority *int32  `json:"priority"`
}

// Tag Events SQL Queries
// SQLc will generate type-safe Go code from these queries
// ============================================================================
// Tag Event Mappings
// ============================================================================
// Get all HebCal event mappings for tag matching
func (q *Queries) GetTagEventMappings(ctx context.Context) ([]GetTagEventMappingsRow, error) {
	rows, err := q.db.Query(ctx, getTagEventMappings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTagEventMappingsRow{}
	for rows.Next() {
		var i GetTagEventMappingsRow
		if err := rows.Scan(&i.TagKey, &i.Pattern, &i.Priority); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagTypes = `-- name: GetTagTypes :many

SELECT
    id,
    key,
    display_name_hebrew,
    display_name_english,
    color,
    sort_order
FROM tag_types
ORDER BY sort_order
`

type GetTagTypesRow struct {
	ID                 string  `json:"id"`
	Key                string  `json:"key"`
	DisplayNameHebrew  string  `json:"display_name_hebrew"`
	DisplayNameEnglish string  `json:"display_name_english"`
	Color              *string `json:"color"`
	SortOrder          int32   `json:"sort_order"`
}

// ============================================================================
// Tag Types Metadata
// ============================================================================
// Get all tag types with their styling
func (q *Queries) GetTagTypes(ctx context.Context) ([]GetTagTypesRow, error) {
	rows, err := q.db.Query(ctx, getTagTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTagTypesRow{}
	for rows.Next() {
		var i GetTagTypesRow
		if err := rows.Scan(
			&i.ID,
			&i.Key,
			&i.DisplayNameHebrew,
			&i.DisplayNameEnglish,
			&i.Color,
			&i.SortOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagsByKeys = `-- name: GetTagsByKeys :many
SELECT
    id,
    tag_key,
    name,
    display_name_hebrew,
    display_name_english,
    tag_type,
    description,
    color,
    sort_order
FROM zman_tags
WHERE tag_key = ANY($1::text[])
ORDER BY sort_order, display_name_english
`

type GetTagsByKeysRow struct {
	ID                 string  `json:"id"`
	TagKey             string  `json:"tag_key"`
	Name               string  `json:"name"`
	DisplayNameHebrew  string  `json:"display_name_hebrew"`
	DisplayNameEnglish string  `json:"display_name_english"`
	TagType            string  `json:"tag_type"`
	Description        *string `json:"description"`
	Color              *string `json:"color"`
	SortOrder          *int32  `json:"sort_order"`
}

// Get multiple tags by their keys
func (q *Queries) GetTagsByKeys(ctx context.Context, dollar_1 []string) ([]GetTagsByKeysRow, error) {
	rows, err := q.db.Query(ctx, getTagsByKeys, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTagsByKeysRow{}
	for rows.Next() {
		var i GetTagsByKeysRow
		if err := rows.Scan(
			&i.ID,
			&i.TagKey,
			&i.Name,
			&i.DisplayNameHebrew,
			&i.DisplayNameEnglish,
			&i.TagType,
			&i.Description,
			&i.Color,
			&i.SortOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagsForHebCalEvent = `-- name: GetTagsForHebCalEvent :many
SELECT DISTINCT
    t.id,
    t.tag_key,
    t.name,
    t.display_name_hebrew,
    t.display_name_english,
    t.tag_type,
    t.description,
    t.sort_order
FROM zman_tags t
JOIN tag_event_mappings m ON m.tag_id = t.id
WHERE m.hebcal_event_pattern IS NOT NULL
  AND (
    $1 LIKE m.hebcal_event_pattern OR
    m.hebcal_event_pattern LIKE $1 OR
    -- Handle wildcards: convert % to pattern matching
    $1 LIKE REPLACE(m.hebcal_event_pattern, '%', '')::text || '%' OR
    $1 LIKE '%' || REPLACE(m.hebcal_event_pattern, '%', '')::text
  )
ORDER BY m.priority DESC, t.sort_order
`

type GetTagsForHebCalEventRow struct {
	ID                 string  `json:"id"`
	TagKey             string  `json:"tag_key"`
	Name               string  `json:"name"`
	DisplayNameHebrew  string  `json:"display_name_hebrew"`
	DisplayNameEnglish string  `json:"display_name_english"`
	TagType            string  `json:"tag_type"`
	Description        *string `json:"description"`
	SortOrder          *int32  `json:"sort_order"`
}

// Get tags that match a specific HebCal event name using pattern matching
// The pattern supports SQL LIKE wildcards (%)
func (q *Queries) GetTagsForHebCalEvent(ctx context.Context, hebcalEventPattern *string) ([]GetTagsForHebCalEventRow, error) {
	rows, err := q.db.Query(ctx, getTagsForHebCalEvent, hebcalEventPattern)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTagsForHebCalEventRow{}
	for rows.Next() {
		var i GetTagsForHebCalEventRow
		if err := rows.Scan(
			&i.ID,
			&i.TagKey,
			&i.Name,
			&i.DisplayNameHebrew,
			&i.DisplayNameEnglish,
			&i.TagType,
			&i.Description,
			&i.SortOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagsForHebrewDate = `-- name: GetTagsForHebrewDate :many
SELECT DISTINCT
    t.id,
    t.tag_key,
    t.name,
    t.display_name_hebrew,
    t.display_name_english,
    t.tag_type,
    t.description,
    t.sort_order
FROM zman_tags t
JOIN tag_event_mappings m ON m.tag_id = t.id
WHERE m.hebrew_month = $1
  AND $2 BETWEEN m.hebrew_day_start AND COALESCE(m.hebrew_day_end, m.hebrew_day_start)
ORDER BY m.priority DESC, t.sort_order
`

type GetTagsForHebrewDateParams struct {
	HebrewMonth    *int32 `json:"hebrew_month"`
	HebrewDayStart *int32 `json:"hebrew_day_start"`
}

type GetTagsForHebrewDateRow struct {
	ID                 string  `json:"id"`
	TagKey             string  `json:"tag_key"`
	Name               string  `json:"name"`
	DisplayNameHebrew  string  `json:"display_name_hebrew"`
	DisplayNameEnglish string  `json:"display_name_english"`
	TagType            string  `json:"tag_type"`
	Description        *string `json:"description"`
	SortOrder          *int32  `json:"sort_order"`
}

// Get tags that match a specific Hebrew date (month and day)
func (q *Queries) GetTagsForHebrewDate(ctx context.Context, arg GetTagsForHebrewDateParams) ([]GetTagsForHebrewDateRow, error) {
	rows, err := q.db.Query(ctx, getTagsForHebrewDate, arg.HebrewMonth, arg.HebrewDayStart)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTagsForHebrewDateRow{}
	for rows.Next() {
		var i GetTagsForHebrewDateRow
		if err := rows.Scan(
			&i.ID,
			&i.TagKey,
			&i.Name,
			&i.DisplayNameHebrew,
			&i.DisplayNameEnglish,
			&i.TagType,
			&i.Description,
			&i.SortOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getZmanimByActiveTags = `-- name: GetZmanimByActiveTags :many

SELECT DISTINCT
    pz.id,
    pz.publisher_id,
    pz.zman_key,
    pz.hebrew_name,
    pz.english_name,
    pz.formula_dsl,
    pz.is_enabled,
    pz.is_published,
    pz.category
FROM publisher_zmanim pz
JOIN publisher_zman_tags pzt ON pzt.publisher_zman_id = pz.id
JOIN zman_tags t ON t.id = pzt.tag_id
WHERE pz.publisher_id = $1
  AND t.tag_key = ANY($2::text[])
  AND pz.deleted_at IS NULL
  AND pz.is_enabled = true
ORDER BY pz.hebrew_name
`

type GetZmanimByActiveTagsParams struct {
	PublisherID string   `json:"publisher_id"`
	Column2     []string `json:"column_2"`
}

type GetZmanimByActiveTagsRow struct {
	ID          string `json:"id"`
	PublisherID string `json:"publisher_id"`
	ZmanKey     string `json:"zman_key"`
	HebrewName  string `json:"hebrew_name"`
	EnglishName string `json:"english_name"`
	FormulaDsl  string `json:"formula_dsl"`
	IsEnabled   bool   `json:"is_enabled"`
	IsPublished bool   `json:"is_published"`
	Category    string `json:"category"`
}

// ============================================================================
// Publisher Zmanim by Active Tags
// ============================================================================
// Get publisher zmanim that have any of the specified tags (for calendar day filtering)
func (q *Queries) GetZmanimByActiveTags(ctx context.Context, arg GetZmanimByActiveTagsParams) ([]GetZmanimByActiveTagsRow, error) {
	rows, err := q.db.Query(ctx, getZmanimByActiveTags, arg.PublisherID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetZmanimByActiveTagsRow{}
	for rows.Next() {
		var i GetZmanimByActiveTagsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublisherID,
			&i.ZmanKey,
			&i.HebrewName,
			&i.EnglishName,
			&i.FormulaDsl,
			&i.IsEnabled,
			&i.IsPublished,
			&i.Category,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
