// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: master_registry.sql

package sqlcgen

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const addMasterZmanFromRequest = `-- name: AddMasterZmanFromRequest :one
INSERT INTO master_zmanim_registry (
    zman_key,
    canonical_hebrew_name,
    canonical_english_name,
    time_category,
    default_formula_dsl,
    is_core,
    sort_order,
    description
)
SELECT
    requested_key,
    requested_hebrew_name,
    requested_english_name,
    time_category,
    requested_formula_dsl,
    false,
    999,
    'Added from publisher request'
FROM zman_registry_requests zrr
WHERE zrr.id = $1
RETURNING id, zman_key, canonical_hebrew_name, canonical_english_name, time_category,
    default_formula_dsl, is_core, sort_order, created_at, updated_at
`

type AddMasterZmanFromRequestRow struct {
	ID                   string    `json:"id"`
	ZmanKey              string    `json:"zman_key"`
	CanonicalHebrewName  string    `json:"canonical_hebrew_name"`
	CanonicalEnglishName string    `json:"canonical_english_name"`
	TimeCategory         string    `json:"time_category"`
	DefaultFormulaDsl    string    `json:"default_formula_dsl"`
	IsCore               *bool     `json:"is_core"`
	SortOrder            *int32    `json:"sort_order"`
	CreatedAt            time.Time `json:"created_at"`
	UpdatedAt            time.Time `json:"updated_at"`
}

func (q *Queries) AddMasterZmanFromRequest(ctx context.Context, id string) (AddMasterZmanFromRequestRow, error) {
	row := q.db.QueryRow(ctx, addMasterZmanFromRequest, id)
	var i AddMasterZmanFromRequestRow
	err := row.Scan(
		&i.ID,
		&i.ZmanKey,
		&i.CanonicalHebrewName,
		&i.CanonicalEnglishName,
		&i.TimeCategory,
		&i.DefaultFormulaDsl,
		&i.IsCore,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPublisherZmanFromRegistry = `-- name: CreatePublisherZmanFromRegistry :one
INSERT INTO publisher_zmanim (
    id, publisher_id, zman_key, hebrew_name, english_name,
    formula_dsl, ai_explanation, publisher_comment,
    is_enabled, is_visible, is_published, is_custom, category,
    dependencies, sort_order, master_zman_id, current_version
)
SELECT
    gen_random_uuid() AS id,
    $1 AS publisher_id,
    mr.zman_key AS zman_key,
    mr.canonical_hebrew_name AS hebrew_name,
    mr.canonical_english_name AS english_name,
    COALESCE($3, mr.default_formula_dsl) AS formula_dsl,
    NULL AS ai_explanation,
    NULL AS publisher_comment,
    true AS is_enabled,
    true AS is_visible,
    false AS is_published,
    false AS is_custom,
    mr.time_category AS category,
    '{}'::text[] AS dependencies,
    mr.sort_order AS sort_order,
    mr.id AS master_zman_id,
    1 AS current_version
FROM master_zmanim_registry mr
WHERE mr.id = $2
RETURNING id, publisher_id, zman_key, hebrew_name, english_name,
    formula_dsl, ai_explanation, publisher_comment,
    is_enabled, is_visible, is_published, is_custom, category,
    dependencies, sort_order, created_at, updated_at, master_zman_id, current_version
`

type CreatePublisherZmanFromRegistryParams struct {
	PublisherID string  `json:"publisher_id"`
	ID          string  `json:"id"`
	FormulaDsl  *string `json:"formula_dsl"`
}

type CreatePublisherZmanFromRegistryRow struct {
	ID               string      `json:"id"`
	PublisherID      string      `json:"publisher_id"`
	ZmanKey          string      `json:"zman_key"`
	HebrewName       string      `json:"hebrew_name"`
	EnglishName      string      `json:"english_name"`
	FormulaDsl       string      `json:"formula_dsl"`
	AiExplanation    *string     `json:"ai_explanation"`
	PublisherComment *string     `json:"publisher_comment"`
	IsEnabled        bool        `json:"is_enabled"`
	IsVisible        bool        `json:"is_visible"`
	IsPublished      bool        `json:"is_published"`
	IsCustom         bool        `json:"is_custom"`
	Category         string      `json:"category"`
	Dependencies     []string    `json:"dependencies"`
	SortOrder        int32       `json:"sort_order"`
	CreatedAt        time.Time   `json:"created_at"`
	UpdatedAt        time.Time   `json:"updated_at"`
	MasterZmanID     pgtype.UUID `json:"master_zman_id"`
	CurrentVersion   *int32      `json:"current_version"`
}

func (q *Queries) CreatePublisherZmanFromRegistry(ctx context.Context, arg CreatePublisherZmanFromRegistryParams) (CreatePublisherZmanFromRegistryRow, error) {
	row := q.db.QueryRow(ctx, createPublisherZmanFromRegistry, arg.PublisherID, arg.ID, arg.FormulaDsl)
	var i CreatePublisherZmanFromRegistryRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.ZmanKey,
		&i.HebrewName,
		&i.EnglishName,
		&i.FormulaDsl,
		&i.AiExplanation,
		&i.PublisherComment,
		&i.IsEnabled,
		&i.IsVisible,
		&i.IsPublished,
		&i.IsCustom,
		&i.Category,
		&i.Dependencies,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MasterZmanID,
		&i.CurrentVersion,
	)
	return i, err
}

const createZmanRegistryRequest = `-- name: CreateZmanRegistryRequest :one

INSERT INTO zman_registry_requests (
    publisher_id,
    requested_key,
    requested_hebrew_name,
    requested_english_name,
    requested_formula_dsl,
    time_category,
    justification
) VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, publisher_id, requested_key, requested_hebrew_name, requested_english_name,
    requested_formula_dsl, time_category, justification, status, created_at
`

type CreateZmanRegistryRequestParams struct {
	PublisherID          string  `json:"publisher_id"`
	RequestedKey         string  `json:"requested_key"`
	RequestedHebrewName  string  `json:"requested_hebrew_name"`
	RequestedEnglishName string  `json:"requested_english_name"`
	RequestedFormulaDsl  *string `json:"requested_formula_dsl"`
	TimeCategory         string  `json:"time_category"`
	Justification        string  `json:"justification"`
}

type CreateZmanRegistryRequestRow struct {
	ID                   string    `json:"id"`
	PublisherID          string    `json:"publisher_id"`
	RequestedKey         string    `json:"requested_key"`
	RequestedHebrewName  string    `json:"requested_hebrew_name"`
	RequestedEnglishName string    `json:"requested_english_name"`
	RequestedFormulaDsl  *string   `json:"requested_formula_dsl"`
	TimeCategory         string    `json:"time_category"`
	Justification        string    `json:"justification"`
	Status               string    `json:"status"`
	CreatedAt            time.Time `json:"created_at"`
}

// ============================================
// ZMAN REGISTRY REQUESTS
// ============================================
func (q *Queries) CreateZmanRegistryRequest(ctx context.Context, arg CreateZmanRegistryRequestParams) (CreateZmanRegistryRequestRow, error) {
	row := q.db.QueryRow(ctx, createZmanRegistryRequest,
		arg.PublisherID,
		arg.RequestedKey,
		arg.RequestedHebrewName,
		arg.RequestedEnglishName,
		arg.RequestedFormulaDsl,
		arg.TimeCategory,
		arg.Justification,
	)
	var i CreateZmanRegistryRequestRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.RequestedKey,
		&i.RequestedHebrewName,
		&i.RequestedEnglishName,
		&i.RequestedFormulaDsl,
		&i.TimeCategory,
		&i.Justification,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const createZmanVersion = `-- name: CreateZmanVersion :one
INSERT INTO publisher_zman_versions (
    publisher_zman_id,
    version_number,
    formula_dsl,
    created_by
)
SELECT
    pz.id,
    COALESCE((SELECT MAX(version_number) FROM publisher_zman_versions WHERE publisher_zman_id = pz.id), 0) + 1,
    $3,
    $4
FROM publisher_zmanim pz
WHERE pz.publisher_id = $1 AND pz.zman_key = $2
RETURNING id, publisher_zman_id, version_number, formula_dsl, created_by, created_at
`

type CreateZmanVersionParams struct {
	PublisherID string  `json:"publisher_id"`
	ZmanKey     string  `json:"zman_key"`
	FormulaDsl  string  `json:"formula_dsl"`
	CreatedBy   *string `json:"created_by"`
}

func (q *Queries) CreateZmanVersion(ctx context.Context, arg CreateZmanVersionParams) (PublisherZmanVersion, error) {
	row := q.db.QueryRow(ctx, createZmanVersion,
		arg.PublisherID,
		arg.ZmanKey,
		arg.FormulaDsl,
		arg.CreatedBy,
	)
	var i PublisherZmanVersion
	err := row.Scan(
		&i.ID,
		&i.PublisherZmanID,
		&i.VersionNumber,
		&i.FormulaDsl,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const getAllAstronomicalPrimitives = `-- name: GetAllAstronomicalPrimitives :many

SELECT
    id, variable_name, display_name, description, formula_dsl,
    category, calculation_type, solar_angle, is_dawn, edge_type,
    sort_order, created_at, updated_at
FROM astronomical_primitives
ORDER BY sort_order, variable_name
`

// ============================================
// ASTRONOMICAL PRIMITIVES QUERIES
// ============================================
func (q *Queries) GetAllAstronomicalPrimitives(ctx context.Context) ([]AstronomicalPrimitive, error) {
	rows, err := q.db.Query(ctx, getAllAstronomicalPrimitives)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AstronomicalPrimitive{}
	for rows.Next() {
		var i AstronomicalPrimitive
		if err := rows.Scan(
			&i.ID,
			&i.VariableName,
			&i.DisplayName,
			&i.Description,
			&i.FormulaDsl,
			&i.Category,
			&i.CalculationType,
			&i.SolarAngle,
			&i.IsDawn,
			&i.EdgeType,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllMasterZmanim = `-- name: GetAllMasterZmanim :many


SELECT
    id, zman_key, canonical_hebrew_name, canonical_english_name,
    transliteration, description, halachic_notes, halachic_source,
    time_category, default_formula_dsl, is_core, sort_order,
    created_at, updated_at
FROM master_zmanim_registry
ORDER BY time_category, sort_order, canonical_hebrew_name
`

type GetAllMasterZmanimRow struct {
	ID                   string    `json:"id"`
	ZmanKey              string    `json:"zman_key"`
	CanonicalHebrewName  string    `json:"canonical_hebrew_name"`
	CanonicalEnglishName string    `json:"canonical_english_name"`
	Transliteration      *string   `json:"transliteration"`
	Description          *string   `json:"description"`
	HalachicNotes        *string   `json:"halachic_notes"`
	HalachicSource       *string   `json:"halachic_source"`
	TimeCategory         string    `json:"time_category"`
	DefaultFormulaDsl    string    `json:"default_formula_dsl"`
	IsCore               *bool     `json:"is_core"`
	SortOrder            *int32    `json:"sort_order"`
	CreatedAt            time.Time `json:"created_at"`
	UpdatedAt            time.Time `json:"updated_at"`
}

// Master Zmanim Registry SQL Queries
// SQLc will generate type-safe Go code from these queries
// ============================================
// MASTER REGISTRY QUERIES
// ============================================
func (q *Queries) GetAllMasterZmanim(ctx context.Context) ([]GetAllMasterZmanimRow, error) {
	rows, err := q.db.Query(ctx, getAllMasterZmanim)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllMasterZmanimRow{}
	for rows.Next() {
		var i GetAllMasterZmanimRow
		if err := rows.Scan(
			&i.ID,
			&i.ZmanKey,
			&i.CanonicalHebrewName,
			&i.CanonicalEnglishName,
			&i.Transliteration,
			&i.Description,
			&i.HalachicNotes,
			&i.HalachicSource,
			&i.TimeCategory,
			&i.DefaultFormulaDsl,
			&i.IsCore,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllTags = `-- name: GetAllTags :many

SELECT
    id, name, display_name_hebrew, display_name_english,
    tag_type, description, color, sort_order, created_at
FROM zman_tags
ORDER BY tag_type, sort_order, name
`

// ============================================
// TAG QUERIES
// ============================================
func (q *Queries) GetAllTags(ctx context.Context) ([]ZmanTag, error) {
	rows, err := q.db.Query(ctx, getAllTags)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ZmanTag{}
	for rows.Next() {
		var i ZmanTag
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.DisplayNameHebrew,
			&i.DisplayNameEnglish,
			&i.TagType,
			&i.Description,
			&i.Color,
			&i.SortOrder,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAstronomicalPrimitiveByName = `-- name: GetAstronomicalPrimitiveByName :one
SELECT
    id, variable_name, display_name, description, formula_dsl,
    category, calculation_type, solar_angle, is_dawn, edge_type,
    sort_order, created_at, updated_at
FROM astronomical_primitives
WHERE variable_name = $1
`

func (q *Queries) GetAstronomicalPrimitiveByName(ctx context.Context, variableName string) (AstronomicalPrimitive, error) {
	row := q.db.QueryRow(ctx, getAstronomicalPrimitiveByName, variableName)
	var i AstronomicalPrimitive
	err := row.Scan(
		&i.ID,
		&i.VariableName,
		&i.DisplayName,
		&i.Description,
		&i.FormulaDsl,
		&i.Category,
		&i.CalculationType,
		&i.SolarAngle,
		&i.IsDawn,
		&i.EdgeType,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAstronomicalPrimitivesByCategory = `-- name: GetAstronomicalPrimitivesByCategory :many
SELECT
    id, variable_name, display_name, description, formula_dsl,
    category, calculation_type, solar_angle, is_dawn, edge_type,
    sort_order, created_at, updated_at
FROM astronomical_primitives
WHERE category = $1
ORDER BY sort_order, variable_name
`

func (q *Queries) GetAstronomicalPrimitivesByCategory(ctx context.Context, category string) ([]AstronomicalPrimitive, error) {
	rows, err := q.db.Query(ctx, getAstronomicalPrimitivesByCategory, category)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AstronomicalPrimitive{}
	for rows.Next() {
		var i AstronomicalPrimitive
		if err := rows.Scan(
			&i.ID,
			&i.VariableName,
			&i.DisplayName,
			&i.Description,
			&i.FormulaDsl,
			&i.Category,
			&i.CalculationType,
			&i.SolarAngle,
			&i.IsDawn,
			&i.EdgeType,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAstronomicalPrimitivesGrouped = `-- name: GetAstronomicalPrimitivesGrouped :many
SELECT
    id, variable_name, display_name, description, formula_dsl,
    category, calculation_type, solar_angle, is_dawn, edge_type,
    sort_order, created_at, updated_at
FROM astronomical_primitives
ORDER BY
    CASE category
        WHEN 'horizon' THEN 1
        WHEN 'civil_twilight' THEN 2
        WHEN 'nautical_twilight' THEN 3
        WHEN 'astronomical_twilight' THEN 4
        WHEN 'solar_position' THEN 5
        ELSE 6
    END,
    sort_order,
    variable_name
`

// Returns primitives with category for grouping in UI
func (q *Queries) GetAstronomicalPrimitivesGrouped(ctx context.Context) ([]AstronomicalPrimitive, error) {
	rows, err := q.db.Query(ctx, getAstronomicalPrimitivesGrouped)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AstronomicalPrimitive{}
	for rows.Next() {
		var i AstronomicalPrimitive
		if err := rows.Scan(
			&i.ID,
			&i.VariableName,
			&i.DisplayName,
			&i.Description,
			&i.FormulaDsl,
			&i.Category,
			&i.CalculationType,
			&i.SolarAngle,
			&i.IsDawn,
			&i.EdgeType,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDeletedPublisherZmanim = `-- name: GetDeletedPublisherZmanim :many
SELECT
    pz.id,
    pz.publisher_id,
    pz.zman_key,
    COALESCE(mr.canonical_hebrew_name, pz.hebrew_name) AS hebrew_name,
    COALESCE(mr.canonical_english_name, pz.english_name) AS english_name,
    pz.formula_dsl,
    pz.deleted_at,
    pz.deleted_by,
    COALESCE(mr.time_category, pz.category) AS time_category,
    pz.master_zman_id
FROM publisher_zmanim pz
LEFT JOIN master_zmanim_registry mr ON pz.master_zman_id = mr.id
WHERE pz.publisher_id = $1
  AND pz.deleted_at IS NOT NULL
ORDER BY pz.deleted_at DESC
`

type GetDeletedPublisherZmanimRow struct {
	ID           string             `json:"id"`
	PublisherID  string             `json:"publisher_id"`
	ZmanKey      string             `json:"zman_key"`
	HebrewName   string             `json:"hebrew_name"`
	EnglishName  string             `json:"english_name"`
	FormulaDsl   string             `json:"formula_dsl"`
	DeletedAt    pgtype.Timestamptz `json:"deleted_at"`
	DeletedBy    *string            `json:"deleted_by"`
	TimeCategory string             `json:"time_category"`
	MasterZmanID pgtype.UUID        `json:"master_zman_id"`
}

func (q *Queries) GetDeletedPublisherZmanim(ctx context.Context, publisherID string) ([]GetDeletedPublisherZmanimRow, error) {
	rows, err := q.db.Query(ctx, getDeletedPublisherZmanim, publisherID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDeletedPublisherZmanimRow{}
	for rows.Next() {
		var i GetDeletedPublisherZmanimRow
		if err := rows.Scan(
			&i.ID,
			&i.PublisherID,
			&i.ZmanKey,
			&i.HebrewName,
			&i.EnglishName,
			&i.FormulaDsl,
			&i.DeletedAt,
			&i.DeletedBy,
			&i.TimeCategory,
			&i.MasterZmanID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMasterZmanByID = `-- name: GetMasterZmanByID :one
SELECT
    id, zman_key, canonical_hebrew_name, canonical_english_name,
    transliteration, description, halachic_notes, halachic_source,
    time_category, default_formula_dsl, is_core, sort_order,
    created_at, updated_at
FROM master_zmanim_registry
WHERE id = $1
`

type GetMasterZmanByIDRow struct {
	ID                   string    `json:"id"`
	ZmanKey              string    `json:"zman_key"`
	CanonicalHebrewName  string    `json:"canonical_hebrew_name"`
	CanonicalEnglishName string    `json:"canonical_english_name"`
	Transliteration      *string   `json:"transliteration"`
	Description          *string   `json:"description"`
	HalachicNotes        *string   `json:"halachic_notes"`
	HalachicSource       *string   `json:"halachic_source"`
	TimeCategory         string    `json:"time_category"`
	DefaultFormulaDsl    string    `json:"default_formula_dsl"`
	IsCore               *bool     `json:"is_core"`
	SortOrder            *int32    `json:"sort_order"`
	CreatedAt            time.Time `json:"created_at"`
	UpdatedAt            time.Time `json:"updated_at"`
}

func (q *Queries) GetMasterZmanByID(ctx context.Context, id string) (GetMasterZmanByIDRow, error) {
	row := q.db.QueryRow(ctx, getMasterZmanByID, id)
	var i GetMasterZmanByIDRow
	err := row.Scan(
		&i.ID,
		&i.ZmanKey,
		&i.CanonicalHebrewName,
		&i.CanonicalEnglishName,
		&i.Transliteration,
		&i.Description,
		&i.HalachicNotes,
		&i.HalachicSource,
		&i.TimeCategory,
		&i.DefaultFormulaDsl,
		&i.IsCore,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMasterZmanByKey = `-- name: GetMasterZmanByKey :one
SELECT
    id, zman_key, canonical_hebrew_name, canonical_english_name,
    transliteration, description, halachic_notes, halachic_source,
    time_category, default_formula_dsl, is_core, sort_order,
    created_at, updated_at
FROM master_zmanim_registry
WHERE zman_key = $1
`

type GetMasterZmanByKeyRow struct {
	ID                   string    `json:"id"`
	ZmanKey              string    `json:"zman_key"`
	CanonicalHebrewName  string    `json:"canonical_hebrew_name"`
	CanonicalEnglishName string    `json:"canonical_english_name"`
	Transliteration      *string   `json:"transliteration"`
	Description          *string   `json:"description"`
	HalachicNotes        *string   `json:"halachic_notes"`
	HalachicSource       *string   `json:"halachic_source"`
	TimeCategory         string    `json:"time_category"`
	DefaultFormulaDsl    string    `json:"default_formula_dsl"`
	IsCore               *bool     `json:"is_core"`
	SortOrder            *int32    `json:"sort_order"`
	CreatedAt            time.Time `json:"created_at"`
	UpdatedAt            time.Time `json:"updated_at"`
}

func (q *Queries) GetMasterZmanByKey(ctx context.Context, zmanKey string) (GetMasterZmanByKeyRow, error) {
	row := q.db.QueryRow(ctx, getMasterZmanByKey, zmanKey)
	var i GetMasterZmanByKeyRow
	err := row.Scan(
		&i.ID,
		&i.ZmanKey,
		&i.CanonicalHebrewName,
		&i.CanonicalEnglishName,
		&i.Transliteration,
		&i.Description,
		&i.HalachicNotes,
		&i.HalachicSource,
		&i.TimeCategory,
		&i.DefaultFormulaDsl,
		&i.IsCore,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMasterZmanimByCategory = `-- name: GetMasterZmanimByCategory :many
SELECT
    id, zman_key, canonical_hebrew_name, canonical_english_name,
    transliteration, description, halachic_notes, halachic_source,
    time_category, default_formula_dsl, is_core, sort_order,
    created_at, updated_at
FROM master_zmanim_registry
WHERE time_category = $1
ORDER BY sort_order, canonical_hebrew_name
`

type GetMasterZmanimByCategoryRow struct {
	ID                   string    `json:"id"`
	ZmanKey              string    `json:"zman_key"`
	CanonicalHebrewName  string    `json:"canonical_hebrew_name"`
	CanonicalEnglishName string    `json:"canonical_english_name"`
	Transliteration      *string   `json:"transliteration"`
	Description          *string   `json:"description"`
	HalachicNotes        *string   `json:"halachic_notes"`
	HalachicSource       *string   `json:"halachic_source"`
	TimeCategory         string    `json:"time_category"`
	DefaultFormulaDsl    string    `json:"default_formula_dsl"`
	IsCore               *bool     `json:"is_core"`
	SortOrder            *int32    `json:"sort_order"`
	CreatedAt            time.Time `json:"created_at"`
	UpdatedAt            time.Time `json:"updated_at"`
}

func (q *Queries) GetMasterZmanimByCategory(ctx context.Context, timeCategory string) ([]GetMasterZmanimByCategoryRow, error) {
	rows, err := q.db.Query(ctx, getMasterZmanimByCategory, timeCategory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMasterZmanimByCategoryRow{}
	for rows.Next() {
		var i GetMasterZmanimByCategoryRow
		if err := rows.Scan(
			&i.ID,
			&i.ZmanKey,
			&i.CanonicalHebrewName,
			&i.CanonicalEnglishName,
			&i.Transliteration,
			&i.Description,
			&i.HalachicNotes,
			&i.HalachicSource,
			&i.TimeCategory,
			&i.DefaultFormulaDsl,
			&i.IsCore,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMasterZmanimByTag = `-- name: GetMasterZmanimByTag :many
SELECT
    mr.id, mr.zman_key, mr.canonical_hebrew_name, mr.canonical_english_name,
    mr.transliteration, mr.description, mr.halachic_notes, mr.halachic_source,
    mr.time_category, mr.default_formula_dsl, mr.is_core, mr.sort_order,
    mr.created_at, mr.updated_at
FROM master_zmanim_registry mr
JOIN master_zman_tags mzt ON mr.id = mzt.master_zman_id
JOIN zman_tags t ON t.id = mzt.tag_id
WHERE t.name = $1
ORDER BY mr.time_category, mr.sort_order
`

type GetMasterZmanimByTagRow struct {
	ID                   string    `json:"id"`
	ZmanKey              string    `json:"zman_key"`
	CanonicalHebrewName  string    `json:"canonical_hebrew_name"`
	CanonicalEnglishName string    `json:"canonical_english_name"`
	Transliteration      *string   `json:"transliteration"`
	Description          *string   `json:"description"`
	HalachicNotes        *string   `json:"halachic_notes"`
	HalachicSource       *string   `json:"halachic_source"`
	TimeCategory         string    `json:"time_category"`
	DefaultFormulaDsl    string    `json:"default_formula_dsl"`
	IsCore               *bool     `json:"is_core"`
	SortOrder            *int32    `json:"sort_order"`
	CreatedAt            time.Time `json:"created_at"`
	UpdatedAt            time.Time `json:"updated_at"`
}

func (q *Queries) GetMasterZmanimByTag(ctx context.Context, name string) ([]GetMasterZmanimByTagRow, error) {
	rows, err := q.db.Query(ctx, getMasterZmanimByTag, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMasterZmanimByTagRow{}
	for rows.Next() {
		var i GetMasterZmanimByTagRow
		if err := rows.Scan(
			&i.ID,
			&i.ZmanKey,
			&i.CanonicalHebrewName,
			&i.CanonicalEnglishName,
			&i.Transliteration,
			&i.Description,
			&i.HalachicNotes,
			&i.HalachicSource,
			&i.TimeCategory,
			&i.DefaultFormulaDsl,
			&i.IsCore,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMasterZmanimGroupedByCategory = `-- name: GetMasterZmanimGroupedByCategory :many
SELECT
    time_category,
    json_agg(
        json_build_object(
            'id', id,
            'zman_key', zman_key,
            'canonical_hebrew_name', canonical_hebrew_name,
            'canonical_english_name', canonical_english_name,
            'transliteration', transliteration,
            'default_formula_dsl', default_formula_dsl,
            'is_core', is_core,
            'sort_order', sort_order
        ) ORDER BY sort_order, canonical_hebrew_name
    ) as zmanim
FROM master_zmanim_registry
GROUP BY time_category
ORDER BY
    CASE time_category
        WHEN 'dawn' THEN 1
        WHEN 'sunrise' THEN 2
        WHEN 'morning' THEN 3
        WHEN 'midday' THEN 4
        WHEN 'afternoon' THEN 5
        WHEN 'sunset' THEN 6
        WHEN 'nightfall' THEN 7
        WHEN 'midnight' THEN 8
    END
`

type GetMasterZmanimGroupedByCategoryRow struct {
	TimeCategory string `json:"time_category"`
	Zmanim       []byte `json:"zmanim"`
}

func (q *Queries) GetMasterZmanimGroupedByCategory(ctx context.Context) ([]GetMasterZmanimGroupedByCategoryRow, error) {
	rows, err := q.db.Query(ctx, getMasterZmanimGroupedByCategory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMasterZmanimGroupedByCategoryRow{}
	for rows.Next() {
		var i GetMasterZmanimGroupedByCategoryRow
		if err := rows.Scan(&i.TimeCategory, &i.Zmanim); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublisherZmanWithRegistry = `-- name: GetPublisherZmanWithRegistry :one
SELECT
    pz.id,
    pz.publisher_id,
    pz.zman_key,
    COALESCE(mr.canonical_hebrew_name, pz.hebrew_name) AS hebrew_name,
    COALESCE(mr.canonical_english_name, pz.english_name) AS english_name,
    mr.transliteration,
    pz.formula_dsl,
    mr.default_formula_dsl,
    pz.ai_explanation,
    pz.publisher_comment,
    pz.is_enabled,
    pz.is_visible,
    pz.is_published,
    COALESCE(pz.is_custom, false) AS is_custom,
    COALESCE(mr.time_category, pz.category) AS time_category,
    pz.category,
    pz.dependencies,
    pz.sort_order,
    pz.current_version,
    pz.created_at,
    pz.updated_at,
    pz.master_zman_id,
    mr.description AS zman_description,
    mr.halachic_notes,
    mr.is_core
FROM publisher_zmanim pz
LEFT JOIN master_zmanim_registry mr ON pz.master_zman_id = mr.id
WHERE pz.publisher_id = $1
  AND pz.zman_key = $2
  AND pz.deleted_at IS NULL
`

type GetPublisherZmanWithRegistryParams struct {
	PublisherID string `json:"publisher_id"`
	ZmanKey     string `json:"zman_key"`
}

type GetPublisherZmanWithRegistryRow struct {
	ID                string      `json:"id"`
	PublisherID       string      `json:"publisher_id"`
	ZmanKey           string      `json:"zman_key"`
	HebrewName        string      `json:"hebrew_name"`
	EnglishName       string      `json:"english_name"`
	Transliteration   *string     `json:"transliteration"`
	FormulaDsl        string      `json:"formula_dsl"`
	DefaultFormulaDsl *string     `json:"default_formula_dsl"`
	AiExplanation     *string     `json:"ai_explanation"`
	PublisherComment  *string     `json:"publisher_comment"`
	IsEnabled         bool        `json:"is_enabled"`
	IsVisible         bool        `json:"is_visible"`
	IsPublished       bool        `json:"is_published"`
	IsCustom          bool        `json:"is_custom"`
	TimeCategory      string      `json:"time_category"`
	Category          string      `json:"category"`
	Dependencies      []string    `json:"dependencies"`
	SortOrder         int32       `json:"sort_order"`
	CurrentVersion    *int32      `json:"current_version"`
	CreatedAt         time.Time   `json:"created_at"`
	UpdatedAt         time.Time   `json:"updated_at"`
	MasterZmanID      pgtype.UUID `json:"master_zman_id"`
	ZmanDescription   *string     `json:"zman_description"`
	HalachicNotes     *string     `json:"halachic_notes"`
	IsCore            *bool       `json:"is_core"`
}

func (q *Queries) GetPublisherZmanWithRegistry(ctx context.Context, arg GetPublisherZmanWithRegistryParams) (GetPublisherZmanWithRegistryRow, error) {
	row := q.db.QueryRow(ctx, getPublisherZmanWithRegistry, arg.PublisherID, arg.ZmanKey)
	var i GetPublisherZmanWithRegistryRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.ZmanKey,
		&i.HebrewName,
		&i.EnglishName,
		&i.Transliteration,
		&i.FormulaDsl,
		&i.DefaultFormulaDsl,
		&i.AiExplanation,
		&i.PublisherComment,
		&i.IsEnabled,
		&i.IsVisible,
		&i.IsPublished,
		&i.IsCustom,
		&i.TimeCategory,
		&i.Category,
		&i.Dependencies,
		&i.SortOrder,
		&i.CurrentVersion,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MasterZmanID,
		&i.ZmanDescription,
		&i.HalachicNotes,
		&i.IsCore,
	)
	return i, err
}

const getPublisherZmanimWithRegistry = `-- name: GetPublisherZmanimWithRegistry :many

SELECT
    pz.id,
    pz.publisher_id,
    pz.zman_key,
    COALESCE(mr.canonical_hebrew_name, pz.hebrew_name) AS hebrew_name,
    COALESCE(mr.canonical_english_name, pz.english_name) AS english_name,
    mr.transliteration,
    pz.formula_dsl,
    mr.default_formula_dsl,
    pz.ai_explanation,
    pz.publisher_comment,
    pz.is_enabled,
    pz.is_visible,
    pz.is_published,
    COALESCE(pz.is_custom, false) AS is_custom,
    COALESCE(mr.time_category, pz.category) AS time_category,
    pz.category,
    pz.dependencies,
    pz.sort_order,
    pz.current_version,
    pz.created_at,
    pz.updated_at,
    pz.master_zman_id,
    mr.description AS zman_description,
    mr.halachic_notes,
    mr.is_core
FROM publisher_zmanim pz
LEFT JOIN master_zmanim_registry mr ON pz.master_zman_id = mr.id
WHERE pz.publisher_id = $1
  AND pz.deleted_at IS NULL
ORDER BY
    CASE COALESCE(mr.time_category, pz.category)
        WHEN 'dawn' THEN 1
        WHEN 'sunrise' THEN 2
        WHEN 'morning' THEN 3
        WHEN 'midday' THEN 4
        WHEN 'afternoon' THEN 5
        WHEN 'sunset' THEN 6
        WHEN 'nightfall' THEN 7
        WHEN 'midnight' THEN 8
        ELSE 9
    END,
    pz.sort_order,
    pz.hebrew_name
`

type GetPublisherZmanimWithRegistryRow struct {
	ID                string      `json:"id"`
	PublisherID       string      `json:"publisher_id"`
	ZmanKey           string      `json:"zman_key"`
	HebrewName        string      `json:"hebrew_name"`
	EnglishName       string      `json:"english_name"`
	Transliteration   *string     `json:"transliteration"`
	FormulaDsl        string      `json:"formula_dsl"`
	DefaultFormulaDsl *string     `json:"default_formula_dsl"`
	AiExplanation     *string     `json:"ai_explanation"`
	PublisherComment  *string     `json:"publisher_comment"`
	IsEnabled         bool        `json:"is_enabled"`
	IsVisible         bool        `json:"is_visible"`
	IsPublished       bool        `json:"is_published"`
	IsCustom          bool        `json:"is_custom"`
	TimeCategory      string      `json:"time_category"`
	Category          string      `json:"category"`
	Dependencies      []string    `json:"dependencies"`
	SortOrder         int32       `json:"sort_order"`
	CurrentVersion    *int32      `json:"current_version"`
	CreatedAt         time.Time   `json:"created_at"`
	UpdatedAt         time.Time   `json:"updated_at"`
	MasterZmanID      pgtype.UUID `json:"master_zman_id"`
	ZmanDescription   *string     `json:"zman_description"`
	HalachicNotes     *string     `json:"halachic_notes"`
	IsCore            *bool       `json:"is_core"`
}

// ============================================
// PUBLISHER ZMANIM WITH REGISTRY (new model)
// ============================================
func (q *Queries) GetPublisherZmanimWithRegistry(ctx context.Context, publisherID string) ([]GetPublisherZmanimWithRegistryRow, error) {
	rows, err := q.db.Query(ctx, getPublisherZmanimWithRegistry, publisherID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPublisherZmanimWithRegistryRow{}
	for rows.Next() {
		var i GetPublisherZmanimWithRegistryRow
		if err := rows.Scan(
			&i.ID,
			&i.PublisherID,
			&i.ZmanKey,
			&i.HebrewName,
			&i.EnglishName,
			&i.Transliteration,
			&i.FormulaDsl,
			&i.DefaultFormulaDsl,
			&i.AiExplanation,
			&i.PublisherComment,
			&i.IsEnabled,
			&i.IsVisible,
			&i.IsPublished,
			&i.IsCustom,
			&i.TimeCategory,
			&i.Category,
			&i.Dependencies,
			&i.SortOrder,
			&i.CurrentVersion,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.MasterZmanID,
			&i.ZmanDescription,
			&i.HalachicNotes,
			&i.IsCore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagByName = `-- name: GetTagByName :one
SELECT
    id, name, display_name_hebrew, display_name_english,
    tag_type, description, color, sort_order, created_at
FROM zman_tags
WHERE name = $1
`

func (q *Queries) GetTagByName(ctx context.Context, name string) (ZmanTag, error) {
	row := q.db.QueryRow(ctx, getTagByName, name)
	var i ZmanTag
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.DisplayNameHebrew,
		&i.DisplayNameEnglish,
		&i.TagType,
		&i.Description,
		&i.Color,
		&i.SortOrder,
		&i.CreatedAt,
	)
	return i, err
}

const getTagsByType = `-- name: GetTagsByType :many
SELECT
    id, name, display_name_hebrew, display_name_english,
    tag_type, description, color, sort_order, created_at
FROM zman_tags
WHERE tag_type = $1
ORDER BY sort_order, name
`

func (q *Queries) GetTagsByType(ctx context.Context, tagType string) ([]ZmanTag, error) {
	rows, err := q.db.Query(ctx, getTagsByType, tagType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ZmanTag{}
	for rows.Next() {
		var i ZmanTag
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.DisplayNameHebrew,
			&i.DisplayNameEnglish,
			&i.TagType,
			&i.Description,
			&i.Color,
			&i.SortOrder,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagsForMasterZman = `-- name: GetTagsForMasterZman :many
SELECT
    t.id, t.name, t.display_name_hebrew, t.display_name_english,
    t.tag_type, t.description, t.color, t.sort_order, t.created_at
FROM zman_tags t
JOIN master_zman_tags mzt ON t.id = mzt.tag_id
WHERE mzt.master_zman_id = $1
ORDER BY t.tag_type, t.sort_order
`

func (q *Queries) GetTagsForMasterZman(ctx context.Context, masterZmanID string) ([]ZmanTag, error) {
	rows, err := q.db.Query(ctx, getTagsForMasterZman, masterZmanID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ZmanTag{}
	for rows.Next() {
		var i ZmanTag
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.DisplayNameHebrew,
			&i.DisplayNameEnglish,
			&i.TagType,
			&i.Description,
			&i.Color,
			&i.SortOrder,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getZmanRegistryRequestByID = `-- name: GetZmanRegistryRequestByID :one
SELECT
    id, publisher_id, requested_key, requested_hebrew_name, requested_english_name,
    requested_formula_dsl, time_category, justification, status,
    reviewed_by, reviewed_at, reviewer_notes, created_at
FROM zman_registry_requests
WHERE id = $1
`

func (q *Queries) GetZmanRegistryRequestByID(ctx context.Context, id string) (ZmanRegistryRequest, error) {
	row := q.db.QueryRow(ctx, getZmanRegistryRequestByID, id)
	var i ZmanRegistryRequest
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.RequestedKey,
		&i.RequestedHebrewName,
		&i.RequestedEnglishName,
		&i.RequestedFormulaDsl,
		&i.TimeCategory,
		&i.Justification,
		&i.Status,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.ReviewerNotes,
		&i.CreatedAt,
	)
	return i, err
}

const getZmanRegistryRequests = `-- name: GetZmanRegistryRequests :many
SELECT
    id, publisher_id, requested_key, requested_hebrew_name, requested_english_name,
    requested_formula_dsl, time_category, justification, status,
    reviewed_by, reviewed_at, reviewer_notes, created_at
FROM zman_registry_requests
WHERE status = COALESCE($1, status)
ORDER BY created_at DESC
`

func (q *Queries) GetZmanRegistryRequests(ctx context.Context, status *string) ([]ZmanRegistryRequest, error) {
	rows, err := q.db.Query(ctx, getZmanRegistryRequests, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ZmanRegistryRequest{}
	for rows.Next() {
		var i ZmanRegistryRequest
		if err := rows.Scan(
			&i.ID,
			&i.PublisherID,
			&i.RequestedKey,
			&i.RequestedHebrewName,
			&i.RequestedEnglishName,
			&i.RequestedFormulaDsl,
			&i.TimeCategory,
			&i.Justification,
			&i.Status,
			&i.ReviewedBy,
			&i.ReviewedAt,
			&i.ReviewerNotes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getZmanVersion = `-- name: GetZmanVersion :one
SELECT
    pzv.id,
    pzv.publisher_zman_id,
    pzv.version_number,
    pzv.formula_dsl,
    pzv.created_by,
    pzv.created_at
FROM publisher_zman_versions pzv
JOIN publisher_zmanim pz ON pz.id = pzv.publisher_zman_id
WHERE pz.publisher_id = $1 AND pz.zman_key = $2 AND pzv.version_number = $3
`

type GetZmanVersionParams struct {
	PublisherID   string `json:"publisher_id"`
	ZmanKey       string `json:"zman_key"`
	VersionNumber int32  `json:"version_number"`
}

func (q *Queries) GetZmanVersion(ctx context.Context, arg GetZmanVersionParams) (PublisherZmanVersion, error) {
	row := q.db.QueryRow(ctx, getZmanVersion, arg.PublisherID, arg.ZmanKey, arg.VersionNumber)
	var i PublisherZmanVersion
	err := row.Scan(
		&i.ID,
		&i.PublisherZmanID,
		&i.VersionNumber,
		&i.FormulaDsl,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const getZmanVersionHistory = `-- name: GetZmanVersionHistory :many

SELECT
    pzv.id,
    pzv.publisher_zman_id,
    pzv.version_number,
    pzv.formula_dsl,
    pzv.created_by,
    pzv.created_at
FROM publisher_zman_versions pzv
JOIN publisher_zmanim pz ON pz.id = pzv.publisher_zman_id
WHERE pz.publisher_id = $1 AND pz.zman_key = $2
ORDER BY pzv.version_number DESC
LIMIT 7
`

type GetZmanVersionHistoryParams struct {
	PublisherID string `json:"publisher_id"`
	ZmanKey     string `json:"zman_key"`
}

// ============================================
// VERSION HISTORY QUERIES
// ============================================
func (q *Queries) GetZmanVersionHistory(ctx context.Context, arg GetZmanVersionHistoryParams) ([]PublisherZmanVersion, error) {
	rows, err := q.db.Query(ctx, getZmanVersionHistory, arg.PublisherID, arg.ZmanKey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PublisherZmanVersion{}
	for rows.Next() {
		var i PublisherZmanVersion
		if err := rows.Scan(
			&i.ID,
			&i.PublisherZmanID,
			&i.VersionNumber,
			&i.FormulaDsl,
			&i.CreatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const importZmanimFromRegistryByKeys = `-- name: ImportZmanimFromRegistryByKeys :many
INSERT INTO publisher_zmanim (
    id, publisher_id, zman_key, hebrew_name, english_name,
    formula_dsl, ai_explanation, publisher_comment,
    is_enabled, is_visible, is_published, is_custom, category,
    dependencies, sort_order, master_zman_id, current_version
)
SELECT
    gen_random_uuid(),
    $1,
    mr.zman_key,
    mr.canonical_hebrew_name,
    mr.canonical_english_name,
    mr.default_formula_dsl,
    NULL,
    NULL,
    true,
    true,
    false,
    false,
    mr.time_category,
    '{}',
    mr.sort_order,
    mr.id,
    1
FROM master_zmanim_registry mr
WHERE mr.zman_key = ANY($2::text[])
ON CONFLICT (publisher_id, zman_key) DO NOTHING
RETURNING id, publisher_id, zman_key, hebrew_name, english_name,
    formula_dsl, ai_explanation, publisher_comment,
    is_enabled, is_visible, is_published, is_custom, category,
    dependencies, sort_order, created_at, updated_at, master_zman_id, current_version
`

type ImportZmanimFromRegistryByKeysParams struct {
	PublisherID string   `json:"publisher_id"`
	Column2     []string `json:"column_2"`
}

type ImportZmanimFromRegistryByKeysRow struct {
	ID               string      `json:"id"`
	PublisherID      string      `json:"publisher_id"`
	ZmanKey          string      `json:"zman_key"`
	HebrewName       string      `json:"hebrew_name"`
	EnglishName      string      `json:"english_name"`
	FormulaDsl       string      `json:"formula_dsl"`
	AiExplanation    *string     `json:"ai_explanation"`
	PublisherComment *string     `json:"publisher_comment"`
	IsEnabled        bool        `json:"is_enabled"`
	IsVisible        bool        `json:"is_visible"`
	IsPublished      bool        `json:"is_published"`
	IsCustom         bool        `json:"is_custom"`
	Category         string      `json:"category"`
	Dependencies     []string    `json:"dependencies"`
	SortOrder        int32       `json:"sort_order"`
	CreatedAt        time.Time   `json:"created_at"`
	UpdatedAt        time.Time   `json:"updated_at"`
	MasterZmanID     pgtype.UUID `json:"master_zman_id"`
	CurrentVersion   *int32      `json:"current_version"`
}

func (q *Queries) ImportZmanimFromRegistryByKeys(ctx context.Context, arg ImportZmanimFromRegistryByKeysParams) ([]ImportZmanimFromRegistryByKeysRow, error) {
	rows, err := q.db.Query(ctx, importZmanimFromRegistryByKeys, arg.PublisherID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ImportZmanimFromRegistryByKeysRow{}
	for rows.Next() {
		var i ImportZmanimFromRegistryByKeysRow
		if err := rows.Scan(
			&i.ID,
			&i.PublisherID,
			&i.ZmanKey,
			&i.HebrewName,
			&i.EnglishName,
			&i.FormulaDsl,
			&i.AiExplanation,
			&i.PublisherComment,
			&i.IsEnabled,
			&i.IsVisible,
			&i.IsPublished,
			&i.IsCustom,
			&i.Category,
			&i.Dependencies,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.MasterZmanID,
			&i.CurrentVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const permanentDeletePublisherZman = `-- name: PermanentDeletePublisherZman :exec
DELETE FROM publisher_zmanim
WHERE publisher_id = $1 AND zman_key = $2 AND deleted_at IS NOT NULL
`

type PermanentDeletePublisherZmanParams struct {
	PublisherID string `json:"publisher_id"`
	ZmanKey     string `json:"zman_key"`
}

func (q *Queries) PermanentDeletePublisherZman(ctx context.Context, arg PermanentDeletePublisherZmanParams) error {
	_, err := q.db.Exec(ctx, permanentDeletePublisherZman, arg.PublisherID, arg.ZmanKey)
	return err
}

const restorePublisherZman = `-- name: RestorePublisherZman :one
UPDATE publisher_zmanim
SET deleted_at = NULL, deleted_by = NULL, updated_at = NOW()
WHERE publisher_id = $1 AND zman_key = $2 AND deleted_at IS NOT NULL
RETURNING id, publisher_id, zman_key, hebrew_name, english_name,
    formula_dsl, ai_explanation, publisher_comment,
    is_enabled, is_visible, is_published, is_custom, category,
    dependencies, sort_order, created_at, updated_at, master_zman_id, current_version
`

type RestorePublisherZmanParams struct {
	PublisherID string `json:"publisher_id"`
	ZmanKey     string `json:"zman_key"`
}

type RestorePublisherZmanRow struct {
	ID               string      `json:"id"`
	PublisherID      string      `json:"publisher_id"`
	ZmanKey          string      `json:"zman_key"`
	HebrewName       string      `json:"hebrew_name"`
	EnglishName      string      `json:"english_name"`
	FormulaDsl       string      `json:"formula_dsl"`
	AiExplanation    *string     `json:"ai_explanation"`
	PublisherComment *string     `json:"publisher_comment"`
	IsEnabled        bool        `json:"is_enabled"`
	IsVisible        bool        `json:"is_visible"`
	IsPublished      bool        `json:"is_published"`
	IsCustom         bool        `json:"is_custom"`
	Category         string      `json:"category"`
	Dependencies     []string    `json:"dependencies"`
	SortOrder        int32       `json:"sort_order"`
	CreatedAt        time.Time   `json:"created_at"`
	UpdatedAt        time.Time   `json:"updated_at"`
	MasterZmanID     pgtype.UUID `json:"master_zman_id"`
	CurrentVersion   *int32      `json:"current_version"`
}

func (q *Queries) RestorePublisherZman(ctx context.Context, arg RestorePublisherZmanParams) (RestorePublisherZmanRow, error) {
	row := q.db.QueryRow(ctx, restorePublisherZman, arg.PublisherID, arg.ZmanKey)
	var i RestorePublisherZmanRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.ZmanKey,
		&i.HebrewName,
		&i.EnglishName,
		&i.FormulaDsl,
		&i.AiExplanation,
		&i.PublisherComment,
		&i.IsEnabled,
		&i.IsVisible,
		&i.IsPublished,
		&i.IsCustom,
		&i.Category,
		&i.Dependencies,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MasterZmanID,
		&i.CurrentVersion,
	)
	return i, err
}

const rollbackZmanToVersion = `-- name: RollbackZmanToVersion :one
UPDATE publisher_zmanim pz
SET
    formula_dsl = pzv.formula_dsl,
    current_version = (SELECT COALESCE(MAX(version_number), 0) + 1 FROM publisher_zman_versions WHERE publisher_zman_id = pz.id),
    updated_at = NOW()
FROM publisher_zman_versions pzv
WHERE pz.publisher_id = $1
  AND pz.zman_key = $2
  AND pzv.publisher_zman_id = pz.id
  AND pzv.version_number = $3
RETURNING pz.id, pz.publisher_id, pz.zman_key, pz.formula_dsl, pz.current_version
`

type RollbackZmanToVersionParams struct {
	PublisherID   string `json:"publisher_id"`
	ZmanKey       string `json:"zman_key"`
	VersionNumber int32  `json:"version_number"`
}

type RollbackZmanToVersionRow struct {
	ID             string `json:"id"`
	PublisherID    string `json:"publisher_id"`
	ZmanKey        string `json:"zman_key"`
	FormulaDsl     string `json:"formula_dsl"`
	CurrentVersion *int32 `json:"current_version"`
}

func (q *Queries) RollbackZmanToVersion(ctx context.Context, arg RollbackZmanToVersionParams) (RollbackZmanToVersionRow, error) {
	row := q.db.QueryRow(ctx, rollbackZmanToVersion, arg.PublisherID, arg.ZmanKey, arg.VersionNumber)
	var i RollbackZmanToVersionRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.ZmanKey,
		&i.FormulaDsl,
		&i.CurrentVersion,
	)
	return i, err
}

const searchMasterZmanim = `-- name: SearchMasterZmanim :many
SELECT
    id, zman_key, canonical_hebrew_name, canonical_english_name,
    transliteration, description, halachic_notes, halachic_source,
    time_category, default_formula_dsl, is_core, sort_order,
    created_at, updated_at
FROM master_zmanim_registry
WHERE
    canonical_hebrew_name ILIKE '%' || $1 || '%'
    OR canonical_english_name ILIKE '%' || $1 || '%'
    OR transliteration ILIKE '%' || $1 || '%'
    OR zman_key ILIKE '%' || $1 || '%'
ORDER BY
    CASE
        WHEN canonical_english_name ILIKE $1 || '%' THEN 1
        WHEN canonical_hebrew_name ILIKE $1 || '%' THEN 2
        ELSE 3
    END,
    sort_order
LIMIT 50
`

type SearchMasterZmanimRow struct {
	ID                   string    `json:"id"`
	ZmanKey              string    `json:"zman_key"`
	CanonicalHebrewName  string    `json:"canonical_hebrew_name"`
	CanonicalEnglishName string    `json:"canonical_english_name"`
	Transliteration      *string   `json:"transliteration"`
	Description          *string   `json:"description"`
	HalachicNotes        *string   `json:"halachic_notes"`
	HalachicSource       *string   `json:"halachic_source"`
	TimeCategory         string    `json:"time_category"`
	DefaultFormulaDsl    string    `json:"default_formula_dsl"`
	IsCore               *bool     `json:"is_core"`
	SortOrder            *int32    `json:"sort_order"`
	CreatedAt            time.Time `json:"created_at"`
	UpdatedAt            time.Time `json:"updated_at"`
}

func (q *Queries) SearchMasterZmanim(ctx context.Context, dollar_1 *string) ([]SearchMasterZmanimRow, error) {
	rows, err := q.db.Query(ctx, searchMasterZmanim, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchMasterZmanimRow{}
	for rows.Next() {
		var i SearchMasterZmanimRow
		if err := rows.Scan(
			&i.ID,
			&i.ZmanKey,
			&i.CanonicalHebrewName,
			&i.CanonicalEnglishName,
			&i.Transliteration,
			&i.Description,
			&i.HalachicNotes,
			&i.HalachicSource,
			&i.TimeCategory,
			&i.DefaultFormulaDsl,
			&i.IsCore,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeletePublisherZman = `-- name: SoftDeletePublisherZman :one

UPDATE publisher_zmanim
SET deleted_at = NOW(), deleted_by = $3, updated_at = NOW()
WHERE publisher_id = $1 AND zman_key = $2 AND deleted_at IS NULL
RETURNING id, publisher_id, zman_key, deleted_at, deleted_by
`

type SoftDeletePublisherZmanParams struct {
	PublisherID string  `json:"publisher_id"`
	ZmanKey     string  `json:"zman_key"`
	DeletedBy   *string `json:"deleted_by"`
}

type SoftDeletePublisherZmanRow struct {
	ID          string             `json:"id"`
	PublisherID string             `json:"publisher_id"`
	ZmanKey     string             `json:"zman_key"`
	DeletedAt   pgtype.Timestamptz `json:"deleted_at"`
	DeletedBy   *string            `json:"deleted_by"`
}

// ============================================
// SOFT DELETE QUERIES
// ============================================
func (q *Queries) SoftDeletePublisherZman(ctx context.Context, arg SoftDeletePublisherZmanParams) (SoftDeletePublisherZmanRow, error) {
	row := q.db.QueryRow(ctx, softDeletePublisherZman, arg.PublisherID, arg.ZmanKey, arg.DeletedBy)
	var i SoftDeletePublisherZmanRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.ZmanKey,
		&i.DeletedAt,
		&i.DeletedBy,
	)
	return i, err
}

const updateZmanCurrentVersion = `-- name: UpdateZmanCurrentVersion :exec
UPDATE publisher_zmanim
SET current_version = $3, updated_at = NOW()
WHERE publisher_id = $1 AND zman_key = $2
`

type UpdateZmanCurrentVersionParams struct {
	PublisherID    string `json:"publisher_id"`
	ZmanKey        string `json:"zman_key"`
	CurrentVersion *int32 `json:"current_version"`
}

func (q *Queries) UpdateZmanCurrentVersion(ctx context.Context, arg UpdateZmanCurrentVersionParams) error {
	_, err := q.db.Exec(ctx, updateZmanCurrentVersion, arg.PublisherID, arg.ZmanKey, arg.CurrentVersion)
	return err
}

const updateZmanRegistryRequestStatus = `-- name: UpdateZmanRegistryRequestStatus :one
UPDATE zman_registry_requests
SET
    status = $2,
    reviewed_by = $3,
    reviewed_at = NOW(),
    reviewer_notes = $4
WHERE id = $1
RETURNING id, publisher_id, requested_key, requested_hebrew_name, requested_english_name,
    requested_formula_dsl, time_category, justification, status,
    reviewed_by, reviewed_at, reviewer_notes, created_at
`

type UpdateZmanRegistryRequestStatusParams struct {
	ID            string  `json:"id"`
	Status        string  `json:"status"`
	ReviewedBy    *string `json:"reviewed_by"`
	ReviewerNotes *string `json:"reviewer_notes"`
}

func (q *Queries) UpdateZmanRegistryRequestStatus(ctx context.Context, arg UpdateZmanRegistryRequestStatusParams) (ZmanRegistryRequest, error) {
	row := q.db.QueryRow(ctx, updateZmanRegistryRequestStatus,
		arg.ID,
		arg.Status,
		arg.ReviewedBy,
		arg.ReviewerNotes,
	)
	var i ZmanRegistryRequest
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.RequestedKey,
		&i.RequestedHebrewName,
		&i.RequestedEnglishName,
		&i.RequestedFormulaDsl,
		&i.TimeCategory,
		&i.Justification,
		&i.Status,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.ReviewerNotes,
		&i.CreatedAt,
	)
	return i, err
}
