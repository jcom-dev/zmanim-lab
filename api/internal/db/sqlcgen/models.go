// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package sqlcgen

import (
	"time"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/pgvector/pgvector-go"
)

// Audit log for all AI-powered formula generation and explanation requests
type AiAuditLog struct {
	ID          string      `json:"id"`
	PublisherID pgtype.UUID `json:"publisher_id"`
	UserID      *string     `json:"user_id"`
	// Type of AI request: generate_formula or explain_formula
	RequestType string  `json:"request_type"`
	InputText   string  `json:"input_text"`
	OutputText  *string `json:"output_text"`
	TokensUsed  *int32  `json:"tokens_used"`
	Model       *string `json:"model"`
	// AI confidence score for generated output (0.0 to 1.0)
	Confidence   pgtype.Numeric `json:"confidence"`
	Success      bool           `json:"success"`
	ErrorMessage *string        `json:"error_message"`
	DurationMs   *int32         `json:"duration_ms"`
	// Whether RAG context was included in the prompt
	RagContextUsed *bool              `json:"rag_context_used"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
}

// Tracks indexing status for each knowledge source
type AiIndexStatus struct {
	ID            int32            `json:"id"`
	Source        string           `json:"source"`
	TotalChunks   int32            `json:"total_chunks"`
	LastIndexedAt pgtype.Timestamp `json:"last_indexed_at"`
	Status        *string          `json:"status"`
	ErrorMessage  *string          `json:"error_message"`
	CreatedAt     pgtype.Timestamp `json:"created_at"`
	UpdatedAt     pgtype.Timestamp `json:"updated_at"`
}

type Algorithm struct {
	ID          string  `json:"id"`
	PublisherID string  `json:"publisher_id"`
	Name        string  `json:"name"`
	Version     string  `json:"version"`
	Description *string `json:"description"`
	// Legacy field, use config instead
	FormulaDefinition []byte             `json:"formula_definition"`
	Configuration     []byte             `json:"configuration"`
	CalculationType   string             `json:"calculation_type"`
	ValidationStatus  *string            `json:"validation_status"`
	ValidationResults []byte             `json:"validation_results"`
	IsActive          *bool              `json:"is_active"`
	PublishedAt       pgtype.Timestamptz `json:"published_at"`
	DeprecatedAt      pgtype.Timestamptz `json:"deprecated_at"`
	Tags              []string           `json:"tags"`
	Metadata          []byte             `json:"metadata"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	// Algorithm lifecycle: draft (editable), published (active for users), deprecated (archived old version)
	Status *string `json:"status"`
	// Algorithm configuration JSON (preferred field name per architecture spec)
	Config []byte `json:"config"`
	// Whether this algorithm is visible and can be copied/forked by other publishers
	IsPublic *bool `json:"is_public"`
	// Reference to the source algorithm if this was forked
	ForkedFrom pgtype.UUID `json:"forked_from"`
	// Attribution text shown for forked algorithms
	AttributionText *string `json:"attribution_text"`
	// Number of times this algorithm has been forked
	ForkCount *int32 `json:"fork_count"`
}

type AuditLog struct {
	ID         string             `json:"id"`
	EntityType string             `json:"entity_type"`
	EntityID   string             `json:"entity_id"`
	Action     string             `json:"action"`
	ActorID    *string            `json:"actor_id"`
	Changes    []byte             `json:"changes"`
	Metadata   []byte             `json:"metadata"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
}

type CalculationCache struct {
	ID              string             `json:"id"`
	AlgorithmID     string             `json:"algorithm_id"`
	LocationID      string             `json:"location_id"`
	CalculationDate pgtype.Date        `json:"calculation_date"`
	ZmanimData      []byte             `json:"zmanim_data"`
	CalculatedAt    pgtype.Timestamptz `json:"calculated_at"`
	ExpiresAt       pgtype.Timestamptz `json:"expires_at"`
	HitCount        *int32             `json:"hit_count"`
}

// Global cities database for location search and selection
type City struct {
	ID          string  `json:"id"`
	Name        string  `json:"name"`
	NameAscii   string  `json:"name_ascii"`
	Country     string  `json:"country"`
	CountryCode string  `json:"country_code"`
	Region      *string `json:"region"`
	// Type of administrative region: state (US), province (CA), county (UK), district (IL), prefecture (JP)
	RegionType *string            `json:"region_type"`
	Latitude   pgtype.Numeric     `json:"latitude"`
	Longitude  pgtype.Numeric     `json:"longitude"`
	Timezone   string             `json:"timezone"`
	Population *int32             `json:"population"`
	Location   interface{}        `json:"location"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	UpdatedAt  pgtype.Timestamptz `json:"updated_at"`
}

type CoverageArea struct {
	ID          string             `json:"id"`
	PublisherID string             `json:"publisher_id"`
	Name        string             `json:"name"`
	Description *string            `json:"description"`
	Boundary    interface{}        `json:"boundary"`
	CenterPoint interface{}        `json:"center_point"`
	Priority    *int32             `json:"priority"`
	CountryCode *string            `json:"country_code"`
	Region      *string            `json:"region"`
	City        *string            `json:"city"`
	IsActive    *bool              `json:"is_active"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

// Types of days for which zmanim can be configured (Shabbos, Yom Tov, Taanis, etc.)
type DayType struct {
	ID                 string  `json:"id"`
	Name               string  `json:"name"`
	DisplayNameHebrew  string  `json:"display_name_hebrew"`
	DisplayNameEnglish string  `json:"display_name_english"`
	Description        *string `json:"description"`
	// Parent type name for hierarchical day types
	ParentType *string   `json:"parent_type"`
	SortOrder  *int32    `json:"sort_order"`
	CreatedAt  time.Time `json:"created_at"`
}

// Vector embeddings for RAG semantic search
type Embedding struct {
	ID string `json:"id"`
	// Source document identifier (dsl-spec, kosher-java, halacha)
	Source string `json:"source"`
	// Type of content (documentation, example, source)
	ContentType string `json:"content_type"`
	ChunkIndex  int32  `json:"chunk_index"`
	Content     string `json:"content"`
	Metadata    []byte `json:"metadata"`
	// OpenAI text-embedding-3-small 1536-dimensional vector
	Embedding *pgvector.Vector `json:"embedding"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
	UpdatedAt pgtype.Timestamp `json:"updated_at"`
}

// Cache for AI-generated formula explanations
type ExplanationCache struct {
	ID string `json:"id"`
	// SHA-256 hash of the formula text
	FormulaHash string             `json:"formula_hash"`
	Language    string             `json:"language"`
	Explanation string             `json:"explanation"`
	Source      *string            `json:"source"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	// TTL is typically 7 days
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
}

type GeographicRegion struct {
	ID          string             `json:"id"`
	Name        string             `json:"name"`
	NameLocal   *string            `json:"name_local"`
	Type        string             `json:"type"`
	ParentID    pgtype.UUID        `json:"parent_id"`
	Location    interface{}        `json:"location"`
	Boundary    interface{}        `json:"boundary"`
	CountryCode *string            `json:"country_code"`
	Timezone    string             `json:"timezone"`
	Elevation   pgtype.Numeric     `json:"elevation"`
	Population  *int32             `json:"population"`
	Metadata    []byte             `json:"metadata"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

// Default day type applicability for master registry zmanim
type MasterZmanDayType struct {
	MasterZmanID string `json:"master_zman_id"`
	DayTypeID    string `json:"day_type_id"`
	// If true, this zman is shown by default on this day type
	IsDefault *bool     `json:"is_default"`
	CreatedAt time.Time `json:"created_at"`
}

// Many-to-many relationship between zmanim and tags
type MasterZmanTag struct {
	MasterZmanID string    `json:"master_zman_id"`
	TagID        string    `json:"tag_id"`
	CreatedAt    time.Time `json:"created_at"`
}

// Canonical list of all zmanim - publishers must select from this registry
type MasterZmanimRegistry struct {
	ID string `json:"id"`
	// Unique identifier for this zman type
	ZmanKey              string  `json:"zman_key"`
	CanonicalHebrewName  string  `json:"canonical_hebrew_name"`
	CanonicalEnglishName string  `json:"canonical_english_name"`
	Transliteration      *string `json:"transliteration"`
	Description          *string `json:"description"`
	// Halachic background and reasoning for this zman
	HalachicNotes  *string `json:"halachic_notes"`
	HalachicSource *string `json:"halachic_source"`
	// Time of day grouping for UI display
	TimeCategory      string `json:"time_category"`
	DefaultFormulaDsl string `json:"default_formula_dsl"`
	// If true, this zman cannot be removed from the registry
	IsFundamental *bool     `json:"is_fundamental"`
	SortOrder     *int32    `json:"sort_order"`
	CreatedAt     time.Time `json:"created_at"`
	UpdatedAt     time.Time `json:"updated_at"`
	// Category for event-specific zmanim. NULL means everyday zman. Values: candles, havdalah, yom_kippur, fast_day, tisha_bav, pesach
	EventCategory *string `json:"event_category"`
}

type PasswordResetToken struct {
	ID        string             `json:"id"`
	Email     string             `json:"email"`
	Token     string             `json:"token"`
	ExpiresAt time.Time          `json:"expires_at"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

type Publisher struct {
	ID           string  `json:"id"`
	Name         string  `json:"name"`
	Organization string  `json:"organization"`
	Slug         string  `json:"slug"`
	Email        string  `json:"email"`
	Description  *string `json:"description"`
	Website      *string `json:"website"`
	LogoUrl      *string `json:"logo_url"`
	ContactInfo  []byte  `json:"contact_info"`
	// Publisher status: pending (newly created), verified (approved by admin), suspended (deactivated), or legacy values (pending_verification, active, retired)
	Status      string             `json:"status"`
	VerifiedAt  pgtype.Timestamptz `json:"verified_at"`
	VerifiedBy  pgtype.UUID        `json:"verified_by"`
	ClerkUserID *string            `json:"clerk_user_id"`
	Metadata    []byte             `json:"metadata"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	Bio         *string            `json:"bio"`
	// Whether the publisher profile and zmanim are publicly visible
	IsPublished bool `json:"is_published"`
}

// Publisher geographic coverage at country, region, or city level
type PublisherCoverage struct {
	ID          string `json:"id"`
	PublisherID string `json:"publisher_id"`
	// Level of coverage: country, region, or city
	CoverageLevel string      `json:"coverage_level"`
	CountryCode   *string     `json:"country_code"`
	Region        *string     `json:"region"`
	CityID        pgtype.UUID `json:"city_id"`
	// Priority for this coverage (1-10, higher = more prominent)
	Priority  *int32             `json:"priority"`
	IsActive  *bool              `json:"is_active"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

type PublisherInvitation struct {
	ID          string             `json:"id"`
	PublisherID pgtype.UUID        `json:"publisher_id"`
	Email       string             `json:"email"`
	Token       string             `json:"token"`
	Status      string             `json:"status"`
	InvitedBy   string             `json:"invited_by"`
	ExpiresAt   time.Time          `json:"expires_at"`
	AcceptedAt  pgtype.Timestamptz `json:"accepted_at"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
}

// Tracks onboarding wizard state for publishers
type PublisherOnboarding struct {
	ID             string  `json:"id"`
	PublisherID    string  `json:"publisher_id"`
	CurrentStep    *int32  `json:"current_step"`
	CompletedSteps []int32 `json:"completed_steps"`
	// JSON data containing template selection, customizations, and coverage
	WizardData    []byte             `json:"wizard_data"`
	StartedAt     pgtype.Timestamptz `json:"started_at"`
	LastUpdatedAt pgtype.Timestamptz `json:"last_updated_at"`
	CompletedAt   pgtype.Timestamptz `json:"completed_at"`
	// True if publisher skipped the wizard
	Skipped *bool `json:"skipped"`
}

type PublisherRequest struct {
	ID              string             `json:"id"`
	Name            string             `json:"name"`
	Organization    string             `json:"organization"`
	Email           string             `json:"email"`
	Website         *string            `json:"website"`
	Description     string             `json:"description"`
	Status          string             `json:"status"`
	RejectionReason *string            `json:"rejection_reason"`
	ReviewedBy      *string            `json:"reviewed_by"`
	ReviewedAt      pgtype.Timestamptz `json:"reviewed_at"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
}

// Publisher overrides for day type visibility
type PublisherZmanDayType struct {
	PublisherZmanID string    `json:"publisher_zman_id"`
	DayTypeID       string    `json:"day_type_id"`
	IsVisible       *bool     `json:"is_visible"`
	CreatedAt       time.Time `json:"created_at"`
	UpdatedAt       time.Time `json:"updated_at"`
}

// Version history for each publisher zman (max 7 versions, formula changes only)
type PublisherZmanVersion struct {
	ID              string    `json:"id"`
	PublisherZmanID string    `json:"publisher_zman_id"`
	VersionNumber   int32     `json:"version_number"`
	FormulaDsl      string    `json:"formula_dsl"`
	CreatedBy       *string   `json:"created_by"`
	CreatedAt       time.Time `json:"created_at"`
}

// Individual zmanim formulas for each publisher using DSL syntax (Epic 4)
type PublisherZmanim struct {
	ID          string `json:"id"`
	PublisherID string `json:"publisher_id"`
	ZmanKey     string `json:"zman_key"`
	HebrewName  string `json:"hebrew_name"`
	EnglishName string `json:"english_name"`
	// DSL formula string. Examples: "shaos(3, gra)" for 3 hours after sunrise, "solar(16.1, before_sunrise)" for dawn
	FormulaDsl       string  `json:"formula_dsl"`
	AiExplanation    *string `json:"ai_explanation"`
	PublisherComment *string `json:"publisher_comment"`
	// Whether this zman is active in the algorithm (for preview/calculation)
	IsEnabled bool `json:"is_enabled"`
	IsVisible bool `json:"is_visible"`
	IsCustom  bool `json:"is_custom"`
	// essential = always enabled, optional = can toggle, custom = user created
	Category string `json:"category"`
	// Auto-extracted @references from formula_dsl
	Dependencies []string  `json:"dependencies"`
	SortOrder    int32     `json:"sort_order"`
	CreatedAt    time.Time `json:"created_at"`
	UpdatedAt    time.Time `json:"updated_at"`
	// Whether this zman is publicly visible to end users
	IsPublished    bool               `json:"is_published"`
	MasterZmanID   pgtype.UUID        `json:"master_zman_id"`
	CurrentVersion *int32             `json:"current_version"`
	DeletedAt      pgtype.Timestamptz `json:"deleted_at"`
	DeletedBy      *string            `json:"deleted_by"`
}

// Convenience view that joins publisher_zmanim with master registry data
type PublisherZmanimWithRegistry struct {
	ID                string             `json:"id"`
	PublisherID       string             `json:"publisher_id"`
	ZmanKey           string             `json:"zman_key"`
	HebrewName        string             `json:"hebrew_name"`
	EnglishName       string             `json:"english_name"`
	Transliteration   *string            `json:"transliteration"`
	FormulaDsl        string             `json:"formula_dsl"`
	DefaultFormulaDsl *string            `json:"default_formula_dsl"`
	AiExplanation     *string            `json:"ai_explanation"`
	PublisherComment  *string            `json:"publisher_comment"`
	IsEnabled         bool               `json:"is_enabled"`
	IsVisible         bool               `json:"is_visible"`
	IsCustom          bool               `json:"is_custom"`
	TimeCategory      string             `json:"time_category"`
	Category          string             `json:"category"`
	Dependencies      []string           `json:"dependencies"`
	SortOrder         int32              `json:"sort_order"`
	CurrentVersion    *int32             `json:"current_version"`
	DeletedAt         pgtype.Timestamptz `json:"deleted_at"`
	DeletedBy         *string            `json:"deleted_by"`
	CreatedAt         time.Time          `json:"created_at"`
	UpdatedAt         time.Time          `json:"updated_at"`
	MasterZmanID      pgtype.UUID        `json:"master_zman_id"`
	ZmanDescription   *string            `json:"zman_description"`
	HalachicNotes     *string            `json:"halachic_notes"`
	HalachicSource    *string            `json:"halachic_source"`
	IsFundamental     *bool              `json:"is_fundamental"`
}

// System-wide configuration settings manageable by admins
type SystemConfig struct {
	Key         string             `json:"key"`
	Value       []byte             `json:"value"`
	Description *string            `json:"description"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	UpdatedBy   *string            `json:"updated_by"`
}

type UserProfile struct {
	ID          string             `json:"id"`
	DisplayName *string            `json:"display_name"`
	AvatarUrl   *string            `json:"avatar_url"`
	Preferences []byte             `json:"preferences"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

type UserSubscription struct {
	ID           string             `json:"id"`
	UserID       string             `json:"user_id"`
	PublisherID  string             `json:"publisher_id"`
	SubscribedAt pgtype.Timestamptz `json:"subscribed_at"`
}

type ZmanDefinition struct {
	ID              string             `json:"id"`
	Key             string             `json:"key"`
	NameHebrew      string             `json:"name_hebrew"`
	NameEnglish     string             `json:"name_english"`
	Transliteration *string            `json:"transliteration"`
	Category        string             `json:"category"`
	SortOrder       *int32             `json:"sort_order"`
	IsStandard      *bool              `json:"is_standard"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	// Markdown-formatted halachic documentation and sources
	HalachicNotes *string `json:"halachic_notes"`
	// Primary halachic source reference
	HalachicSource *string `json:"halachic_source"`
}

// Requests from publishers to add new zmanim to the master registry
type ZmanRegistryRequest struct {
	ID                   string             `json:"id"`
	PublisherID          string             `json:"publisher_id"`
	RequestedKey         string             `json:"requested_key"`
	RequestedHebrewName  string             `json:"requested_hebrew_name"`
	RequestedEnglishName string             `json:"requested_english_name"`
	RequestedFormulaDsl  *string            `json:"requested_formula_dsl"`
	TimeCategory         string             `json:"time_category"`
	Justification        string             `json:"justification"`
	Status               string             `json:"status"`
	ReviewedBy           *string            `json:"reviewed_by"`
	ReviewedAt           pgtype.Timestamptz `json:"reviewed_at"`
	ReviewerNotes        *string            `json:"reviewer_notes"`
	CreatedAt            time.Time          `json:"created_at"`
}

// Tags for categorizing zmanim by shita or calculation method
type ZmanTag struct {
	ID                 string    `json:"id"`
	Name               string    `json:"name"`
	DisplayNameHebrew  string    `json:"display_name_hebrew"`
	DisplayNameEnglish string    `json:"display_name_english"`
	TagType            string    `json:"tag_type"`
	Description        *string   `json:"description"`
	Color              *string   `json:"color"`
	SortOrder          *int32    `json:"sort_order"`
	CreatedAt          time.Time `json:"created_at"`
}

// System-wide default zmanim formulas that publishers can copy from
type ZmanimTemplate struct {
	ID          string `json:"id"`
	ZmanKey     string `json:"zman_key"`
	HebrewName  string `json:"hebrew_name"`
	EnglishName string `json:"english_name"`
	// DSL formula string. shaos(N, gra) returns absolute time N hours after sunrise. shaos(N, mga) returns N hours after dawn (72min before sunrise).
	FormulaDsl  string    `json:"formula_dsl"`
	Category    string    `json:"category"`
	Description *string   `json:"description"`
	IsRequired  bool      `json:"is_required"`
	SortOrder   int32     `json:"sort_order"`
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`
}
