// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package sqlcgen

import (
	"time"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/pgvector/pgvector-go"
)

type AiAuditLog struct {
	ID             string         `json:"id"`
	PublisherID    pgtype.UUID    `json:"publisher_id"`
	UserID         *string        `json:"user_id"`
	RequestType    string         `json:"request_type"`
	InputText      *string        `json:"input_text"`
	OutputText     *string        `json:"output_text"`
	TokensUsed     *int32         `json:"tokens_used"`
	Model          *string        `json:"model"`
	Confidence     pgtype.Numeric `json:"confidence"`
	Success        *bool          `json:"success"`
	ErrorMessage   *string        `json:"error_message"`
	DurationMs     *int32         `json:"duration_ms"`
	RagContextUsed *bool          `json:"rag_context_used"`
	CreatedAt      time.Time      `json:"created_at"`
}

type AiIndexStatus struct {
	ID            string             `json:"id"`
	Source        string             `json:"source"`
	TotalChunks   int32              `json:"total_chunks"`
	LastIndexedAt pgtype.Timestamptz `json:"last_indexed_at"`
	Status        string             `json:"status"`
	ErrorMessage  *string            `json:"error_message"`
	CreatedAt     time.Time          `json:"created_at"`
	UpdatedAt     time.Time          `json:"updated_at"`
}

type Algorithm struct {
	ID              string             `json:"id"`
	PublisherID     string             `json:"publisher_id"`
	Name            string             `json:"name"`
	Description     *string            `json:"description"`
	Configuration   []byte             `json:"configuration"`
	Status          *string            `json:"status"`
	IsPublic        *bool              `json:"is_public"`
	ForkedFrom      pgtype.UUID        `json:"forked_from"`
	AttributionText *string            `json:"attribution_text"`
	ForkCount       *int32             `json:"fork_count"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
}

type AlgorithmTemplate struct {
	ID            string    `json:"id"`
	TemplateKey   string    `json:"template_key"`
	Name          string    `json:"name"`
	Description   *string   `json:"description"`
	Configuration []byte    `json:"configuration"`
	SortOrder     int32     `json:"sort_order"`
	IsActive      bool      `json:"is_active"`
	CreatedAt     time.Time `json:"created_at"`
	UpdatedAt     time.Time `json:"updated_at"`
}

type AstronomicalPrimitive struct {
	ID              string             `json:"id"`
	VariableName    string             `json:"variable_name"`
	DisplayName     string             `json:"display_name"`
	Description     *string            `json:"description"`
	FormulaDsl      string             `json:"formula_dsl"`
	Category        string             `json:"category"`
	CalculationType string             `json:"calculation_type"`
	SolarAngle      pgtype.Numeric     `json:"solar_angle"`
	IsDawn          *bool              `json:"is_dawn"`
	EdgeType        *string            `json:"edge_type"`
	SortOrder       *int32             `json:"sort_order"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
}

// DEPRECATED: Use jewish_events instead
type DayType struct {
	ID                 string    `json:"id"`
	Name               string    `json:"name"`
	DisplayNameHebrew  string    `json:"display_name_hebrew"`
	DisplayNameEnglish string    `json:"display_name_english"`
	Description        *string   `json:"description"`
	ParentType         *string   `json:"parent_type"`
	SortOrder          *int32    `json:"sort_order"`
	CreatedAt          time.Time `json:"created_at"`
}

type DisplayGroup struct {
	ID                 string             `json:"id"`
	Key                string             `json:"key"`
	DisplayNameHebrew  string             `json:"display_name_hebrew"`
	DisplayNameEnglish string             `json:"display_name_english"`
	Description        *string            `json:"description"`
	IconName           *string            `json:"icon_name"`
	Color              *string            `json:"color"`
	SortOrder          int32              `json:"sort_order"`
	TimeCategories     []string           `json:"time_categories"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
}

type Embedding struct {
	ID          string             `json:"id"`
	Source      string             `json:"source"`
	ContentType string             `json:"content_type"`
	ChunkIndex  int32              `json:"chunk_index"`
	Content     string             `json:"content"`
	Metadata    []byte             `json:"metadata"`
	Embedding   *pgvector.Vector   `json:"embedding"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

type EventCategory struct {
	ID                 string             `json:"id"`
	Key                string             `json:"key"`
	DisplayNameHebrew  string             `json:"display_name_hebrew"`
	DisplayNameEnglish string             `json:"display_name_english"`
	Description        *string            `json:"description"`
	IconName           *string            `json:"icon_name"`
	Color              *string            `json:"color"`
	SortOrder          int32              `json:"sort_order"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
}

type ExplanationCache struct {
	ID          string    `json:"id"`
	FormulaHash string    `json:"formula_hash"`
	Language    string    `json:"language"`
	Explanation string    `json:"explanation"`
	Source      string    `json:"source"`
	CreatedAt   time.Time `json:"created_at"`
	ExpiresAt   time.Time `json:"expires_at"`
}

type GeoBoundaryImport struct {
	ID               int32              `json:"id"`
	Source           string             `json:"source"`
	Level            string             `json:"level"`
	CountryCode      *string            `json:"country_code"`
	Version          *string            `json:"version"`
	RecordsImported  *int32             `json:"records_imported"`
	RecordsMatched   *int32             `json:"records_matched"`
	RecordsUnmatched *int32             `json:"records_unmatched"`
	ImportedAt       pgtype.Timestamptz `json:"imported_at"`
	Notes            *string            `json:"notes"`
}

// Level 4: Cities with coordinates for zmanim calculations
type GeoCity struct {
	ID          string             `json:"id"`
	RegionID    *int32             `json:"region_id"`
	DistrictID  *int32             `json:"district_id"`
	Name        string             `json:"name"`
	NameAscii   *string            `json:"name_ascii"`
	Latitude    float64            `json:"latitude"`
	Longitude   float64            `json:"longitude"`
	Location    interface{}        `json:"location"`
	Timezone    string             `json:"timezone"`
	ElevationM  *int32             `json:"elevation_m"`
	Population  *int32             `json:"population"`
	Geonameid   *int32             `json:"geonameid"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	WofID       *int64             `json:"wof_id"`
	ContinentID *int16             `json:"continent_id"`
	CountryID   *int32             `json:"country_id"`
}

// City/locality boundaries from WOF
type GeoCityBoundary struct {
	CityID             string             `json:"city_id"`
	Boundary           interface{}        `json:"boundary"`
	BoundarySimplified interface{}        `json:"boundary_simplified"`
	AreaKm2            *float64           `json:"area_km2"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
}

// Level 0: 7 continents with ISO codes
type GeoContinent struct {
	ID    int16  `json:"id"`
	Code  string `json:"code"`
	Name  string `json:"name"`
	WofID *int64 `json:"wof_id"`
}

// Level 1 (ADM0): Countries with ISO 3166-1 codes
type GeoCountry struct {
	ID          int16              `json:"id"`
	Code        string             `json:"code"`
	CodeIso3    *string            `json:"code_iso3"`
	Name        string             `json:"name"`
	ContinentID int16              `json:"continent_id"`
	Adm1Label   *string            `json:"adm1_label"`
	Adm2Label   *string            `json:"adm2_label"`
	HasAdm1     *bool              `json:"has_adm1"`
	HasAdm2     *bool              `json:"has_adm2"`
	IsCityState *bool              `json:"is_city_state"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	WofID       *int64             `json:"wof_id"`
}

type GeoCountryBoundary struct {
	CountryID          int16              `json:"country_id"`
	Boundary           interface{}        `json:"boundary"`
	BoundarySimplified interface{}        `json:"boundary_simplified"`
	AreaKm2            *float64           `json:"area_km2"`
	Centroid           interface{}        `json:"centroid"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
}

// Level 3 (ADM2): Counties, boroughs, districts
type GeoDistrict struct {
	ID          int32              `json:"id"`
	RegionID    *int32             `json:"region_id"`
	Code        string             `json:"code"`
	Name        string             `json:"name"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	WofID       *int64             `json:"wof_id"`
	ContinentID int16              `json:"continent_id"`
	CountryID   *int16             `json:"country_id"`
}

type GeoDistrictBoundary struct {
	DistrictID         int32              `json:"district_id"`
	Boundary           interface{}        `json:"boundary"`
	BoundarySimplified interface{}        `json:"boundary_simplified"`
	AreaKm2            *float64           `json:"area_km2"`
	Centroid           interface{}        `json:"centroid"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
}

// Multi-language names for geographic entities
type GeoName struct {
	ID int64 `json:"id"`
	// continent, country, region, district, city
	EntityType string `json:"entity_type"`
	// ID of the entity (text to support both integer and uuid)
	EntityID     string `json:"entity_id"`
	LanguageCode string `json:"language_code"`
	Name         string `json:"name"`
	// True if this is the preferred name for this language
	IsPreferred *bool              `json:"is_preferred"`
	Source      *string            `json:"source"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
}

type GeoNameMapping struct {
	ID                int32              `json:"id"`
	Level             string             `json:"level"`
	Source            string             `json:"source"`
	SourceName        string             `json:"source_name"`
	SourceCountryCode *string            `json:"source_country_code"`
	TargetID          int32              `json:"target_id"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	Notes             *string            `json:"notes"`
}

// Level 2 (ADM1): States, provinces, regions
type GeoRegion struct {
	ID          int32              `json:"id"`
	CountryID   *int16             `json:"country_id"`
	Code        string             `json:"code"`
	Name        string             `json:"name"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	WofID       *int64             `json:"wof_id"`
	ContinentID int16              `json:"continent_id"`
}

type GeoRegionBoundary struct {
	RegionID           int32              `json:"region_id"`
	Boundary           interface{}        `json:"boundary"`
	BoundarySimplified interface{}        `json:"boundary_simplified"`
	AreaKm2            *float64           `json:"area_km2"`
	Centroid           interface{}        `json:"centroid"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
}

type JewishEvent struct {
	ID                   string    `json:"id"`
	Code                 string    `json:"code"`
	NameHebrew           string    `json:"name_hebrew"`
	NameEnglish          string    `json:"name_english"`
	EventType            string    `json:"event_type"`
	DurationDaysIsrael   *int32    `json:"duration_days_israel"`
	DurationDaysDiaspora *int32    `json:"duration_days_diaspora"`
	FastStartType        *string   `json:"fast_start_type"`
	ParentEventCode      *string   `json:"parent_event_code"`
	SortOrder            *int32    `json:"sort_order"`
	CreatedAt            time.Time `json:"created_at"`
}

// ISO 639-3 language codes for multi-language name support
type Language struct {
	Code       string  `json:"code"`
	Name       string  `json:"name"`
	NativeName *string `json:"native_name"`
	Script     *string `json:"script"`
	Direction  *string `json:"direction"`
	IsActive   *bool   `json:"is_active"`
}

type MasterZmanDayType struct {
	MasterZmanID string    `json:"master_zman_id"`
	DayTypeID    string    `json:"day_type_id"`
	CreatedAt    time.Time `json:"created_at"`
}

type MasterZmanEvent struct {
	ID                  string    `json:"id"`
	MasterZmanID        string    `json:"master_zman_id"`
	JewishEventID       string    `json:"jewish_event_id"`
	IsPrimary           *bool     `json:"is_primary"`
	OverrideHebrewName  *string   `json:"override_hebrew_name"`
	OverrideEnglishName *string   `json:"override_english_name"`
	CreatedAt           time.Time `json:"created_at"`
}

type MasterZmanTag struct {
	MasterZmanID string    `json:"master_zman_id"`
	TagID        string    `json:"tag_id"`
	IsNegated    bool      `json:"is_negated"`
	CreatedAt    time.Time `json:"created_at"`
}

type MasterZmanimRegistry struct {
	ID                   string             `json:"id"`
	ZmanKey              string             `json:"zman_key"`
	CanonicalHebrewName  string             `json:"canonical_hebrew_name"`
	CanonicalEnglishName string             `json:"canonical_english_name"`
	Transliteration      *string            `json:"transliteration"`
	Description          *string            `json:"description"`
	HalachicSource       *string            `json:"halachic_source"`
	HalachicNotes        *string            `json:"halachic_notes"`
	TimeCategory         *string            `json:"time_category"`
	DefaultFormulaDsl    *string            `json:"default_formula_dsl"`
	IsHidden             bool               `json:"is_hidden"`
	IsCore               *bool              `json:"is_core"`
	Aliases              []string           `json:"aliases"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
}

type PasswordResetToken struct {
	ID        string             `json:"id"`
	Email     string             `json:"email"`
	Token     string             `json:"token"`
	ExpiresAt time.Time          `json:"expires_at"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

// Publishers who provide zmanim calculations
type Publisher struct {
	ID                string             `json:"id"`
	Name              string             `json:"name"`
	Email             string             `json:"email"`
	Phone             *string            `json:"phone"`
	Website           *string            `json:"website"`
	Description       *string            `json:"description"`
	LogoUrl           *string            `json:"logo_url"`
	Location          interface{}        `json:"location"`
	Latitude          *float64           `json:"latitude"`
	Longitude         *float64           `json:"longitude"`
	Timezone          *string            `json:"timezone"`
	Status            string             `json:"status"`
	VerificationToken *string            `json:"verification_token"`
	VerifiedAt        pgtype.Timestamptz `json:"verified_at"`
	ClerkUserID       *string            `json:"clerk_user_id"`
	IsPublished       bool               `json:"is_published"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	Bio               *string            `json:"bio"`
	Slug              *string            `json:"slug"`
	IsVerified        bool               `json:"is_verified"`
	LogoData          *string            `json:"logo_data"`
	IsCertified       bool               `json:"is_certified"`
	SuspensionReason  *string            `json:"suspension_reason"`
	DeletedAt         pgtype.Timestamptz `json:"deleted_at"`
	DeletedBy         *string            `json:"deleted_by"`
}

type PublisherCoverage struct {
	ID            string             `json:"id"`
	PublisherID   string             `json:"publisher_id"`
	CoverageLevel string             `json:"coverage_level"`
	CityID        pgtype.UUID        `json:"city_id"`
	DistrictID    *int32             `json:"district_id"`
	RegionID      *int32             `json:"region_id"`
	CountryID     *int16             `json:"country_id"`
	ContinentCode *string            `json:"continent_code"`
	IsActive      bool               `json:"is_active"`
	Priority      *int32             `json:"priority"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
}

type PublisherInvitation struct {
	ID          string             `json:"id"`
	PublisherID string             `json:"publisher_id"`
	Email       string             `json:"email"`
	Role        string             `json:"role"`
	Token       string             `json:"token"`
	ExpiresAt   time.Time          `json:"expires_at"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
}

type PublisherOnboarding struct {
	ID                string             `json:"id"`
	PublisherID       string             `json:"publisher_id"`
	ProfileComplete   *bool              `json:"profile_complete"`
	AlgorithmSelected *bool              `json:"algorithm_selected"`
	ZmanimConfigured  *bool              `json:"zmanim_configured"`
	CoverageSet       *bool              `json:"coverage_set"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
}

type PublisherRequest struct {
	ID           string             `json:"id"`
	Email        string             `json:"email"`
	Name         string             `json:"name"`
	Organization *string            `json:"organization"`
	Message      *string            `json:"message"`
	Status       string             `json:"status"`
	ReviewedBy   *string            `json:"reviewed_by"`
	ReviewedAt   pgtype.Timestamptz `json:"reviewed_at"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
}

type PublisherSnapshot struct {
	ID           string    `json:"id"`
	PublisherID  string    `json:"publisher_id"`
	Description  *string   `json:"description"`
	SnapshotData []byte    `json:"snapshot_data"`
	CreatedBy    *string   `json:"created_by"`
	CreatedAt    time.Time `json:"created_at"`
}

type PublisherZmanAlias struct {
	ID                   string    `json:"id"`
	PublisherZmanID      string    `json:"publisher_zman_id"`
	PublisherID          string    `json:"publisher_id"`
	AliasHebrew          string    `json:"alias_hebrew"`
	AliasEnglish         *string   `json:"alias_english"`
	AliasTransliteration *string   `json:"alias_transliteration"`
	Context              *string   `json:"context"`
	IsPrimary            bool      `json:"is_primary"`
	SortOrder            *int32    `json:"sort_order"`
	CreatedAt            time.Time `json:"created_at"`
}

type PublisherZmanDayType struct {
	PublisherZmanID     string    `json:"publisher_zman_id"`
	DayTypeID           string    `json:"day_type_id"`
	OverrideFormulaDsl  *string   `json:"override_formula_dsl"`
	OverrideHebrewName  *string   `json:"override_hebrew_name"`
	OverrideEnglishName *string   `json:"override_english_name"`
	CreatedAt           time.Time `json:"created_at"`
	UpdatedAt           time.Time `json:"updated_at"`
}

type PublisherZmanEvent struct {
	ID                  string    `json:"id"`
	PublisherZmanID     string    `json:"publisher_zman_id"`
	JewishEventID       string    `json:"jewish_event_id"`
	OverrideFormulaDsl  *string   `json:"override_formula_dsl"`
	OverrideHebrewName  *string   `json:"override_hebrew_name"`
	OverrideEnglishName *string   `json:"override_english_name"`
	IsEnabled           bool      `json:"is_enabled"`
	CreatedAt           time.Time `json:"created_at"`
	UpdatedAt           time.Time `json:"updated_at"`
}

type PublisherZmanTag struct {
	PublisherZmanID string    `json:"publisher_zman_id"`
	TagID           string    `json:"tag_id"`
	IsNegated       bool      `json:"is_negated"`
	CreatedAt       time.Time `json:"created_at"`
}

type PublisherZmanVersion struct {
	ID              string    `json:"id"`
	PublisherZmanID string    `json:"publisher_zman_id"`
	VersionNumber   int32     `json:"version_number"`
	HebrewName      string    `json:"hebrew_name"`
	EnglishName     *string   `json:"english_name"`
	FormulaDsl      *string   `json:"formula_dsl"`
	HalachicNotes   *string   `json:"halachic_notes"`
	CreatedBy       *string   `json:"created_by"`
	ChangeReason    *string   `json:"change_reason"`
	CreatedAt       time.Time `json:"created_at"`
}

type PublisherZmanim struct {
	ID                    string             `json:"id"`
	PublisherID           string             `json:"publisher_id"`
	ZmanKey               string             `json:"zman_key"`
	HebrewName            string             `json:"hebrew_name"`
	EnglishName           string             `json:"english_name"`
	Transliteration       *string            `json:"transliteration"`
	Description           *string            `json:"description"`
	FormulaDsl            string             `json:"formula_dsl"`
	AiExplanation         *string            `json:"ai_explanation"`
	PublisherComment      *string            `json:"publisher_comment"`
	MasterZmanID          pgtype.UUID        `json:"master_zman_id"`
	HalachicNotes         *string            `json:"halachic_notes"`
	IsEnabled             bool               `json:"is_enabled"`
	IsVisible             bool               `json:"is_visible"`
	IsPublished           bool               `json:"is_published"`
	IsBeta                bool               `json:"is_beta"`
	IsCustom              bool               `json:"is_custom"`
	Category              string             `json:"category"`
	Aliases               []string           `json:"aliases"`
	Dependencies          []string           `json:"dependencies"`
	LinkedPublisherZmanID pgtype.UUID        `json:"linked_publisher_zman_id"`
	CurrentVersion        *int32             `json:"current_version"`
	CreatedAt             pgtype.Timestamptz `json:"created_at"`
	UpdatedAt             pgtype.Timestamptz `json:"updated_at"`
	DeletedAt             pgtype.Timestamptz `json:"deleted_at"`
	DeletedBy             *string            `json:"deleted_by"`
	CertifiedAt           pgtype.Timestamptz `json:"certified_at"`
	SourceType            string             `json:"source_type"`
	DisplayNameHebrew     *string            `json:"display_name_hebrew"`
	DisplayNameEnglish    *string            `json:"display_name_english"`
}

type SystemConfig struct {
	ID          string             `json:"id"`
	Key         string             `json:"key"`
	Value       []byte             `json:"value"`
	Description *string            `json:"description"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

type TagEventMapping struct {
	ID                 string    `json:"id"`
	TagID              string    `json:"tag_id"`
	HebcalEventPattern *string   `json:"hebcal_event_pattern"`
	HebrewMonth        *int32    `json:"hebrew_month"`
	HebrewDayStart     *int32    `json:"hebrew_day_start"`
	HebrewDayEnd       *int32    `json:"hebrew_day_end"`
	Priority           *int32    `json:"priority"`
	CreatedAt          time.Time `json:"created_at"`
}

type TagType struct {
	ID                 string             `json:"id"`
	Key                string             `json:"key"`
	DisplayNameHebrew  string             `json:"display_name_hebrew"`
	DisplayNameEnglish string             `json:"display_name_english"`
	Color              *string            `json:"color"`
	SortOrder          int32              `json:"sort_order"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
}

type TimeCategory struct {
	ID                 string             `json:"id"`
	Key                string             `json:"key"`
	DisplayNameHebrew  string             `json:"display_name_hebrew"`
	DisplayNameEnglish string             `json:"display_name_english"`
	Description        *string            `json:"description"`
	IconName           *string            `json:"icon_name"`
	Color              *string            `json:"color"`
	SortOrder          int32              `json:"sort_order"`
	IsEveryday         *bool              `json:"is_everyday"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
}

type ZmanDisplayContext struct {
	ID                 string    `json:"id"`
	MasterZmanID       string    `json:"master_zman_id"`
	ContextCode        string    `json:"context_code"`
	DisplayNameHebrew  string    `json:"display_name_hebrew"`
	DisplayNameEnglish string    `json:"display_name_english"`
	SortOrder          *int32    `json:"sort_order"`
	CreatedAt          time.Time `json:"created_at"`
}

type ZmanRegistryRequest struct {
	ID                   string             `json:"id"`
	PublisherID          string             `json:"publisher_id"`
	RequestedKey         string             `json:"requested_key"`
	RequestedHebrewName  string             `json:"requested_hebrew_name"`
	RequestedEnglishName string             `json:"requested_english_name"`
	RequestedFormulaDsl  *string            `json:"requested_formula_dsl"`
	TimeCategory         string             `json:"time_category"`
	Status               string             `json:"status"`
	ReviewedBy           *string            `json:"reviewed_by"`
	ReviewedAt           pgtype.Timestamptz `json:"reviewed_at"`
	ReviewerNotes        *string            `json:"reviewer_notes"`
	CreatedAt            time.Time          `json:"created_at"`
	Transliteration      *string            `json:"transliteration"`
	Description          *string            `json:"description"`
	HalachicNotes        *string            `json:"halachic_notes"`
	HalachicSource       *string            `json:"halachic_source"`
	PublisherEmail       *string            `json:"publisher_email"`
	PublisherName        *string            `json:"publisher_name"`
	AutoAddOnApproval    *bool              `json:"auto_add_on_approval"`
}

type ZmanRequestTag struct {
	ID               string      `json:"id"`
	RequestID        string      `json:"request_id"`
	TagID            pgtype.UUID `json:"tag_id"`
	RequestedTagName *string     `json:"requested_tag_name"`
	RequestedTagType *string     `json:"requested_tag_type"`
	IsNewTagRequest  bool        `json:"is_new_tag_request"`
	CreatedAt        time.Time   `json:"created_at"`
}

type ZmanTag struct {
	ID                 string    `json:"id"`
	TagKey             string    `json:"tag_key"`
	Name               string    `json:"name"`
	DisplayNameHebrew  string    `json:"display_name_hebrew"`
	DisplayNameEnglish string    `json:"display_name_english"`
	TagType            string    `json:"tag_type"`
	Description        *string   `json:"description"`
	Color              *string   `json:"color"`
	SortOrder          *int32    `json:"sort_order"`
	CreatedAt          time.Time `json:"created_at"`
}

type ZmanimTemplate struct {
	ID          string    `json:"id"`
	ZmanKey     string    `json:"zman_key"`
	HebrewName  string    `json:"hebrew_name"`
	EnglishName string    `json:"english_name"`
	FormulaDsl  string    `json:"formula_dsl"`
	Category    string    `json:"category"`
	Description *string   `json:"description"`
	IsRequired  bool      `json:"is_required"`
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`
}
