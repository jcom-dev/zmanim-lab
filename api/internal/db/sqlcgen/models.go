// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package sqlcgen

import (
	"github.com/jackc/pgx/v5/pgtype"
)

// Audit log for all AI-powered formula generation and explanation requests
type AiAuditLog struct {
	ID          string      `json:"id"`
	PublisherID pgtype.UUID `json:"publisher_id"`
	UserID      *string     `json:"user_id"`
	// Type of AI request: generate_formula or explain_formula
	RequestType string  `json:"request_type"`
	InputText   string  `json:"input_text"`
	OutputText  *string `json:"output_text"`
	TokensUsed  *int32  `json:"tokens_used"`
	Model       *string `json:"model"`
	// AI confidence score for generated output (0.0 to 1.0)
	Confidence   pgtype.Numeric `json:"confidence"`
	Success      bool           `json:"success"`
	ErrorMessage *string        `json:"error_message"`
	DurationMs   *int32         `json:"duration_ms"`
	// Whether RAG context was included in the prompt
	RagContextUsed *bool              `json:"rag_context_used"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
}

// Tracks indexing status for each knowledge source. After migrations, run: cd api && go run cmd/indexer/main.go
type AiIndexStatus struct {
	ID            int32            `json:"id"`
	Source        string           `json:"source"`
	TotalChunks   int32            `json:"total_chunks"`
	LastIndexedAt pgtype.Timestamp `json:"last_indexed_at"`
	Status        *string          `json:"status"`
	ErrorMessage  *string          `json:"error_message"`
	CreatedAt     pgtype.Timestamp `json:"created_at"`
	UpdatedAt     pgtype.Timestamp `json:"updated_at"`
}

// Algorithm configurations for publishers
type Algorithm struct {
	ID            string  `json:"id"`
	PublisherID   string  `json:"publisher_id"`
	Name          string  `json:"name"`
	Description   *string `json:"description"`
	Configuration []byte  `json:"configuration"`
	Status        *string `json:"status"`
	// Whether this algorithm is visible and can be copied/forked by other publishers
	IsPublic *bool `json:"is_public"`
	// Reference to the source algorithm if this was forked
	ForkedFrom pgtype.UUID `json:"forked_from"`
	// Attribution text shown for forked algorithms
	AttributionText *string `json:"attribution_text"`
	// Number of times this algorithm has been forked
	ForkCount *int32             `json:"fork_count"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

// Canonical registry of astronomical times that can be referenced in DSL formulas. These are pure astronomical calculations with no halachic interpretation.
type AstronomicalPrimitive struct {
	ID string `json:"id"`
	// The unique identifier used in DSL formulas (e.g., sunrise, nautical_dawn). Must be snake_case.
	VariableName string  `json:"variable_name"`
	DisplayName  string  `json:"display_name"`
	Description  *string `json:"description"`
	// The DSL formula that calculates this time. Base primitives use their own name, derived use solar() function.
	FormulaDsl string `json:"formula_dsl"`
	Category   string `json:"category"`
	// How to compute: horizon (0째 crossing), solar_angle (degrees below horizon), transit (noon/midnight)
	CalculationType string `json:"calculation_type"`
	// Degrees below horizon for solar_angle calculations (6째 civil, 12째 nautical, 18째 astronomical)
	SolarAngle pgtype.Numeric `json:"solar_angle"`
	// True for morning events (dawn/sunrise), false for evening events (dusk/sunset), NULL for position events (noon/midnight)
	IsDawn *bool `json:"is_dawn"`
	// Which part of the sun: center (geometric), top_edge (visible sunrise/sunset), bottom_edge
	EdgeType  *string            `json:"edge_type"`
	SortOrder *int32             `json:"sort_order"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

// Cities table - use idx_cities_name_trgm for ILIKE searches, idx_cities_country_population for country listings
type City struct {
	ID              string             `json:"id"`
	Name            string             `json:"name"`
	HebrewName      *string            `json:"hebrew_name"`
	Latitude        float64            `json:"latitude"`
	Longitude       float64            `json:"longitude"`
	Timezone        string             `json:"timezone"`
	ElevationMeters *int32             `json:"elevation_meters"`
	Population      *int32             `json:"population"`
	Location        interface{}        `json:"location"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	// Elevation in meters above sea level, used for zmanim calculations
	Elevation *int32 `json:"elevation"`
	// GeoNames ID for data source reference and deduplication
	Geonameid *int32  `json:"geonameid"`
	NameAscii *string `json:"name_ascii"`
	// FK to geo_countries - normalized replacement for country/country_code
	CountryID int16 `json:"country_id"`
	// FK to geo_regions - normalized replacement for region/region_code
	RegionID *int32 `json:"region_id"`
}

type Country struct {
	ID        string             `json:"id"`
	Code      string             `json:"code"`
	Name      string             `json:"name"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

// DEPRECATED: Use jewish_events instead. Types of days for which zmanim can be configured.
type DayType struct {
	ID                 string  `json:"id"`
	Name               string  `json:"name"`
	DisplayNameHebrew  string  `json:"display_name_hebrew"`
	DisplayNameEnglish string  `json:"display_name_english"`
	Description        *string `json:"description"`
	// Parent type name for hierarchical day types
	ParentType *string            `json:"parent_type"`
	SortOrder  *int32             `json:"sort_order"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
}

// Vector embeddings for RAG semantic search
type Embedding struct {
	ID string `json:"id"`
	// Source document identifier (dsl-spec, kosher-java, halacha)
	Source string `json:"source"`
	// Type of content (documentation, example, source)
	ContentType string `json:"content_type"`
	ChunkIndex  int32  `json:"chunk_index"`
	Content     string `json:"content"`
	Metadata    []byte `json:"metadata"`
	// OpenAI text-embedding-3-small 1536-dimensional vector
	Embedding interface{}      `json:"embedding"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
	UpdatedAt pgtype.Timestamp `json:"updated_at"`
}

// Cache for AI-generated formula explanations
type ExplanationCache struct {
	ID string `json:"id"`
	// SHA-256 hash of the formula text
	FormulaHash string             `json:"formula_hash"`
	Language    string             `json:"language"`
	Explanation string             `json:"explanation"`
	Source      *string            `json:"source"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	// TTL is typically 7 days
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
}

// Lookup table for 7 continents with ISO codes
type GeoContinent struct {
	ID   int16  `json:"id"`
	Code string `json:"code"`
	Name string `json:"name"`
}

// Lookup table for countries with ISO 3166-1 alpha-2 codes
type GeoCountry struct {
	ID int16 `json:"id"`
	// ISO 3166-1 alpha-2 country code (e.g., US, IL, GB)
	Code        string `json:"code"`
	Name        string `json:"name"`
	ContinentID int16  `json:"continent_id"`
}

// Lookup table for administrative regions (states, provinces, districts)
type GeoRegion struct {
	ID        int32 `json:"id"`
	CountryID int16 `json:"country_id"`
	// GeoNames admin1 code within the country
	Code string `json:"code"`
	// Human-readable region name (e.g., California, Ontario)
	Name string `json:"name"`
}

// Canonical list of Jewish events (Shabbos, Yom Tov, fasts, etc.) with Israel/Diaspora duration differences
type JewishEvent struct {
	ID          string `json:"id"`
	Code        string `json:"code"`
	NameHebrew  string `json:"name_hebrew"`
	NameEnglish string `json:"name_english"`
	// Type of event: weekly (Shabbos), yom_tov, fast, or informational (no linked zmanim)
	EventType string `json:"event_type"`
	// Number of days this event lasts in Israel
	DurationDaysIsrael *int32 `json:"duration_days_israel"`
	// Number of days this event lasts in the Diaspora
	DurationDaysDiaspora *int32 `json:"duration_days_diaspora"`
	// For fasts: dawn (regular fasts) or sunset (Yom Kippur, Tisha B'Av)
	FastStartType   *string            `json:"fast_start_type"`
	ParentEventCode *string            `json:"parent_event_code"`
	SortOrder       *int32             `json:"sort_order"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
}

// DEPRECATED: Use master_zman_events instead.
type MasterZmanDayType struct {
	MasterZmanID string             `json:"master_zman_id"`
	DayTypeID    string             `json:"day_type_id"`
	IsDefault    *bool              `json:"is_default"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
}

// Links zmanim to the Jewish events they apply to
type MasterZmanEvent struct {
	ID            string `json:"id"`
	MasterZmanID  string `json:"master_zman_id"`
	JewishEventID string `json:"jewish_event_id"`
	IsDefault     *bool  `json:"is_default"`
	// NULL = all days of event, 1 = day 1 only, 2 = day 2 only (for 2-day Yom Tov in Diaspora)
	AppliesToDay *int32             `json:"applies_to_day"`
	Notes        *string            `json:"notes"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
}

// Many-to-many relationship between zmanim and tags
type MasterZmanTag struct {
	MasterZmanID string             `json:"master_zman_id"`
	TagID        string             `json:"tag_id"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
}

// Master zmanim registry - trigram indexes available for fuzzy Hebrew/English/transliteration searches
type MasterZmanimRegistry struct {
	ID string `json:"id"`
	// Unique identifier for this zman type
	ZmanKey              string  `json:"zman_key"`
	CanonicalHebrewName  string  `json:"canonical_hebrew_name"`
	CanonicalEnglishName string  `json:"canonical_english_name"`
	Transliteration      *string `json:"transliteration"`
	Description          *string `json:"description"`
	// Halachic background and reasoning for this zman
	HalachicNotes  *string `json:"halachic_notes"`
	HalachicSource *string `json:"halachic_source"`
	// Time of day grouping for UI display
	TimeCategory      string `json:"time_category"`
	DefaultFormulaDsl string `json:"default_formula_dsl"`
	// If true, this zman is a core/essential zman that cannot be removed from the registry
	IsCore *bool `json:"is_core"`
	// When true, this zman is hidden from public registry queries but visible to admins. Useful for deprecated or experimental zmanim.
	IsHidden bool `json:"is_hidden"`
	// Clerk user ID of the admin who created this zman
	CreatedBy *string `json:"created_by"`
	// Clerk user ID of the admin who last updated this zman
	UpdatedBy *string            `json:"updated_by"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

// Master zmanim registry with their associated tags
type MasterZmanimWithTag struct {
	ID                   string             `json:"id"`
	ZmanKey              string             `json:"zman_key"`
	CanonicalHebrewName  string             `json:"canonical_hebrew_name"`
	CanonicalEnglishName string             `json:"canonical_english_name"`
	Transliteration      *string            `json:"transliteration"`
	Description          *string            `json:"description"`
	HalachicNotes        *string            `json:"halachic_notes"`
	HalachicSource       *string            `json:"halachic_source"`
	TimeCategory         string             `json:"time_category"`
	DefaultFormulaDsl    string             `json:"default_formula_dsl"`
	IsCore               *bool              `json:"is_core"`
	IsHidden             bool               `json:"is_hidden"`
	CreatedBy            *string            `json:"created_by"`
	UpdatedBy            *string            `json:"updated_by"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
	Tags                 interface{}        `json:"tags"`
}

type PasswordResetToken struct {
	ID        string             `json:"id"`
	Email     string             `json:"email"`
	Token     string             `json:"token"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

// Publishers who provide zmanim calculations. Publisher name IS the organization name.
type Publisher struct {
	ID                string             `json:"id"`
	Name              string             `json:"name"`
	Email             string             `json:"email"`
	Phone             *string            `json:"phone"`
	Website           *string            `json:"website"`
	Description       *string            `json:"description"`
	LogoUrl           *string            `json:"logo_url"`
	Location          interface{}        `json:"location"`
	Latitude          *float64           `json:"latitude"`
	Longitude         *float64           `json:"longitude"`
	Timezone          *string            `json:"timezone"`
	Status            string             `json:"status"`
	VerificationToken *string            `json:"verification_token"`
	VerifiedAt        pgtype.Timestamptz `json:"verified_at"`
	ClerkUserID       *string            `json:"clerk_user_id"`
	// Whether the publisher profile and zmanim are publicly visible
	IsPublished bool               `json:"is_published"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	// Short biography or about text for the publisher
	Bio *string `json:"bio"`
	// URL-friendly unique identifier for the publisher
	Slug *string `json:"slug"`
	// Verified publishers can have their zmanim linked to by other publishers
	IsVerified bool `json:"is_verified"`
	// Base64 encoded logo image (PNG format, data:image/png;base64,...)
	LogoData *string `json:"logo_data"`
}

// Publisher geographic coverage at country, region, or city level
type PublisherCoverage struct {
	ID          string `json:"id"`
	PublisherID string `json:"publisher_id"`
	// Level of coverage: country, region, or city
	CoverageLevel string      `json:"coverage_level"`
	CountryCode   *string     `json:"country_code"`
	Region        *string     `json:"region"`
	CityID        pgtype.UUID `json:"city_id"`
	// Priority for this coverage (1-10, higher = more prominent)
	Priority      *int32             `json:"priority"`
	IsActive      *bool              `json:"is_active"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
	ContinentCode *string            `json:"continent_code"`
}

// DEPRECATED: This table is no longer used. User management now creates users directly via Clerk instead of using invitations. Table kept for historical reference but will be empty.
type PublisherInvitation struct {
	ID          string             `json:"id"`
	PublisherID pgtype.UUID        `json:"publisher_id"`
	Email       string             `json:"email"`
	Token       string             `json:"token"`
	Status      string             `json:"status"`
	InvitedBy   string             `json:"invited_by"`
	ExpiresAt   pgtype.Timestamptz `json:"expires_at"`
	AcceptedAt  pgtype.Timestamptz `json:"accepted_at"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
}

// Tracks onboarding wizard state for publishers
type PublisherOnboarding struct {
	ID             string  `json:"id"`
	PublisherID    string  `json:"publisher_id"`
	CurrentStep    *int32  `json:"current_step"`
	CompletedSteps []int32 `json:"completed_steps"`
	// JSON data containing template selection, customizations, and coverage
	WizardData    []byte             `json:"wizard_data"`
	StartedAt     pgtype.Timestamptz `json:"started_at"`
	LastUpdatedAt pgtype.Timestamptz `json:"last_updated_at"`
	CompletedAt   pgtype.Timestamptz `json:"completed_at"`
	// True if publisher skipped the wizard
	Skipped *bool `json:"skipped"`
}

// Requests from users to become publishers. Publisher name IS the organization name.
type PublisherRequest struct {
	ID              string             `json:"id"`
	Name            string             `json:"name"`
	Email           string             `json:"email"`
	Website         *string            `json:"website"`
	Description     string             `json:"description"`
	Status          string             `json:"status"`
	RejectionReason *string            `json:"rejection_reason"`
	ReviewedBy      *string            `json:"reviewed_by"`
	ReviewedAt      pgtype.Timestamptz `json:"reviewed_at"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
}

// Custom display names for zmanim per publisher. Original master registry names remain accessible via master_zmanim_registry.
type PublisherZmanAlias struct {
	ID              string `json:"id"`
	PublisherID     string `json:"publisher_id"`
	PublisherZmanID string `json:"publisher_zman_id"`
	// Publisher-specific Hebrew display name
	CustomHebrewName string `json:"custom_hebrew_name"`
	// Publisher-specific English display name
	CustomEnglishName string `json:"custom_english_name"`
	// Optional publisher-specific transliteration
	CustomTransliteration *string `json:"custom_transliteration"`
	// Whether this alias is currently in use
	IsActive  bool               `json:"is_active"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

// DEPRECATED: Use publisher_zman_events instead.
type PublisherZmanDayType struct {
	PublisherZmanID string             `json:"publisher_zman_id"`
	DayTypeID       string             `json:"day_type_id"`
	IsVisible       *bool              `json:"is_visible"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
}

// Publisher overrides for which events their zmanim apply to
type PublisherZmanEvent struct {
	ID              string             `json:"id"`
	PublisherZmanID string             `json:"publisher_zman_id"`
	JewishEventID   string             `json:"jewish_event_id"`
	IsEnabled       *bool              `json:"is_enabled"`
	AppliesToDay    *int32             `json:"applies_to_day"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
}

// Publisher-specific tags for zmanim. These override/supplement the master registry tags.
type PublisherZmanTag struct {
	PublisherZmanID string             `json:"publisher_zman_id"`
	TagID           string             `json:"tag_id"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
}

// Version history for each publisher zman (max 7 versions, formula changes only)
type PublisherZmanVersion struct {
	ID              string             `json:"id"`
	PublisherZmanID string             `json:"publisher_zman_id"`
	VersionNumber   int32              `json:"version_number"`
	FormulaDsl      string             `json:"formula_dsl"`
	CreatedBy       *string            `json:"created_by"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
}

// Publisher zmanim - filtered queries should use publisher_id + deleted_at + is_enabled for best performance
type PublisherZmanim struct {
	ID          string `json:"id"`
	PublisherID string `json:"publisher_id"`
	ZmanKey     string `json:"zman_key"`
	HebrewName  string `json:"hebrew_name"`
	EnglishName string `json:"english_name"`
	// DSL formula string. Examples: "proportional_hours(3, gra)" for 3 hours after sunrise, "solar(16.1, before_sunrise)" for dawn
	FormulaDsl    string  `json:"formula_dsl"`
	AiExplanation *string `json:"ai_explanation"`
	// Publisher's personal notes, minhag, or halachic source
	PublisherComment *string `json:"publisher_comment"`
	// Whether this zman is active in the algorithm (for preview/calculation)
	IsEnabled bool `json:"is_enabled"`
	IsVisible bool `json:"is_visible"`
	// Whether this zman is publicly visible to end users
	IsPublished bool `json:"is_published"`
	IsCustom    bool `json:"is_custom"`
	// essential = always enabled, optional = can toggle, custom = user created
	Category string `json:"category"`
	// Auto-extracted @references from formula_dsl
	Dependencies   []string           `json:"dependencies"`
	MasterZmanID   pgtype.UUID        `json:"master_zman_id"`
	CurrentVersion *int32             `json:"current_version"`
	DeletedAt      pgtype.Timestamptz `json:"deleted_at"`
	DeletedBy      *string            `json:"deleted_by"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	// For linked zmanim, points to the source zman from another publisher
	LinkedPublisherZmanID pgtype.UUID `json:"linked_publisher_zman_id"`
	// How this zman was created: registry, copied, linked, or custom
	SourceType *string `json:"source_type"`
	// When true, this zman is in beta mode and displayed with a warning to users. Publishers use beta mode to gather feedback before certifying a zman as stable.
	IsBeta bool `json:"is_beta"`
	// Timestamp when is_beta was changed from true to false, indicating publisher certification
	CertifiedAt pgtype.Timestamptz `json:"certified_at"`
	// Publisher's custom transliteration (can differ from registry)
	Transliteration *string `json:"transliteration"`
	// Publisher's description of what this zman represents (can differ from registry)
	Description *string `json:"description"`
}

// Resolves linked zmanim to their source formulas at query time
type PublisherZmanimResolved struct {
	ID                        string             `json:"id"`
	PublisherID               string             `json:"publisher_id"`
	ZmanKey                   string             `json:"zman_key"`
	HebrewName                string             `json:"hebrew_name"`
	EnglishName               string             `json:"english_name"`
	FormulaDsl                string             `json:"formula_dsl"`
	OwnFormulaDsl             string             `json:"own_formula_dsl"`
	AiExplanation             *string            `json:"ai_explanation"`
	PublisherComment          *string            `json:"publisher_comment"`
	IsEnabled                 bool               `json:"is_enabled"`
	IsVisible                 bool               `json:"is_visible"`
	IsPublished               bool               `json:"is_published"`
	IsCustom                  bool               `json:"is_custom"`
	Category                  string             `json:"category"`
	Dependencies              []string           `json:"dependencies"`
	MasterZmanID              pgtype.UUID        `json:"master_zman_id"`
	LinkedPublisherZmanID     pgtype.UUID        `json:"linked_publisher_zman_id"`
	SourceType                *string            `json:"source_type"`
	CurrentVersion            *int32             `json:"current_version"`
	DeletedAt                 pgtype.Timestamptz `json:"deleted_at"`
	DeletedBy                 *string            `json:"deleted_by"`
	CreatedAt                 pgtype.Timestamptz `json:"created_at"`
	UpdatedAt                 pgtype.Timestamptz `json:"updated_at"`
	LinkedSourcePublisherID   pgtype.UUID        `json:"linked_source_publisher_id"`
	LinkedSourcePublisherName *string            `json:"linked_source_publisher_name"`
	LinkedSourceDeletedAt     pgtype.Timestamptz `json:"linked_source_deleted_at"`
	IsLinked                  bool               `json:"is_linked"`
	LinkedSourceIsDeleted     bool               `json:"linked_source_is_deleted"`
}

// Convenience view that joins publisher_zmanim with master registry data
type PublisherZmanimWithRegistry struct {
	ID                string             `json:"id"`
	PublisherID       string             `json:"publisher_id"`
	ZmanKey           string             `json:"zman_key"`
	HebrewName        string             `json:"hebrew_name"`
	EnglishName       string             `json:"english_name"`
	Transliteration   *string            `json:"transliteration"`
	FormulaDsl        string             `json:"formula_dsl"`
	DefaultFormulaDsl *string            `json:"default_formula_dsl"`
	AiExplanation     *string            `json:"ai_explanation"`
	PublisherComment  *string            `json:"publisher_comment"`
	IsEnabled         bool               `json:"is_enabled"`
	IsVisible         bool               `json:"is_visible"`
	IsCustom          bool               `json:"is_custom"`
	TimeCategory      string             `json:"time_category"`
	Category          string             `json:"category"`
	Dependencies      []string           `json:"dependencies"`
	CurrentVersion    *int32             `json:"current_version"`
	DeletedAt         pgtype.Timestamptz `json:"deleted_at"`
	DeletedBy         *string            `json:"deleted_by"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	MasterZmanID      pgtype.UUID        `json:"master_zman_id"`
	ZmanDescription   *string            `json:"zman_description"`
	HalachicNotes     *string            `json:"halachic_notes"`
	HalachicSource    *string            `json:"halachic_source"`
	IsCore            *bool              `json:"is_core"`
}

type SystemConfig struct {
	ID          string             `json:"id"`
	Key         string             `json:"key"`
	Value       []byte             `json:"value"`
	Description *string            `json:"description"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

// Context-specific display names for zmanim with the same calculation but different labels
type ZmanDisplayContext struct {
	ID           string `json:"id"`
	MasterZmanID string `json:"master_zman_id"`
	// Context identifier - matches jewish_events.code or special values
	ContextCode        string             `json:"context_code"`
	DisplayNameHebrew  string             `json:"display_name_hebrew"`
	DisplayNameEnglish string             `json:"display_name_english"`
	SortOrder          *int32             `json:"sort_order"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
}

// Requests from publishers to add new zmanim to the master registry
type ZmanRegistryRequest struct {
	ID                   string             `json:"id"`
	PublisherID          string             `json:"publisher_id"`
	RequestedKey         string             `json:"requested_key"`
	RequestedHebrewName  string             `json:"requested_hebrew_name"`
	RequestedEnglishName string             `json:"requested_english_name"`
	RequestedFormulaDsl  *string            `json:"requested_formula_dsl"`
	TimeCategory         string             `json:"time_category"`
	Status               string             `json:"status"`
	ReviewedBy           *string            `json:"reviewed_by"`
	ReviewedAt           pgtype.Timestamptz `json:"reviewed_at"`
	ReviewerNotes        *string            `json:"reviewer_notes"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	// Transliteration of the Hebrew name
	Transliteration *string `json:"transliteration"`
	// Brief description of the zman
	Description *string `json:"description"`
	// Halachic context or notes
	HalachicNotes *string `json:"halachic_notes"`
	// Source references (seforim, poskim)
	HalachicSource *string `json:"halachic_source"`
	// Contact email for the requesting publisher
	PublisherEmail *string `json:"publisher_email"`
	// Display name of the requesting publisher
	PublisherName *string `json:"publisher_name"`
	// If true, automatically add this zman to publisher's list when approved
	AutoAddOnApproval *bool `json:"auto_add_on_approval"`
}

// Tags associated with zman registry requests. Supports both existing tag references and new tag requests.
type ZmanRequestTag struct {
	ID        string `json:"id"`
	RequestID string `json:"request_id"`
	// Reference to existing tag (if using existing tag)
	TagID pgtype.UUID `json:"tag_id"`
	// Name of requested new tag (if requesting new tag)
	RequestedTagName *string `json:"requested_tag_name"`
	// Type of requested new tag: event, timing, behavior, shita, method
	RequestedTagType *string `json:"requested_tag_type"`
	// True if this is a request for a new tag to be created
	IsNewTagRequest bool               `json:"is_new_tag_request"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
}

// Tags for categorizing zmanim by event type, timing, and behavior
type ZmanTag struct {
	ID string `json:"id"`
	// Unique key identifier for the tag (e.g., shabbos, yom_tov)
	TagKey             string             `json:"tag_key"`
	Name               string             `json:"name"`
	DisplayNameHebrew  string             `json:"display_name_hebrew"`
	DisplayNameEnglish string             `json:"display_name_english"`
	TagType            string             `json:"tag_type"`
	Description        *string            `json:"description"`
	Color              *string            `json:"color"`
	SortOrder          *int32             `json:"sort_order"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
}

// System-wide default zmanim formulas that publishers can copy from
type ZmanimTemplate struct {
	ID          string `json:"id"`
	ZmanKey     string `json:"zman_key"`
	HebrewName  string `json:"hebrew_name"`
	EnglishName string `json:"english_name"`
	// DSL formula string. proportional_hours(N, gra) returns absolute time N hours after sunrise. proportional_hours(N, mga) returns N hours after dawn (72min before sunrise).
	FormulaDsl  string             `json:"formula_dsl"`
	Category    string             `json:"category"`
	Description *string            `json:"description"`
	IsRequired  bool               `json:"is_required"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}
