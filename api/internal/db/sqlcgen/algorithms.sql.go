// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: algorithms.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const archiveActiveAlgorithms = `-- name: ArchiveActiveAlgorithms :exec

UPDATE algorithms
SET status = 'deprecated', updated_at = NOW()
WHERE publisher_id = $1 AND status = 'published'
`

// Publish algorithm --
func (q *Queries) ArchiveActiveAlgorithms(ctx context.Context, publisherID string) error {
	_, err := q.db.Exec(ctx, archiveActiveAlgorithms, publisherID)
	return err
}

const completeOnboarding = `-- name: CompleteOnboarding :one
UPDATE publisher_onboarding
SET completed_at = NOW(),
    last_updated_at = NOW()
WHERE publisher_id = $1
RETURNING id
`

func (q *Queries) CompleteOnboarding(ctx context.Context, publisherID string) (string, error) {
	row := q.db.QueryRow(ctx, completeOnboarding, publisherID)
	var id string
	err := row.Scan(&id)
	return id, err
}

const createAlgorithm = `-- name: CreateAlgorithm :one

INSERT INTO algorithms (
    publisher_id, name, description, configuration, status, is_public
)
VALUES ($1, $2, $3, $4, 'draft', false)
RETURNING id, created_at, updated_at
`

type CreateAlgorithmParams struct {
	PublisherID   string  `json:"publisher_id"`
	Name          string  `json:"name"`
	Description   *string `json:"description"`
	Configuration []byte  `json:"configuration"`
}

type CreateAlgorithmRow struct {
	ID        string             `json:"id"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

// Create or update algorithm --
func (q *Queries) CreateAlgorithm(ctx context.Context, arg CreateAlgorithmParams) (CreateAlgorithmRow, error) {
	row := q.db.QueryRow(ctx, createAlgorithm,
		arg.PublisherID,
		arg.Name,
		arg.Description,
		arg.Configuration,
	)
	var i CreateAlgorithmRow
	err := row.Scan(&i.ID, &i.CreatedAt, &i.UpdatedAt)
	return i, err
}

const createOnboardingState = `-- name: CreateOnboardingState :one
INSERT INTO publisher_onboarding (publisher_id)
VALUES ($1)
RETURNING id, publisher_id, current_step, completed_steps, wizard_data,
    started_at, last_updated_at, completed_at, skipped
`

func (q *Queries) CreateOnboardingState(ctx context.Context, publisherID string) (PublisherOnboarding, error) {
	row := q.db.QueryRow(ctx, createOnboardingState, publisherID)
	var i PublisherOnboarding
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.CurrentStep,
		&i.CompletedSteps,
		&i.WizardData,
		&i.StartedAt,
		&i.LastUpdatedAt,
		&i.CompletedAt,
		&i.Skipped,
	)
	return i, err
}

const deprecateAlgorithmVersion = `-- name: DeprecateAlgorithmVersion :execrows
UPDATE algorithms
SET status = 'deprecated',
    updated_at = NOW()
WHERE id = $1 AND publisher_id = $2
`

type DeprecateAlgorithmVersionParams struct {
	ID          string `json:"id"`
	PublisherID string `json:"publisher_id"`
}

func (q *Queries) DeprecateAlgorithmVersion(ctx context.Context, arg DeprecateAlgorithmVersionParams) (int64, error) {
	result, err := q.db.Exec(ctx, deprecateAlgorithmVersion, arg.ID, arg.PublisherID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getAlgorithmByID = `-- name: GetAlgorithmByID :one
SELECT id, name, COALESCE(description, '') as description,
       COALESCE(configuration::text, '{}')::jsonb as configuration,
       status, is_public,
       created_at, updated_at
FROM algorithms
WHERE id = $1 AND publisher_id = $2
`

type GetAlgorithmByIDParams struct {
	ID          string `json:"id"`
	PublisherID string `json:"publisher_id"`
}

type GetAlgorithmByIDRow struct {
	ID            string             `json:"id"`
	Name          string             `json:"name"`
	Description   string             `json:"description"`
	Configuration []byte             `json:"configuration"`
	Status        *string            `json:"status"`
	IsPublic      *bool              `json:"is_public"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetAlgorithmByID(ctx context.Context, arg GetAlgorithmByIDParams) (GetAlgorithmByIDRow, error) {
	row := q.db.QueryRow(ctx, getAlgorithmByID, arg.ID, arg.PublisherID)
	var i GetAlgorithmByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Configuration,
		&i.Status,
		&i.IsPublic,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAlgorithmVersions = `-- name: GetAlgorithmVersions :many

SELECT id, name,
       status,
       is_public,
       created_at
FROM algorithms
WHERE publisher_id = $1
ORDER BY created_at DESC
`

type GetAlgorithmVersionsRow struct {
	ID        string             `json:"id"`
	Name      string             `json:"name"`
	Status    *string            `json:"status"`
	IsPublic  *bool              `json:"is_public"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

// Algorithm versions --
func (q *Queries) GetAlgorithmVersions(ctx context.Context, publisherID string) ([]GetAlgorithmVersionsRow, error) {
	rows, err := q.db.Query(ctx, getAlgorithmVersions, publisherID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAlgorithmVersionsRow{}
	for rows.Next() {
		var i GetAlgorithmVersionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Status,
			&i.IsPublic,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOnboardingState = `-- name: GetOnboardingState :one

SELECT
    id, publisher_id, current_step, completed_steps, wizard_data,
    started_at, last_updated_at, completed_at, skipped
FROM publisher_onboarding
WHERE publisher_id = $1
`

// Onboarding related --
func (q *Queries) GetOnboardingState(ctx context.Context, publisherID string) (PublisherOnboarding, error) {
	row := q.db.QueryRow(ctx, getOnboardingState, publisherID)
	var i PublisherOnboarding
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.CurrentStep,
		&i.CompletedSteps,
		&i.WizardData,
		&i.StartedAt,
		&i.LastUpdatedAt,
		&i.CompletedAt,
		&i.Skipped,
	)
	return i, err
}

const getPublisherActiveAlgorithm = `-- name: GetPublisherActiveAlgorithm :one
SELECT id, name, COALESCE(description, '') as description,
       COALESCE(configuration::text, '{}')::jsonb as configuration,
       status, is_public,
       created_at, updated_at
FROM algorithms
WHERE publisher_id = $1 AND status = 'published'
ORDER BY created_at DESC
LIMIT 1
`

type GetPublisherActiveAlgorithmRow struct {
	ID            string             `json:"id"`
	Name          string             `json:"name"`
	Description   string             `json:"description"`
	Configuration []byte             `json:"configuration"`
	Status        *string            `json:"status"`
	IsPublic      *bool              `json:"is_public"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetPublisherActiveAlgorithm(ctx context.Context, publisherID string) (GetPublisherActiveAlgorithmRow, error) {
	row := q.db.QueryRow(ctx, getPublisherActiveAlgorithm, publisherID)
	var i GetPublisherActiveAlgorithmRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Configuration,
		&i.Status,
		&i.IsPublic,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPublisherDraftAlgorithm = `-- name: GetPublisherDraftAlgorithm :one


SELECT id, name, COALESCE(description, '') as description,
       COALESCE(configuration::text, '{}')::jsonb as configuration,
       status, is_public,
       created_at, updated_at
FROM algorithms
WHERE publisher_id = $1 AND status = 'draft'
ORDER BY created_at DESC
LIMIT 1
`

type GetPublisherDraftAlgorithmRow struct {
	ID            string             `json:"id"`
	Name          string             `json:"name"`
	Description   string             `json:"description"`
	Configuration []byte             `json:"configuration"`
	Status        *string            `json:"status"`
	IsPublic      *bool              `json:"is_public"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
}

// Algorithms SQL Queries
// SQLc will generate type-safe Go code from these queries
// Get algorithm for publisher --
func (q *Queries) GetPublisherDraftAlgorithm(ctx context.Context, publisherID string) (GetPublisherDraftAlgorithmRow, error) {
	row := q.db.QueryRow(ctx, getPublisherDraftAlgorithm, publisherID)
	var i GetPublisherDraftAlgorithmRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Configuration,
		&i.Status,
		&i.IsPublic,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const publishAlgorithm = `-- name: PublishAlgorithm :one
UPDATE algorithms
SET status = 'published',
    updated_at = NOW()
WHERE id = $1
RETURNING updated_at
`

func (q *Queries) PublishAlgorithm(ctx context.Context, id string) (pgtype.Timestamptz, error) {
	row := q.db.QueryRow(ctx, publishAlgorithm, id)
	var updated_at pgtype.Timestamptz
	err := row.Scan(&updated_at)
	return updated_at, err
}

const skipOnboarding = `-- name: SkipOnboarding :one
UPDATE publisher_onboarding
SET skipped = true,
    last_updated_at = NOW()
WHERE publisher_id = $1
RETURNING id
`

func (q *Queries) SkipOnboarding(ctx context.Context, publisherID string) (string, error) {
	row := q.db.QueryRow(ctx, skipOnboarding, publisherID)
	var id string
	err := row.Scan(&id)
	return id, err
}

const updateAlgorithmDraft = `-- name: UpdateAlgorithmDraft :one
UPDATE algorithms
SET configuration = $1,
    name = COALESCE(NULLIF($2, ''), name),
    description = COALESCE(NULLIF($3, ''), description),
    updated_at = NOW()
WHERE id = $4
RETURNING id, created_at, updated_at
`

type UpdateAlgorithmDraftParams struct {
	Configuration []byte      `json:"configuration"`
	Column2       interface{} `json:"column_2"`
	Column3       interface{} `json:"column_3"`
	ID            string      `json:"id"`
}

type UpdateAlgorithmDraftRow struct {
	ID        string             `json:"id"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) UpdateAlgorithmDraft(ctx context.Context, arg UpdateAlgorithmDraftParams) (UpdateAlgorithmDraftRow, error) {
	row := q.db.QueryRow(ctx, updateAlgorithmDraft,
		arg.Configuration,
		arg.Column2,
		arg.Column3,
		arg.ID,
	)
	var i UpdateAlgorithmDraftRow
	err := row.Scan(&i.ID, &i.CreatedAt, &i.UpdatedAt)
	return i, err
}

const updateOnboardingState = `-- name: UpdateOnboardingState :one
UPDATE publisher_onboarding
SET current_step = COALESCE($2, current_step),
    completed_steps = COALESCE($3, completed_steps),
    wizard_data = COALESCE($4, wizard_data),
    last_updated_at = NOW()
WHERE publisher_id = $1
RETURNING id, publisher_id, current_step, completed_steps, wizard_data,
    started_at, last_updated_at, completed_at, skipped
`

type UpdateOnboardingStateParams struct {
	PublisherID    string  `json:"publisher_id"`
	CurrentStep    *int32  `json:"current_step"`
	CompletedSteps []int32 `json:"completed_steps"`
	WizardData     []byte  `json:"wizard_data"`
}

func (q *Queries) UpdateOnboardingState(ctx context.Context, arg UpdateOnboardingStateParams) (PublisherOnboarding, error) {
	row := q.db.QueryRow(ctx, updateOnboardingState,
		arg.PublisherID,
		arg.CurrentStep,
		arg.CompletedSteps,
		arg.WizardData,
	)
	var i PublisherOnboarding
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.CurrentStep,
		&i.CompletedSteps,
		&i.WizardData,
		&i.StartedAt,
		&i.LastUpdatedAt,
		&i.CompletedAt,
		&i.Skipped,
	)
	return i, err
}
