// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: algorithms.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const archiveActiveAlgorithms = `-- name: ArchiveActiveAlgorithms :exec

UPDATE algorithms
SET status = 'deprecated', updated_at = NOW()
WHERE publisher_id = $1 AND status = 'published'
`

// Publish algorithm --
func (q *Queries) ArchiveActiveAlgorithms(ctx context.Context, publisherID string) error {
	_, err := q.db.Exec(ctx, archiveActiveAlgorithms, publisherID)
	return err
}

const createAlgorithm = `-- name: CreateAlgorithm :one

INSERT INTO algorithms (
    publisher_id, name, description, configuration, status, is_public
)
VALUES ($1, $2, $3, $4, 'draft', false)
RETURNING id, created_at, updated_at
`

type CreateAlgorithmParams struct {
	PublisherID   string  `json:"publisher_id"`
	Name          string  `json:"name"`
	Description   *string `json:"description"`
	Configuration []byte  `json:"configuration"`
}

type CreateAlgorithmRow struct {
	ID        string             `json:"id"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

// Create or update algorithm --
func (q *Queries) CreateAlgorithm(ctx context.Context, arg CreateAlgorithmParams) (CreateAlgorithmRow, error) {
	row := q.db.QueryRow(ctx, createAlgorithm,
		arg.PublisherID,
		arg.Name,
		arg.Description,
		arg.Configuration,
	)
	var i CreateAlgorithmRow
	err := row.Scan(&i.ID, &i.CreatedAt, &i.UpdatedAt)
	return i, err
}

const createOnboardingState = `-- name: CreateOnboardingState :one
INSERT INTO publisher_onboarding (publisher_id)
VALUES ($1)
RETURNING id, publisher_id, profile_complete, algorithm_selected, zmanim_configured, coverage_set,
    created_at, updated_at
`

func (q *Queries) CreateOnboardingState(ctx context.Context, publisherID string) (PublisherOnboarding, error) {
	row := q.db.QueryRow(ctx, createOnboardingState, publisherID)
	var i PublisherOnboarding
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.ProfileComplete,
		&i.AlgorithmSelected,
		&i.ZmanimConfigured,
		&i.CoverageSet,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deprecateAlgorithmVersion = `-- name: DeprecateAlgorithmVersion :execrows
UPDATE algorithms
SET status = 'deprecated',
    updated_at = NOW()
WHERE id = $1 AND publisher_id = $2
`

type DeprecateAlgorithmVersionParams struct {
	ID          string `json:"id"`
	PublisherID string `json:"publisher_id"`
}

func (q *Queries) DeprecateAlgorithmVersion(ctx context.Context, arg DeprecateAlgorithmVersionParams) (int64, error) {
	result, err := q.db.Exec(ctx, deprecateAlgorithmVersion, arg.ID, arg.PublisherID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getAlgorithmByID = `-- name: GetAlgorithmByID :one
SELECT id, name, COALESCE(description, '') as description,
       COALESCE(configuration::text, '{}')::jsonb as configuration,
       status, is_public,
       created_at, updated_at
FROM algorithms
WHERE id = $1 AND publisher_id = $2
`

type GetAlgorithmByIDParams struct {
	ID          string `json:"id"`
	PublisherID string `json:"publisher_id"`
}

type GetAlgorithmByIDRow struct {
	ID            string             `json:"id"`
	Name          string             `json:"name"`
	Description   string             `json:"description"`
	Configuration []byte             `json:"configuration"`
	Status        *string            `json:"status"`
	IsPublic      *bool              `json:"is_public"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetAlgorithmByID(ctx context.Context, arg GetAlgorithmByIDParams) (GetAlgorithmByIDRow, error) {
	row := q.db.QueryRow(ctx, getAlgorithmByID, arg.ID, arg.PublisherID)
	var i GetAlgorithmByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Configuration,
		&i.Status,
		&i.IsPublic,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAlgorithmTemplateByKey = `-- name: GetAlgorithmTemplateByKey :one
SELECT
    id, template_key, name, description,
    configuration, sort_order, is_active,
    created_at, updated_at
FROM algorithm_templates
WHERE template_key = $1 AND is_active = true
`

func (q *Queries) GetAlgorithmTemplateByKey(ctx context.Context, templateKey string) (AlgorithmTemplate, error) {
	row := q.db.QueryRow(ctx, getAlgorithmTemplateByKey, templateKey)
	var i AlgorithmTemplate
	err := row.Scan(
		&i.ID,
		&i.TemplateKey,
		&i.Name,
		&i.Description,
		&i.Configuration,
		&i.SortOrder,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAlgorithmTemplates = `-- name: GetAlgorithmTemplates :many

SELECT
    id, template_key, name, description,
    configuration, sort_order, is_active,
    created_at, updated_at
FROM algorithm_templates
WHERE is_active = true
ORDER BY sort_order ASC
`

// Algorithm Templates --
func (q *Queries) GetAlgorithmTemplates(ctx context.Context) ([]AlgorithmTemplate, error) {
	rows, err := q.db.Query(ctx, getAlgorithmTemplates)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AlgorithmTemplate{}
	for rows.Next() {
		var i AlgorithmTemplate
		if err := rows.Scan(
			&i.ID,
			&i.TemplateKey,
			&i.Name,
			&i.Description,
			&i.Configuration,
			&i.SortOrder,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAlgorithmVersions = `-- name: GetAlgorithmVersions :many

SELECT id, name,
       status,
       is_public,
       created_at
FROM algorithms
WHERE publisher_id = $1
ORDER BY created_at DESC
`

type GetAlgorithmVersionsRow struct {
	ID        string             `json:"id"`
	Name      string             `json:"name"`
	Status    *string            `json:"status"`
	IsPublic  *bool              `json:"is_public"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

// Algorithm versions --
func (q *Queries) GetAlgorithmVersions(ctx context.Context, publisherID string) ([]GetAlgorithmVersionsRow, error) {
	rows, err := q.db.Query(ctx, getAlgorithmVersions, publisherID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAlgorithmVersionsRow{}
	for rows.Next() {
		var i GetAlgorithmVersionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Status,
			&i.IsPublic,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOnboardingState = `-- name: GetOnboardingState :one

SELECT
    id, publisher_id, profile_complete, algorithm_selected, zmanim_configured, coverage_set,
    created_at, updated_at
FROM publisher_onboarding
WHERE publisher_id = $1
`

// Onboarding related --
// Schema: id, publisher_id, profile_complete, algorithm_selected, zmanim_configured, coverage_set, created_at, updated_at
func (q *Queries) GetOnboardingState(ctx context.Context, publisherID string) (PublisherOnboarding, error) {
	row := q.db.QueryRow(ctx, getOnboardingState, publisherID)
	var i PublisherOnboarding
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.ProfileComplete,
		&i.AlgorithmSelected,
		&i.ZmanimConfigured,
		&i.CoverageSet,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPublisherActiveAlgorithm = `-- name: GetPublisherActiveAlgorithm :one
SELECT id, name, COALESCE(description, '') as description,
       COALESCE(configuration::text, '{}')::jsonb as configuration,
       status, is_public,
       created_at, updated_at
FROM algorithms
WHERE publisher_id = $1 AND status = 'published'
ORDER BY created_at DESC
LIMIT 1
`

type GetPublisherActiveAlgorithmRow struct {
	ID            string             `json:"id"`
	Name          string             `json:"name"`
	Description   string             `json:"description"`
	Configuration []byte             `json:"configuration"`
	Status        *string            `json:"status"`
	IsPublic      *bool              `json:"is_public"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetPublisherActiveAlgorithm(ctx context.Context, publisherID string) (GetPublisherActiveAlgorithmRow, error) {
	row := q.db.QueryRow(ctx, getPublisherActiveAlgorithm, publisherID)
	var i GetPublisherActiveAlgorithmRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Configuration,
		&i.Status,
		&i.IsPublic,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPublisherDraftAlgorithm = `-- name: GetPublisherDraftAlgorithm :one


SELECT id, name, COALESCE(description, '') as description,
       COALESCE(configuration::text, '{}')::jsonb as configuration,
       status, is_public,
       created_at, updated_at
FROM algorithms
WHERE publisher_id = $1 AND status = 'draft'
ORDER BY created_at DESC
LIMIT 1
`

type GetPublisherDraftAlgorithmRow struct {
	ID            string             `json:"id"`
	Name          string             `json:"name"`
	Description   string             `json:"description"`
	Configuration []byte             `json:"configuration"`
	Status        *string            `json:"status"`
	IsPublic      *bool              `json:"is_public"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
}

// Algorithms SQL Queries
// SQLc will generate type-safe Go code from these queries
// Get algorithm for publisher --
func (q *Queries) GetPublisherDraftAlgorithm(ctx context.Context, publisherID string) (GetPublisherDraftAlgorithmRow, error) {
	row := q.db.QueryRow(ctx, getPublisherDraftAlgorithm, publisherID)
	var i GetPublisherDraftAlgorithmRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Configuration,
		&i.Status,
		&i.IsPublic,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const publishAlgorithm = `-- name: PublishAlgorithm :one
UPDATE algorithms
SET status = 'published',
    updated_at = NOW()
WHERE id = $1
RETURNING updated_at
`

func (q *Queries) PublishAlgorithm(ctx context.Context, id string) (pgtype.Timestamptz, error) {
	row := q.db.QueryRow(ctx, publishAlgorithm, id)
	var updated_at pgtype.Timestamptz
	err := row.Scan(&updated_at)
	return updated_at, err
}

const updateAlgorithmDraft = `-- name: UpdateAlgorithmDraft :one
UPDATE algorithms
SET configuration = $1,
    name = COALESCE(NULLIF($2, ''), name),
    description = COALESCE(NULLIF($3, ''), description),
    updated_at = NOW()
WHERE id = $4
RETURNING id, created_at, updated_at
`

type UpdateAlgorithmDraftParams struct {
	Configuration []byte      `json:"configuration"`
	Column2       interface{} `json:"column_2"`
	Column3       interface{} `json:"column_3"`
	ID            string      `json:"id"`
}

type UpdateAlgorithmDraftRow struct {
	ID        string             `json:"id"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) UpdateAlgorithmDraft(ctx context.Context, arg UpdateAlgorithmDraftParams) (UpdateAlgorithmDraftRow, error) {
	row := q.db.QueryRow(ctx, updateAlgorithmDraft,
		arg.Configuration,
		arg.Column2,
		arg.Column3,
		arg.ID,
	)
	var i UpdateAlgorithmDraftRow
	err := row.Scan(&i.ID, &i.CreatedAt, &i.UpdatedAt)
	return i, err
}

const updateOnboardingAlgorithmSelected = `-- name: UpdateOnboardingAlgorithmSelected :one
UPDATE publisher_onboarding
SET algorithm_selected = $2, updated_at = NOW()
WHERE publisher_id = $1
RETURNING id, publisher_id, profile_complete, algorithm_selected, zmanim_configured, coverage_set,
    created_at, updated_at
`

type UpdateOnboardingAlgorithmSelectedParams struct {
	PublisherID       string `json:"publisher_id"`
	AlgorithmSelected *bool  `json:"algorithm_selected"`
}

func (q *Queries) UpdateOnboardingAlgorithmSelected(ctx context.Context, arg UpdateOnboardingAlgorithmSelectedParams) (PublisherOnboarding, error) {
	row := q.db.QueryRow(ctx, updateOnboardingAlgorithmSelected, arg.PublisherID, arg.AlgorithmSelected)
	var i PublisherOnboarding
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.ProfileComplete,
		&i.AlgorithmSelected,
		&i.ZmanimConfigured,
		&i.CoverageSet,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateOnboardingCoverageSet = `-- name: UpdateOnboardingCoverageSet :one
UPDATE publisher_onboarding
SET coverage_set = $2, updated_at = NOW()
WHERE publisher_id = $1
RETURNING id, publisher_id, profile_complete, algorithm_selected, zmanim_configured, coverage_set,
    created_at, updated_at
`

type UpdateOnboardingCoverageSetParams struct {
	PublisherID string `json:"publisher_id"`
	CoverageSet *bool  `json:"coverage_set"`
}

func (q *Queries) UpdateOnboardingCoverageSet(ctx context.Context, arg UpdateOnboardingCoverageSetParams) (PublisherOnboarding, error) {
	row := q.db.QueryRow(ctx, updateOnboardingCoverageSet, arg.PublisherID, arg.CoverageSet)
	var i PublisherOnboarding
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.ProfileComplete,
		&i.AlgorithmSelected,
		&i.ZmanimConfigured,
		&i.CoverageSet,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateOnboardingProfileComplete = `-- name: UpdateOnboardingProfileComplete :one
UPDATE publisher_onboarding
SET profile_complete = $2, updated_at = NOW()
WHERE publisher_id = $1
RETURNING id, publisher_id, profile_complete, algorithm_selected, zmanim_configured, coverage_set,
    created_at, updated_at
`

type UpdateOnboardingProfileCompleteParams struct {
	PublisherID     string `json:"publisher_id"`
	ProfileComplete *bool  `json:"profile_complete"`
}

func (q *Queries) UpdateOnboardingProfileComplete(ctx context.Context, arg UpdateOnboardingProfileCompleteParams) (PublisherOnboarding, error) {
	row := q.db.QueryRow(ctx, updateOnboardingProfileComplete, arg.PublisherID, arg.ProfileComplete)
	var i PublisherOnboarding
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.ProfileComplete,
		&i.AlgorithmSelected,
		&i.ZmanimConfigured,
		&i.CoverageSet,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateOnboardingZmanimConfigured = `-- name: UpdateOnboardingZmanimConfigured :one
UPDATE publisher_onboarding
SET zmanim_configured = $2, updated_at = NOW()
WHERE publisher_id = $1
RETURNING id, publisher_id, profile_complete, algorithm_selected, zmanim_configured, coverage_set,
    created_at, updated_at
`

type UpdateOnboardingZmanimConfiguredParams struct {
	PublisherID      string `json:"publisher_id"`
	ZmanimConfigured *bool  `json:"zmanim_configured"`
}

func (q *Queries) UpdateOnboardingZmanimConfigured(ctx context.Context, arg UpdateOnboardingZmanimConfiguredParams) (PublisherOnboarding, error) {
	row := q.db.QueryRow(ctx, updateOnboardingZmanimConfigured, arg.PublisherID, arg.ZmanimConfigured)
	var i PublisherOnboarding
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.ProfileComplete,
		&i.AlgorithmSelected,
		&i.ZmanimConfigured,
		&i.CoverageSet,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
