// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: geo_boundaries.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const assignAllCityHierarchy = `-- name: AssignAllCityHierarchy :many

SELECT assign_all_city_hierarchy FROM assign_all_city_hierarchy()
`

// ============================================================================
// Hierarchy Assignment (Point-in-Polygon)
// ============================================================================
// Assigns cities to countries/regions/districts based on point-in-polygon
func (q *Queries) AssignAllCityHierarchy(ctx context.Context) ([]interface{}, error) {
	rows, err := q.db.Query(ctx, assignAllCityHierarchy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []interface{}{}
	for rows.Next() {
		var assign_all_city_hierarchy interface{}
		if err := rows.Scan(&assign_all_city_hierarchy); err != nil {
			return nil, err
		}
		items = append(items, assign_all_city_hierarchy)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const assignCitiesToCountries = `-- name: AssignCitiesToCountries :one
SELECT assign_cities_to_countries FROM assign_cities_to_countries()
`

func (q *Queries) AssignCitiesToCountries(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRow(ctx, assignCitiesToCountries)
	var assign_cities_to_countries interface{}
	err := row.Scan(&assign_cities_to_countries)
	return assign_cities_to_countries, err
}

const assignCitiesToDistricts = `-- name: AssignCitiesToDistricts :one
SELECT assign_cities_to_districts FROM assign_cities_to_districts()
`

func (q *Queries) AssignCitiesToDistricts(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRow(ctx, assignCitiesToDistricts)
	var assign_cities_to_districts interface{}
	err := row.Scan(&assign_cities_to_districts)
	return assign_cities_to_districts, err
}

const assignCitiesToRegions = `-- name: AssignCitiesToRegions :one
SELECT assign_cities_to_regions FROM assign_cities_to_regions()
`

func (q *Queries) AssignCitiesToRegions(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRow(ctx, assignCitiesToRegions)
	var assign_cities_to_regions interface{}
	err := row.Scan(&assign_cities_to_regions)
	return assign_cities_to_regions, err
}

const countCityBoundaries = `-- name: CountCityBoundaries :one
SELECT COUNT(*) FROM geo_city_boundaries
`

func (q *Queries) CountCityBoundaries(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countCityBoundaries)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countCountryBoundaries = `-- name: CountCountryBoundaries :one

SELECT COUNT(*) FROM geo_country_boundaries
`

// ============================================================================
// Statistics
// ============================================================================
func (q *Queries) CountCountryBoundaries(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countCountryBoundaries)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countDistrictBoundaries = `-- name: CountDistrictBoundaries :one
SELECT COUNT(*) FROM geo_district_boundaries
`

func (q *Queries) CountDistrictBoundaries(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countDistrictBoundaries)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countRegionBoundaries = `-- name: CountRegionBoundaries :one
SELECT COUNT(*) FROM geo_region_boundaries
`

func (q *Queries) CountRegionBoundaries(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countRegionBoundaries)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createBoundaryImport = `-- name: CreateBoundaryImport :one

INSERT INTO geo_boundary_imports (source, level, country_code, version, records_imported, records_matched, records_unmatched, notes)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id
`

type CreateBoundaryImportParams struct {
	Source           string  `json:"source"`
	Level            string  `json:"level"`
	CountryCode      *string `json:"country_code"`
	Version          *string `json:"version"`
	RecordsImported  *int32  `json:"records_imported"`
	RecordsMatched   *int32  `json:"records_matched"`
	RecordsUnmatched *int32  `json:"records_unmatched"`
	Notes            *string `json:"notes"`
}

// ============================================================================
// Import Tracking
// ============================================================================
func (q *Queries) CreateBoundaryImport(ctx context.Context, arg CreateBoundaryImportParams) (int32, error) {
	row := q.db.QueryRow(ctx, createBoundaryImport,
		arg.Source,
		arg.Level,
		arg.CountryCode,
		arg.Version,
		arg.RecordsImported,
		arg.RecordsMatched,
		arg.RecordsUnmatched,
		arg.Notes,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const deleteAllCityBoundaries = `-- name: DeleteAllCityBoundaries :exec
DELETE FROM geo_city_boundaries
`

func (q *Queries) DeleteAllCityBoundaries(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteAllCityBoundaries)
	return err
}

const deleteAllCountryBoundaries = `-- name: DeleteAllCountryBoundaries :exec
DELETE FROM geo_country_boundaries
`

func (q *Queries) DeleteAllCountryBoundaries(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteAllCountryBoundaries)
	return err
}

const deleteAllDistrictBoundaries = `-- name: DeleteAllDistrictBoundaries :exec
DELETE FROM geo_district_boundaries
`

func (q *Queries) DeleteAllDistrictBoundaries(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteAllDistrictBoundaries)
	return err
}

const deleteAllRegionBoundaries = `-- name: DeleteAllRegionBoundaries :exec
DELETE FROM geo_region_boundaries
`

func (q *Queries) DeleteAllRegionBoundaries(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteAllRegionBoundaries)
	return err
}

const deleteCountryBoundary = `-- name: DeleteCountryBoundary :exec
DELETE FROM geo_country_boundaries WHERE country_id = $1
`

func (q *Queries) DeleteCountryBoundary(ctx context.Context, countryID int16) error {
	_, err := q.db.Exec(ctx, deleteCountryBoundary, countryID)
	return err
}

const deleteDistrictBoundary = `-- name: DeleteDistrictBoundary :exec
DELETE FROM geo_district_boundaries WHERE district_id = $1
`

func (q *Queries) DeleteDistrictBoundary(ctx context.Context, districtID int32) error {
	_, err := q.db.Exec(ctx, deleteDistrictBoundary, districtID)
	return err
}

const deleteRegionBoundary = `-- name: DeleteRegionBoundary :exec
DELETE FROM geo_region_boundaries WHERE region_id = $1
`

func (q *Queries) DeleteRegionBoundary(ctx context.Context, regionID int32) error {
	_, err := q.db.Exec(ctx, deleteRegionBoundary, regionID)
	return err
}

const getAllCountryBoundaries = `-- name: GetAllCountryBoundaries :many


SELECT
    c.id,
    c.code,
    c.name,
    c.adm1_label,
    c.adm2_label,
    c.has_adm1,
    c.has_adm2,
    ct.code as continent_code,
    ct.name as continent_name,
    cb.area_km2,
    ST_AsGeoJSON(COALESCE(cb.boundary_simplified, cb.boundary))::text as boundary_geojson,
    ST_X(cb.centroid::geometry) as centroid_lng,
    ST_Y(cb.centroid::geometry) as centroid_lat
FROM geo_country_boundaries cb
JOIN geo_countries c ON cb.country_id = c.id
JOIN geo_continents ct ON c.continent_id = ct.id
ORDER BY c.name
`

type GetAllCountryBoundariesRow struct {
	ID              int16       `json:"id"`
	Code            string      `json:"code"`
	Name            string      `json:"name"`
	Adm1Label       *string     `json:"adm1_label"`
	Adm2Label       *string     `json:"adm2_label"`
	HasAdm1         *bool       `json:"has_adm1"`
	HasAdm2         *bool       `json:"has_adm2"`
	ContinentCode   string      `json:"continent_code"`
	ContinentName   string      `json:"continent_name"`
	AreaKm2         *float64    `json:"area_km2"`
	BoundaryGeojson string      `json:"boundary_geojson"`
	CentroidLng     interface{} `json:"centroid_lng"`
	CentroidLat     interface{} `json:"centroid_lat"`
}

// Geo Boundaries SQL Queries (5-Level Hierarchy)
// Supports boundaries for: countries, regions (ADM1), districts (ADM2)
// ============================================================================
// Country Boundaries (ADM0)
// ============================================================================
func (q *Queries) GetAllCountryBoundaries(ctx context.Context) ([]GetAllCountryBoundariesRow, error) {
	rows, err := q.db.Query(ctx, getAllCountryBoundaries)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllCountryBoundariesRow{}
	for rows.Next() {
		var i GetAllCountryBoundariesRow
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.Adm1Label,
			&i.Adm2Label,
			&i.HasAdm1,
			&i.HasAdm2,
			&i.ContinentCode,
			&i.ContinentName,
			&i.AreaKm2,
			&i.BoundaryGeojson,
			&i.CentroidLng,
			&i.CentroidLat,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBoundaryImportsByLevel = `-- name: GetBoundaryImportsByLevel :many
SELECT id, source, level, country_code, version, imported_at, records_imported, records_matched, records_unmatched, notes
FROM geo_boundary_imports
WHERE level = $1
ORDER BY imported_at DESC
`

type GetBoundaryImportsByLevelRow struct {
	ID               int32              `json:"id"`
	Source           string             `json:"source"`
	Level            string             `json:"level"`
	CountryCode      *string            `json:"country_code"`
	Version          *string            `json:"version"`
	ImportedAt       pgtype.Timestamptz `json:"imported_at"`
	RecordsImported  *int32             `json:"records_imported"`
	RecordsMatched   *int32             `json:"records_matched"`
	RecordsUnmatched *int32             `json:"records_unmatched"`
	Notes            *string            `json:"notes"`
}

func (q *Queries) GetBoundaryImportsByLevel(ctx context.Context, level string) ([]GetBoundaryImportsByLevelRow, error) {
	rows, err := q.db.Query(ctx, getBoundaryImportsByLevel, level)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetBoundaryImportsByLevelRow{}
	for rows.Next() {
		var i GetBoundaryImportsByLevelRow
		if err := rows.Scan(
			&i.ID,
			&i.Source,
			&i.Level,
			&i.CountryCode,
			&i.Version,
			&i.ImportedAt,
			&i.RecordsImported,
			&i.RecordsMatched,
			&i.RecordsUnmatched,
			&i.Notes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBoundaryStats = `-- name: GetBoundaryStats :one
SELECT
    (SELECT COUNT(*) FROM geo_countries) as total_countries,
    (SELECT COUNT(*) FROM geo_country_boundaries) as countries_with_boundaries,
    (SELECT COUNT(*) FROM geo_regions) as total_regions,
    (SELECT COUNT(*) FROM geo_region_boundaries) as regions_with_boundaries,
    (SELECT COUNT(*) FROM geo_districts) as total_districts,
    (SELECT COUNT(*) FROM geo_district_boundaries) as districts_with_boundaries
`

type GetBoundaryStatsRow struct {
	TotalCountries          int64 `json:"total_countries"`
	CountriesWithBoundaries int64 `json:"countries_with_boundaries"`
	TotalRegions            int64 `json:"total_regions"`
	RegionsWithBoundaries   int64 `json:"regions_with_boundaries"`
	TotalDistricts          int64 `json:"total_districts"`
	DistrictsWithBoundaries int64 `json:"districts_with_boundaries"`
}

func (q *Queries) GetBoundaryStats(ctx context.Context) (GetBoundaryStatsRow, error) {
	row := q.db.QueryRow(ctx, getBoundaryStats)
	var i GetBoundaryStatsRow
	err := row.Scan(
		&i.TotalCountries,
		&i.CountriesWithBoundaries,
		&i.TotalRegions,
		&i.RegionsWithBoundaries,
		&i.TotalDistricts,
		&i.DistrictsWithBoundaries,
	)
	return i, err
}

const getCityBoundaryByID = `-- name: GetCityBoundaryByID :one
SELECT
    c.id,
    c.name,
    co.code as country_code,
    r.name as region_name,
    d.name as district_name,
    cb.area_km2,
    ST_AsGeoJSON(cb.boundary)::text as boundary_geojson
FROM geo_city_boundaries cb
JOIN geo_cities c ON cb.city_id = c.id
JOIN geo_countries co ON c.country_id = co.id
LEFT JOIN geo_regions r ON c.region_id = r.id
LEFT JOIN geo_districts d ON c.district_id = d.id
WHERE c.id = $1
`

type GetCityBoundaryByIDRow struct {
	ID              string   `json:"id"`
	Name            string   `json:"name"`
	CountryCode     string   `json:"country_code"`
	RegionName      *string  `json:"region_name"`
	DistrictName    *string  `json:"district_name"`
	AreaKm2         *float64 `json:"area_km2"`
	BoundaryGeojson string   `json:"boundary_geojson"`
}

func (q *Queries) GetCityBoundaryByID(ctx context.Context, id string) (GetCityBoundaryByIDRow, error) {
	row := q.db.QueryRow(ctx, getCityBoundaryByID, id)
	var i GetCityBoundaryByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CountryCode,
		&i.RegionName,
		&i.DistrictName,
		&i.AreaKm2,
		&i.BoundaryGeojson,
	)
	return i, err
}

const getCityHierarchyStats = `-- name: GetCityHierarchyStats :one
SELECT
    (SELECT COUNT(*) FROM geo_cities) as total_cities,
    (SELECT COUNT(*) FROM geo_cities) as cities_with_country,  -- All cities have country via region
    (SELECT COUNT(*) FROM geo_cities WHERE region_id IS NOT NULL) as cities_with_region,
    (SELECT COUNT(*) FROM geo_cities WHERE district_id IS NOT NULL) as cities_with_district,
    (SELECT COUNT(*) FROM geo_cities c
     JOIN geo_regions r ON c.region_id = r.id
     JOIN geo_countries co ON r.country_id = co.id
     WHERE co.has_adm1 = true AND c.region_id IS NULL) as missing_region,
    (SELECT COUNT(*) FROM geo_cities c
     JOIN geo_regions r ON c.region_id = r.id
     JOIN geo_countries co ON r.country_id = co.id
     WHERE co.has_adm2 = true AND c.district_id IS NULL) as missing_district
`

type GetCityHierarchyStatsRow struct {
	TotalCities        int64 `json:"total_cities"`
	CitiesWithCountry  int64 `json:"cities_with_country"`
	CitiesWithRegion   int64 `json:"cities_with_region"`
	CitiesWithDistrict int64 `json:"cities_with_district"`
	MissingRegion      int64 `json:"missing_region"`
	MissingDistrict    int64 `json:"missing_district"`
}

// Get statistics on city hierarchy assignments
// Note: country derived via city.region_id â†’ region.country_id (region_id is NOT NULL)
func (q *Queries) GetCityHierarchyStats(ctx context.Context) (GetCityHierarchyStatsRow, error) {
	row := q.db.QueryRow(ctx, getCityHierarchyStats)
	var i GetCityHierarchyStatsRow
	err := row.Scan(
		&i.TotalCities,
		&i.CitiesWithCountry,
		&i.CitiesWithRegion,
		&i.CitiesWithDistrict,
		&i.MissingRegion,
		&i.MissingDistrict,
	)
	return i, err
}

const getCountriesWithoutBoundaries = `-- name: GetCountriesWithoutBoundaries :many
SELECT c.id, c.code, c.name
FROM geo_countries c
LEFT JOIN geo_country_boundaries cb ON c.id = cb.country_id
WHERE cb.country_id IS NULL
ORDER BY c.name
`

type GetCountriesWithoutBoundariesRow struct {
	ID   int16  `json:"id"`
	Code string `json:"code"`
	Name string `json:"name"`
}

func (q *Queries) GetCountriesWithoutBoundaries(ctx context.Context) ([]GetCountriesWithoutBoundariesRow, error) {
	rows, err := q.db.Query(ctx, getCountriesWithoutBoundaries)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCountriesWithoutBoundariesRow{}
	for rows.Next() {
		var i GetCountriesWithoutBoundariesRow
		if err := rows.Scan(&i.ID, &i.Code, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCountryBoundariesByContinent = `-- name: GetCountryBoundariesByContinent :many
SELECT
    c.id,
    c.code,
    c.name,
    c.adm1_label,
    c.adm2_label,
    c.has_adm1,
    c.has_adm2,
    ct.code as continent_code,
    ct.name as continent_name,
    cb.area_km2,
    ST_AsGeoJSON(COALESCE(cb.boundary_simplified, cb.boundary))::text as boundary_geojson,
    ST_X(cb.centroid::geometry) as centroid_lng,
    ST_Y(cb.centroid::geometry) as centroid_lat
FROM geo_country_boundaries cb
JOIN geo_countries c ON cb.country_id = c.id
JOIN geo_continents ct ON c.continent_id = ct.id
WHERE ct.code = $1
ORDER BY c.name
`

type GetCountryBoundariesByContinentRow struct {
	ID              int16       `json:"id"`
	Code            string      `json:"code"`
	Name            string      `json:"name"`
	Adm1Label       *string     `json:"adm1_label"`
	Adm2Label       *string     `json:"adm2_label"`
	HasAdm1         *bool       `json:"has_adm1"`
	HasAdm2         *bool       `json:"has_adm2"`
	ContinentCode   string      `json:"continent_code"`
	ContinentName   string      `json:"continent_name"`
	AreaKm2         *float64    `json:"area_km2"`
	BoundaryGeojson string      `json:"boundary_geojson"`
	CentroidLng     interface{} `json:"centroid_lng"`
	CentroidLat     interface{} `json:"centroid_lat"`
}

func (q *Queries) GetCountryBoundariesByContinent(ctx context.Context, code string) ([]GetCountryBoundariesByContinentRow, error) {
	rows, err := q.db.Query(ctx, getCountryBoundariesByContinent, code)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCountryBoundariesByContinentRow{}
	for rows.Next() {
		var i GetCountryBoundariesByContinentRow
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.Adm1Label,
			&i.Adm2Label,
			&i.HasAdm1,
			&i.HasAdm2,
			&i.ContinentCode,
			&i.ContinentName,
			&i.AreaKm2,
			&i.BoundaryGeojson,
			&i.CentroidLng,
			&i.CentroidLat,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCountryBoundaryByCode = `-- name: GetCountryBoundaryByCode :one
SELECT
    c.id,
    c.code,
    c.name,
    c.adm1_label,
    c.adm2_label,
    c.has_adm1,
    c.has_adm2,
    ct.code as continent_code,
    ct.name as continent_name,
    cb.area_km2,
    ST_AsGeoJSON(cb.boundary)::text as boundary_geojson,
    ST_X(cb.centroid::geometry) as centroid_lng,
    ST_Y(cb.centroid::geometry) as centroid_lat
FROM geo_country_boundaries cb
JOIN geo_countries c ON cb.country_id = c.id
JOIN geo_continents ct ON c.continent_id = ct.id
WHERE c.code = $1
`

type GetCountryBoundaryByCodeRow struct {
	ID              int16       `json:"id"`
	Code            string      `json:"code"`
	Name            string      `json:"name"`
	Adm1Label       *string     `json:"adm1_label"`
	Adm2Label       *string     `json:"adm2_label"`
	HasAdm1         *bool       `json:"has_adm1"`
	HasAdm2         *bool       `json:"has_adm2"`
	ContinentCode   string      `json:"continent_code"`
	ContinentName   string      `json:"continent_name"`
	AreaKm2         *float64    `json:"area_km2"`
	BoundaryGeojson string      `json:"boundary_geojson"`
	CentroidLng     interface{} `json:"centroid_lng"`
	CentroidLat     interface{} `json:"centroid_lat"`
}

func (q *Queries) GetCountryBoundaryByCode(ctx context.Context, code string) (GetCountryBoundaryByCodeRow, error) {
	row := q.db.QueryRow(ctx, getCountryBoundaryByCode, code)
	var i GetCountryBoundaryByCodeRow
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.Adm1Label,
		&i.Adm2Label,
		&i.HasAdm1,
		&i.HasAdm2,
		&i.ContinentCode,
		&i.ContinentName,
		&i.AreaKm2,
		&i.BoundaryGeojson,
		&i.CentroidLng,
		&i.CentroidLat,
	)
	return i, err
}

const getCountryBoundaryByID = `-- name: GetCountryBoundaryByID :one
SELECT
    c.id,
    c.code,
    c.name,
    cb.area_km2,
    ST_AsGeoJSON(cb.boundary)::text as boundary_geojson,
    ST_X(cb.centroid::geometry) as centroid_lng,
    ST_Y(cb.centroid::geometry) as centroid_lat
FROM geo_country_boundaries cb
JOIN geo_countries c ON cb.country_id = c.id
WHERE c.id = $1
`

type GetCountryBoundaryByIDRow struct {
	ID              int16       `json:"id"`
	Code            string      `json:"code"`
	Name            string      `json:"name"`
	AreaKm2         *float64    `json:"area_km2"`
	BoundaryGeojson string      `json:"boundary_geojson"`
	CentroidLng     interface{} `json:"centroid_lng"`
	CentroidLat     interface{} `json:"centroid_lat"`
}

func (q *Queries) GetCountryBoundaryByID(ctx context.Context, id int16) (GetCountryBoundaryByIDRow, error) {
	row := q.db.QueryRow(ctx, getCountryBoundaryByID, id)
	var i GetCountryBoundaryByIDRow
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.AreaKm2,
		&i.BoundaryGeojson,
		&i.CentroidLng,
		&i.CentroidLat,
	)
	return i, err
}

const getDistrictBoundariesByCountry = `-- name: GetDistrictBoundariesByCountry :many

SELECT
    d.id,
    d.name,
    d.code,
    r.id as region_id,
    r.code as region_code,
    r.name as region_name,
    c.code as country_code,
    db.area_km2,
    ST_AsGeoJSON(COALESCE(db.boundary_simplified, db.boundary))::text as boundary_geojson,
    ST_X(db.centroid::geometry) as centroid_lng,
    ST_Y(db.centroid::geometry) as centroid_lat
FROM geo_district_boundaries db
JOIN geo_districts d ON db.district_id = d.id
JOIN geo_regions r ON d.region_id = r.id
JOIN geo_countries c ON r.country_id = c.id
WHERE c.code = $1
ORDER BY r.name, d.name
`

type GetDistrictBoundariesByCountryRow struct {
	ID              int32       `json:"id"`
	Name            string      `json:"name"`
	Code            string      `json:"code"`
	RegionID        int32       `json:"region_id"`
	RegionCode      string      `json:"region_code"`
	RegionName      string      `json:"region_name"`
	CountryCode     string      `json:"country_code"`
	AreaKm2         *float64    `json:"area_km2"`
	BoundaryGeojson string      `json:"boundary_geojson"`
	CentroidLng     interface{} `json:"centroid_lng"`
	CentroidLat     interface{} `json:"centroid_lat"`
}

// ============================================================================
// District Boundaries (ADM2)
// ============================================================================
func (q *Queries) GetDistrictBoundariesByCountry(ctx context.Context, code string) ([]GetDistrictBoundariesByCountryRow, error) {
	rows, err := q.db.Query(ctx, getDistrictBoundariesByCountry, code)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDistrictBoundariesByCountryRow{}
	for rows.Next() {
		var i GetDistrictBoundariesByCountryRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Code,
			&i.RegionID,
			&i.RegionCode,
			&i.RegionName,
			&i.CountryCode,
			&i.AreaKm2,
			&i.BoundaryGeojson,
			&i.CentroidLng,
			&i.CentroidLat,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDistrictBoundariesByRegion = `-- name: GetDistrictBoundariesByRegion :many
SELECT
    d.id,
    d.name,
    d.code,
    r.code as region_code,
    r.name as region_name,
    db.area_km2,
    ST_AsGeoJSON(COALESCE(db.boundary_simplified, db.boundary))::text as boundary_geojson,
    ST_X(db.centroid::geometry) as centroid_lng,
    ST_Y(db.centroid::geometry) as centroid_lat
FROM geo_district_boundaries db
JOIN geo_districts d ON db.district_id = d.id
JOIN geo_regions r ON d.region_id = r.id
WHERE r.id = $1
ORDER BY d.name
`

type GetDistrictBoundariesByRegionRow struct {
	ID              int32       `json:"id"`
	Name            string      `json:"name"`
	Code            string      `json:"code"`
	RegionCode      string      `json:"region_code"`
	RegionName      string      `json:"region_name"`
	AreaKm2         *float64    `json:"area_km2"`
	BoundaryGeojson string      `json:"boundary_geojson"`
	CentroidLng     interface{} `json:"centroid_lng"`
	CentroidLat     interface{} `json:"centroid_lat"`
}

func (q *Queries) GetDistrictBoundariesByRegion(ctx context.Context, id int32) ([]GetDistrictBoundariesByRegionRow, error) {
	rows, err := q.db.Query(ctx, getDistrictBoundariesByRegion, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDistrictBoundariesByRegionRow{}
	for rows.Next() {
		var i GetDistrictBoundariesByRegionRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Code,
			&i.RegionCode,
			&i.RegionName,
			&i.AreaKm2,
			&i.BoundaryGeojson,
			&i.CentroidLng,
			&i.CentroidLat,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDistrictBoundaryByID = `-- name: GetDistrictBoundaryByID :one
SELECT
    d.id,
    d.name,
    d.code,
    r.id as region_id,
    r.code as region_code,
    r.name as region_name,
    c.code as country_code,
    c.name as country_name,
    db.area_km2,
    ST_AsGeoJSON(db.boundary)::text as boundary_geojson,
    ST_X(db.centroid::geometry) as centroid_lng,
    ST_Y(db.centroid::geometry) as centroid_lat
FROM geo_district_boundaries db
JOIN geo_districts d ON db.district_id = d.id
JOIN geo_regions r ON d.region_id = r.id
JOIN geo_countries c ON r.country_id = c.id
WHERE d.id = $1
`

type GetDistrictBoundaryByIDRow struct {
	ID              int32       `json:"id"`
	Name            string      `json:"name"`
	Code            string      `json:"code"`
	RegionID        int32       `json:"region_id"`
	RegionCode      string      `json:"region_code"`
	RegionName      string      `json:"region_name"`
	CountryCode     string      `json:"country_code"`
	CountryName     string      `json:"country_name"`
	AreaKm2         *float64    `json:"area_km2"`
	BoundaryGeojson string      `json:"boundary_geojson"`
	CentroidLng     interface{} `json:"centroid_lng"`
	CentroidLat     interface{} `json:"centroid_lat"`
}

func (q *Queries) GetDistrictBoundaryByID(ctx context.Context, id int32) (GetDistrictBoundaryByIDRow, error) {
	row := q.db.QueryRow(ctx, getDistrictBoundaryByID, id)
	var i GetDistrictBoundaryByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Code,
		&i.RegionID,
		&i.RegionCode,
		&i.RegionName,
		&i.CountryCode,
		&i.CountryName,
		&i.AreaKm2,
		&i.BoundaryGeojson,
		&i.CentroidLng,
		&i.CentroidLat,
	)
	return i, err
}

const getDistrictsWithoutBoundaries = `-- name: GetDistrictsWithoutBoundaries :many
SELECT d.id, d.code, d.name, r.code as region_code, c.code as country_code
FROM geo_districts d
JOIN geo_regions r ON d.region_id = r.id
JOIN geo_countries c ON r.country_id = c.id
LEFT JOIN geo_district_boundaries db ON d.id = db.district_id
WHERE db.district_id IS NULL AND c.code = $1
ORDER BY r.name, d.name
`

type GetDistrictsWithoutBoundariesRow struct {
	ID          int32  `json:"id"`
	Code        string `json:"code"`
	Name        string `json:"name"`
	RegionCode  string `json:"region_code"`
	CountryCode string `json:"country_code"`
}

func (q *Queries) GetDistrictsWithoutBoundaries(ctx context.Context, code string) ([]GetDistrictsWithoutBoundariesRow, error) {
	rows, err := q.db.Query(ctx, getDistrictsWithoutBoundaries, code)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDistrictsWithoutBoundariesRow{}
	for rows.Next() {
		var i GetDistrictsWithoutBoundariesRow
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.RegionCode,
			&i.CountryCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestBoundaryImport = `-- name: GetLatestBoundaryImport :one
SELECT id, source, level, country_code, version, imported_at, records_imported, records_matched, records_unmatched, notes
FROM geo_boundary_imports
ORDER BY imported_at DESC
LIMIT 1
`

type GetLatestBoundaryImportRow struct {
	ID               int32              `json:"id"`
	Source           string             `json:"source"`
	Level            string             `json:"level"`
	CountryCode      *string            `json:"country_code"`
	Version          *string            `json:"version"`
	ImportedAt       pgtype.Timestamptz `json:"imported_at"`
	RecordsImported  *int32             `json:"records_imported"`
	RecordsMatched   *int32             `json:"records_matched"`
	RecordsUnmatched *int32             `json:"records_unmatched"`
	Notes            *string            `json:"notes"`
}

func (q *Queries) GetLatestBoundaryImport(ctx context.Context) (GetLatestBoundaryImportRow, error) {
	row := q.db.QueryRow(ctx, getLatestBoundaryImport)
	var i GetLatestBoundaryImportRow
	err := row.Scan(
		&i.ID,
		&i.Source,
		&i.Level,
		&i.CountryCode,
		&i.Version,
		&i.ImportedAt,
		&i.RecordsImported,
		&i.RecordsMatched,
		&i.RecordsUnmatched,
		&i.Notes,
	)
	return i, err
}

const getNameMapping = `-- name: GetNameMapping :one

SELECT id, level, source, source_name, source_country_code, target_id, notes
FROM geo_name_mappings
WHERE level = $1 AND source = $2 AND source_name = $3
  AND (source_country_code = $4 OR (source_country_code IS NULL AND $4 IS NULL))
`

type GetNameMappingParams struct {
	Level             string  `json:"level"`
	Source            string  `json:"source"`
	SourceName        string  `json:"source_name"`
	SourceCountryCode *string `json:"source_country_code"`
}

type GetNameMappingRow struct {
	ID                int32   `json:"id"`
	Level             string  `json:"level"`
	Source            string  `json:"source"`
	SourceName        string  `json:"source_name"`
	SourceCountryCode *string `json:"source_country_code"`
	TargetID          int32   `json:"target_id"`
	Notes             *string `json:"notes"`
}

// ============================================================================
// Name Mappings
// ============================================================================
func (q *Queries) GetNameMapping(ctx context.Context, arg GetNameMappingParams) (GetNameMappingRow, error) {
	row := q.db.QueryRow(ctx, getNameMapping,
		arg.Level,
		arg.Source,
		arg.SourceName,
		arg.SourceCountryCode,
	)
	var i GetNameMappingRow
	err := row.Scan(
		&i.ID,
		&i.Level,
		&i.Source,
		&i.SourceName,
		&i.SourceCountryCode,
		&i.TargetID,
		&i.Notes,
	)
	return i, err
}

const getNameMappingsByLevel = `-- name: GetNameMappingsByLevel :many
SELECT id, level, source, source_name, source_country_code, target_id, notes
FROM geo_name_mappings
WHERE level = $1
ORDER BY source_name
`

type GetNameMappingsByLevelRow struct {
	ID                int32   `json:"id"`
	Level             string  `json:"level"`
	Source            string  `json:"source"`
	SourceName        string  `json:"source_name"`
	SourceCountryCode *string `json:"source_country_code"`
	TargetID          int32   `json:"target_id"`
	Notes             *string `json:"notes"`
}

func (q *Queries) GetNameMappingsByLevel(ctx context.Context, level string) ([]GetNameMappingsByLevelRow, error) {
	rows, err := q.db.Query(ctx, getNameMappingsByLevel, level)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetNameMappingsByLevelRow{}
	for rows.Next() {
		var i GetNameMappingsByLevelRow
		if err := rows.Scan(
			&i.ID,
			&i.Level,
			&i.Source,
			&i.SourceName,
			&i.SourceCountryCode,
			&i.TargetID,
			&i.Notes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRegionBoundariesByCountry = `-- name: GetRegionBoundariesByCountry :many

SELECT
    r.id,
    r.name,
    r.code,
    c.code as country_code,
    c.name as country_name,
    rb.area_km2,
    ST_AsGeoJSON(COALESCE(rb.boundary_simplified, rb.boundary))::text as boundary_geojson,
    ST_X(rb.centroid::geometry) as centroid_lng,
    ST_Y(rb.centroid::geometry) as centroid_lat
FROM geo_region_boundaries rb
JOIN geo_regions r ON rb.region_id = r.id
JOIN geo_countries c ON r.country_id = c.id
WHERE c.code = $1
ORDER BY r.name
`

type GetRegionBoundariesByCountryRow struct {
	ID              int32       `json:"id"`
	Name            string      `json:"name"`
	Code            string      `json:"code"`
	CountryCode     string      `json:"country_code"`
	CountryName     string      `json:"country_name"`
	AreaKm2         *float64    `json:"area_km2"`
	BoundaryGeojson string      `json:"boundary_geojson"`
	CentroidLng     interface{} `json:"centroid_lng"`
	CentroidLat     interface{} `json:"centroid_lat"`
}

// ============================================================================
// Region Boundaries (ADM1)
// ============================================================================
func (q *Queries) GetRegionBoundariesByCountry(ctx context.Context, code string) ([]GetRegionBoundariesByCountryRow, error) {
	rows, err := q.db.Query(ctx, getRegionBoundariesByCountry, code)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRegionBoundariesByCountryRow{}
	for rows.Next() {
		var i GetRegionBoundariesByCountryRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Code,
			&i.CountryCode,
			&i.CountryName,
			&i.AreaKm2,
			&i.BoundaryGeojson,
			&i.CentroidLng,
			&i.CentroidLat,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRegionBoundaryByCode = `-- name: GetRegionBoundaryByCode :one
SELECT
    r.id,
    r.name,
    r.code,
    c.code as country_code,
    c.name as country_name,
    rb.area_km2,
    ST_AsGeoJSON(rb.boundary)::text as boundary_geojson,
    ST_X(rb.centroid::geometry) as centroid_lng,
    ST_Y(rb.centroid::geometry) as centroid_lat
FROM geo_region_boundaries rb
JOIN geo_regions r ON rb.region_id = r.id
JOIN geo_countries c ON r.country_id = c.id
WHERE c.code = $1 AND r.code = $2
`

type GetRegionBoundaryByCodeParams struct {
	Code   string `json:"code"`
	Code_2 string `json:"code_2"`
}

type GetRegionBoundaryByCodeRow struct {
	ID              int32       `json:"id"`
	Name            string      `json:"name"`
	Code            string      `json:"code"`
	CountryCode     string      `json:"country_code"`
	CountryName     string      `json:"country_name"`
	AreaKm2         *float64    `json:"area_km2"`
	BoundaryGeojson string      `json:"boundary_geojson"`
	CentroidLng     interface{} `json:"centroid_lng"`
	CentroidLat     interface{} `json:"centroid_lat"`
}

func (q *Queries) GetRegionBoundaryByCode(ctx context.Context, arg GetRegionBoundaryByCodeParams) (GetRegionBoundaryByCodeRow, error) {
	row := q.db.QueryRow(ctx, getRegionBoundaryByCode, arg.Code, arg.Code_2)
	var i GetRegionBoundaryByCodeRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Code,
		&i.CountryCode,
		&i.CountryName,
		&i.AreaKm2,
		&i.BoundaryGeojson,
		&i.CentroidLng,
		&i.CentroidLat,
	)
	return i, err
}

const getRegionBoundaryByID = `-- name: GetRegionBoundaryByID :one
SELECT
    r.id,
    r.name,
    r.code,
    c.code as country_code,
    c.name as country_name,
    rb.area_km2,
    ST_AsGeoJSON(rb.boundary)::text as boundary_geojson,
    ST_X(rb.centroid::geometry) as centroid_lng,
    ST_Y(rb.centroid::geometry) as centroid_lat
FROM geo_region_boundaries rb
JOIN geo_regions r ON rb.region_id = r.id
JOIN geo_countries c ON r.country_id = c.id
WHERE r.id = $1
`

type GetRegionBoundaryByIDRow struct {
	ID              int32       `json:"id"`
	Name            string      `json:"name"`
	Code            string      `json:"code"`
	CountryCode     string      `json:"country_code"`
	CountryName     string      `json:"country_name"`
	AreaKm2         *float64    `json:"area_km2"`
	BoundaryGeojson string      `json:"boundary_geojson"`
	CentroidLng     interface{} `json:"centroid_lng"`
	CentroidLat     interface{} `json:"centroid_lat"`
}

func (q *Queries) GetRegionBoundaryByID(ctx context.Context, id int32) (GetRegionBoundaryByIDRow, error) {
	row := q.db.QueryRow(ctx, getRegionBoundaryByID, id)
	var i GetRegionBoundaryByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Code,
		&i.CountryCode,
		&i.CountryName,
		&i.AreaKm2,
		&i.BoundaryGeojson,
		&i.CentroidLng,
		&i.CentroidLat,
	)
	return i, err
}

const getRegionsWithoutBoundaries = `-- name: GetRegionsWithoutBoundaries :many
SELECT r.id, r.code, r.name, c.code as country_code
FROM geo_regions r
JOIN geo_countries c ON r.country_id = c.id
LEFT JOIN geo_region_boundaries rb ON r.id = rb.region_id
WHERE rb.region_id IS NULL AND c.code = $1
ORDER BY r.name
`

type GetRegionsWithoutBoundariesRow struct {
	ID          int32  `json:"id"`
	Code        string `json:"code"`
	Name        string `json:"name"`
	CountryCode string `json:"country_code"`
}

func (q *Queries) GetRegionsWithoutBoundaries(ctx context.Context, code string) ([]GetRegionsWithoutBoundariesRow, error) {
	rows, err := q.db.Query(ctx, getRegionsWithoutBoundaries, code)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRegionsWithoutBoundariesRow{}
	for rows.Next() {
		var i GetRegionsWithoutBoundariesRow
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.CountryCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const lookupAllLevelsByPoint = `-- name: LookupAllLevelsByPoint :one
SELECT
    c.id as country_id,
    c.code as country_code,
    c.name as country_name,
    c.adm1_label,
    c.adm2_label,
    r.id as region_id,
    r.code as region_code,
    r.name as region_name,
    d.id as district_id,
    d.code as district_code,
    d.name as district_name
FROM geo_countries c
JOIN geo_country_boundaries cb ON c.id = cb.country_id
LEFT JOIN geo_region_boundaries rb ON ST_Contains(rb.boundary::geometry, ST_SetSRID(ST_MakePoint($1, $2), 4326))
LEFT JOIN geo_regions r ON rb.region_id = r.id AND r.country_id = c.id
LEFT JOIN geo_district_boundaries db ON ST_Contains(db.boundary::geometry, ST_SetSRID(ST_MakePoint($1, $2), 4326))
LEFT JOIN geo_districts d ON db.district_id = d.id AND d.region_id = r.id
WHERE ST_Contains(cb.boundary::geometry, ST_SetSRID(ST_MakePoint($1, $2), 4326))
LIMIT 1
`

type LookupAllLevelsByPointParams struct {
	StMakepoint   interface{} `json:"st_makepoint"`
	StMakepoint_2 interface{} `json:"st_makepoint_2"`
}

type LookupAllLevelsByPointRow struct {
	CountryID    int16   `json:"country_id"`
	CountryCode  string  `json:"country_code"`
	CountryName  string  `json:"country_name"`
	Adm1Label    *string `json:"adm1_label"`
	Adm2Label    *string `json:"adm2_label"`
	RegionID     *int32  `json:"region_id"`
	RegionCode   *string `json:"region_code"`
	RegionName   *string `json:"region_name"`
	DistrictID   *int32  `json:"district_id"`
	DistrictCode *string `json:"district_code"`
	DistrictName *string `json:"district_name"`
}

// Returns all geographic levels for a point (country, region, district)
func (q *Queries) LookupAllLevelsByPoint(ctx context.Context, arg LookupAllLevelsByPointParams) (LookupAllLevelsByPointRow, error) {
	row := q.db.QueryRow(ctx, lookupAllLevelsByPoint, arg.StMakepoint, arg.StMakepoint_2)
	var i LookupAllLevelsByPointRow
	err := row.Scan(
		&i.CountryID,
		&i.CountryCode,
		&i.CountryName,
		&i.Adm1Label,
		&i.Adm2Label,
		&i.RegionID,
		&i.RegionCode,
		&i.RegionName,
		&i.DistrictID,
		&i.DistrictCode,
		&i.DistrictName,
	)
	return i, err
}

const lookupAllLevelsByPointWithArea = `-- name: LookupAllLevelsByPointWithArea :one
SELECT
    -- Country
    c.id as country_id,
    c.code as country_code,
    c.name as country_name,
    c.adm1_label,
    c.adm2_label,
    c.has_adm1,
    c.has_adm2,
    c.is_city_state,
    cb.area_km2 as country_area_km2,
    -- Region
    r.id as region_id,
    r.code as region_code,
    r.name as region_name,
    rb.area_km2 as region_area_km2,
    -- District
    d.id as district_id,
    d.code as district_code,
    d.name as district_name,
    db.area_km2 as district_area_km2
FROM geo_countries c
JOIN geo_country_boundaries cb ON c.id = cb.country_id
LEFT JOIN geo_region_boundaries rb ON ST_Contains(rb.boundary::geometry, ST_SetSRID(ST_MakePoint($1, $2), 4326))
LEFT JOIN geo_regions r ON rb.region_id = r.id AND r.country_id = c.id
LEFT JOIN geo_district_boundaries db ON ST_Contains(db.boundary::geometry, ST_SetSRID(ST_MakePoint($1, $2), 4326))
LEFT JOIN geo_districts d ON db.district_id = d.id AND d.region_id = r.id
WHERE ST_Contains(cb.boundary::geometry, ST_SetSRID(ST_MakePoint($1, $2), 4326))
LIMIT 1
`

type LookupAllLevelsByPointWithAreaParams struct {
	StMakepoint   interface{} `json:"st_makepoint"`
	StMakepoint_2 interface{} `json:"st_makepoint_2"`
}

type LookupAllLevelsByPointWithAreaRow struct {
	CountryID       int16    `json:"country_id"`
	CountryCode     string   `json:"country_code"`
	CountryName     string   `json:"country_name"`
	Adm1Label       *string  `json:"adm1_label"`
	Adm2Label       *string  `json:"adm2_label"`
	HasAdm1         *bool    `json:"has_adm1"`
	HasAdm2         *bool    `json:"has_adm2"`
	IsCityState     *bool    `json:"is_city_state"`
	CountryAreaKm2  *float64 `json:"country_area_km2"`
	RegionID        *int32   `json:"region_id"`
	RegionCode      *string  `json:"region_code"`
	RegionName      *string  `json:"region_name"`
	RegionAreaKm2   *float64 `json:"region_area_km2"`
	DistrictID      *int32   `json:"district_id"`
	DistrictCode    *string  `json:"district_code"`
	DistrictName    *string  `json:"district_name"`
	DistrictAreaKm2 *float64 `json:"district_area_km2"`
}

// Returns all geographic levels for a point with area information for zoom-based selection
func (q *Queries) LookupAllLevelsByPointWithArea(ctx context.Context, arg LookupAllLevelsByPointWithAreaParams) (LookupAllLevelsByPointWithAreaRow, error) {
	row := q.db.QueryRow(ctx, lookupAllLevelsByPointWithArea, arg.StMakepoint, arg.StMakepoint_2)
	var i LookupAllLevelsByPointWithAreaRow
	err := row.Scan(
		&i.CountryID,
		&i.CountryCode,
		&i.CountryName,
		&i.Adm1Label,
		&i.Adm2Label,
		&i.HasAdm1,
		&i.HasAdm2,
		&i.IsCityState,
		&i.CountryAreaKm2,
		&i.RegionID,
		&i.RegionCode,
		&i.RegionName,
		&i.RegionAreaKm2,
		&i.DistrictID,
		&i.DistrictCode,
		&i.DistrictName,
		&i.DistrictAreaKm2,
	)
	return i, err
}

const lookupCountryByPoint = `-- name: LookupCountryByPoint :one

SELECT
    c.id,
    c.code,
    c.name,
    c.adm1_label,
    c.adm2_label,
    c.has_adm1,
    c.has_adm2
FROM geo_countries c
JOIN geo_country_boundaries cb ON c.id = cb.country_id
WHERE ST_Contains(cb.boundary::geometry, ST_SetSRID(ST_MakePoint($1, $2), 4326))
LIMIT 1
`

type LookupCountryByPointParams struct {
	StMakepoint   interface{} `json:"st_makepoint"`
	StMakepoint_2 interface{} `json:"st_makepoint_2"`
}

type LookupCountryByPointRow struct {
	ID        int16   `json:"id"`
	Code      string  `json:"code"`
	Name      string  `json:"name"`
	Adm1Label *string `json:"adm1_label"`
	Adm2Label *string `json:"adm2_label"`
	HasAdm1   *bool   `json:"has_adm1"`
	HasAdm2   *bool   `json:"has_adm2"`
}

// ============================================================================
// Point-in-Polygon Lookups
// ============================================================================
func (q *Queries) LookupCountryByPoint(ctx context.Context, arg LookupCountryByPointParams) (LookupCountryByPointRow, error) {
	row := q.db.QueryRow(ctx, lookupCountryByPoint, arg.StMakepoint, arg.StMakepoint_2)
	var i LookupCountryByPointRow
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.Adm1Label,
		&i.Adm2Label,
		&i.HasAdm1,
		&i.HasAdm2,
	)
	return i, err
}

const lookupDistrictByPoint = `-- name: LookupDistrictByPoint :one
SELECT
    d.id,
    d.name,
    d.code,
    r.id as region_id,
    r.code as region_code,
    r.name as region_name,
    c.id as country_id,
    c.code as country_code
FROM geo_districts d
JOIN geo_district_boundaries db ON d.id = db.district_id
JOIN geo_regions r ON d.region_id = r.id
JOIN geo_countries c ON r.country_id = c.id
WHERE ST_Contains(db.boundary::geometry, ST_SetSRID(ST_MakePoint($1, $2), 4326))
LIMIT 1
`

type LookupDistrictByPointParams struct {
	StMakepoint   interface{} `json:"st_makepoint"`
	StMakepoint_2 interface{} `json:"st_makepoint_2"`
}

type LookupDistrictByPointRow struct {
	ID          int32  `json:"id"`
	Name        string `json:"name"`
	Code        string `json:"code"`
	RegionID    int32  `json:"region_id"`
	RegionCode  string `json:"region_code"`
	RegionName  string `json:"region_name"`
	CountryID   int16  `json:"country_id"`
	CountryCode string `json:"country_code"`
}

func (q *Queries) LookupDistrictByPoint(ctx context.Context, arg LookupDistrictByPointParams) (LookupDistrictByPointRow, error) {
	row := q.db.QueryRow(ctx, lookupDistrictByPoint, arg.StMakepoint, arg.StMakepoint_2)
	var i LookupDistrictByPointRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Code,
		&i.RegionID,
		&i.RegionCode,
		&i.RegionName,
		&i.CountryID,
		&i.CountryCode,
	)
	return i, err
}

const lookupNearestCities = `-- name: LookupNearestCities :many
SELECT
    c.id,
    c.name,
    co.code as country_code,
    r.name as region_name,
    d.name as district_name,
    ST_Distance(c.location, ST_SetSRID(ST_MakePoint($1, $2), 4326)::geography) / 1000 as distance_km
FROM geo_cities c
JOIN geo_regions r ON c.region_id = r.id
JOIN geo_countries co ON r.country_id = co.id
LEFT JOIN geo_districts d ON c.district_id = d.id
WHERE ST_DWithin(c.location, ST_SetSRID(ST_MakePoint($1, $2), 4326)::geography, $3)
ORDER BY c.location <-> ST_SetSRID(ST_MakePoint($1, $2), 4326)::geography
LIMIT $4
`

type LookupNearestCitiesParams struct {
	StMakepoint   interface{} `json:"st_makepoint"`
	StMakepoint_2 interface{} `json:"st_makepoint_2"`
	StDwithin     interface{} `json:"st_dwithin"`
	Limit         int32       `json:"limit"`
}

type LookupNearestCitiesRow struct {
	ID           string  `json:"id"`
	Name         string  `json:"name"`
	CountryCode  string  `json:"country_code"`
	RegionName   string  `json:"region_name"`
	DistrictName *string `json:"district_name"`
	DistanceKm   int32   `json:"distance_km"`
}

func (q *Queries) LookupNearestCities(ctx context.Context, arg LookupNearestCitiesParams) ([]LookupNearestCitiesRow, error) {
	rows, err := q.db.Query(ctx, lookupNearestCities,
		arg.StMakepoint,
		arg.StMakepoint_2,
		arg.StDwithin,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LookupNearestCitiesRow{}
	for rows.Next() {
		var i LookupNearestCitiesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CountryCode,
			&i.RegionName,
			&i.DistrictName,
			&i.DistanceKm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const lookupRegionByPoint = `-- name: LookupRegionByPoint :one
SELECT
    r.id,
    r.name,
    r.code,
    c.id as country_id,
    c.code as country_code
FROM geo_regions r
JOIN geo_region_boundaries rb ON r.id = rb.region_id
JOIN geo_countries c ON r.country_id = c.id
WHERE ST_Contains(rb.boundary::geometry, ST_SetSRID(ST_MakePoint($1, $2), 4326))
LIMIT 1
`

type LookupRegionByPointParams struct {
	StMakepoint   interface{} `json:"st_makepoint"`
	StMakepoint_2 interface{} `json:"st_makepoint_2"`
}

type LookupRegionByPointRow struct {
	ID          int32  `json:"id"`
	Name        string `json:"name"`
	Code        string `json:"code"`
	CountryID   int16  `json:"country_id"`
	CountryCode string `json:"country_code"`
}

func (q *Queries) LookupRegionByPoint(ctx context.Context, arg LookupRegionByPointParams) (LookupRegionByPointRow, error) {
	row := q.db.QueryRow(ctx, lookupRegionByPoint, arg.StMakepoint, arg.StMakepoint_2)
	var i LookupRegionByPointRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Code,
		&i.CountryID,
		&i.CountryCode,
	)
	return i, err
}

const upsertCityBoundary = `-- name: UpsertCityBoundary :exec

INSERT INTO geo_city_boundaries (city_id, boundary, boundary_simplified, area_km2)
VALUES (
    $1,
    ST_GeomFromGeoJSON($2)::geography,
    CASE WHEN $3::text IS NOT NULL THEN ST_GeomFromGeoJSON($3)::geography ELSE NULL END,
    $4
)
ON CONFLICT (city_id) DO UPDATE SET
    boundary = ST_GeomFromGeoJSON($2)::geography,
    boundary_simplified = CASE WHEN $3::text IS NOT NULL THEN ST_GeomFromGeoJSON($3)::geography ELSE geo_city_boundaries.boundary_simplified END,
    area_km2 = $4,
    updated_at = now()
`

type UpsertCityBoundaryParams struct {
	CityID            string      `json:"city_id"`
	StGeomfromgeojson interface{} `json:"st_geomfromgeojson"`
	Column3           string      `json:"column_3"`
	AreaKm2           *float64    `json:"area_km2"`
}

// ============================================================================
// City Boundaries (Localities)
// ============================================================================
func (q *Queries) UpsertCityBoundary(ctx context.Context, arg UpsertCityBoundaryParams) error {
	_, err := q.db.Exec(ctx, upsertCityBoundary,
		arg.CityID,
		arg.StGeomfromgeojson,
		arg.Column3,
		arg.AreaKm2,
	)
	return err
}

const upsertCountryBoundary = `-- name: UpsertCountryBoundary :exec

INSERT INTO geo_country_boundaries (country_id, boundary, boundary_simplified, area_km2, centroid)
VALUES (
    $1,
    ST_GeomFromGeoJSON($2)::geography,
    CASE WHEN $3::text IS NOT NULL THEN ST_GeomFromGeoJSON($3)::geography ELSE NULL END,
    $4,
    ST_SetSRID(ST_MakePoint($5, $6), 4326)::geography
)
ON CONFLICT (country_id) DO UPDATE SET
    boundary = ST_GeomFromGeoJSON($2)::geography,
    boundary_simplified = CASE WHEN $3::text IS NOT NULL THEN ST_GeomFromGeoJSON($3)::geography ELSE geo_country_boundaries.boundary_simplified END,
    area_km2 = $4,
    centroid = ST_SetSRID(ST_MakePoint($5, $6), 4326)::geography,
    updated_at = now()
`

type UpsertCountryBoundaryParams struct {
	CountryID         int16       `json:"country_id"`
	StGeomfromgeojson interface{} `json:"st_geomfromgeojson"`
	Column3           string      `json:"column_3"`
	AreaKm2           *float64    `json:"area_km2"`
	StMakepoint       interface{} `json:"st_makepoint"`
	StMakepoint_2     interface{} `json:"st_makepoint_2"`
}

// ============================================================================
// Boundary Management (for import scripts)
// ============================================================================
func (q *Queries) UpsertCountryBoundary(ctx context.Context, arg UpsertCountryBoundaryParams) error {
	_, err := q.db.Exec(ctx, upsertCountryBoundary,
		arg.CountryID,
		arg.StGeomfromgeojson,
		arg.Column3,
		arg.AreaKm2,
		arg.StMakepoint,
		arg.StMakepoint_2,
	)
	return err
}

const upsertDistrictBoundary = `-- name: UpsertDistrictBoundary :exec
INSERT INTO geo_district_boundaries (district_id, boundary, boundary_simplified, area_km2, centroid)
VALUES (
    $1,
    ST_GeomFromGeoJSON($2)::geography,
    CASE WHEN $3::text IS NOT NULL THEN ST_GeomFromGeoJSON($3)::geography ELSE NULL END,
    $4,
    ST_SetSRID(ST_MakePoint($5, $6), 4326)::geography
)
ON CONFLICT (district_id) DO UPDATE SET
    boundary = ST_GeomFromGeoJSON($2)::geography,
    boundary_simplified = CASE WHEN $3::text IS NOT NULL THEN ST_GeomFromGeoJSON($3)::geography ELSE geo_district_boundaries.boundary_simplified END,
    area_km2 = $4,
    centroid = ST_SetSRID(ST_MakePoint($5, $6), 4326)::geography,
    updated_at = now()
`

type UpsertDistrictBoundaryParams struct {
	DistrictID        int32       `json:"district_id"`
	StGeomfromgeojson interface{} `json:"st_geomfromgeojson"`
	Column3           string      `json:"column_3"`
	AreaKm2           *float64    `json:"area_km2"`
	StMakepoint       interface{} `json:"st_makepoint"`
	StMakepoint_2     interface{} `json:"st_makepoint_2"`
}

func (q *Queries) UpsertDistrictBoundary(ctx context.Context, arg UpsertDistrictBoundaryParams) error {
	_, err := q.db.Exec(ctx, upsertDistrictBoundary,
		arg.DistrictID,
		arg.StGeomfromgeojson,
		arg.Column3,
		arg.AreaKm2,
		arg.StMakepoint,
		arg.StMakepoint_2,
	)
	return err
}

const upsertNameMapping = `-- name: UpsertNameMapping :exec
INSERT INTO geo_name_mappings (level, source, source_name, source_country_code, target_id, notes)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (level, source, source_name, source_country_code) DO UPDATE SET
    target_id = $5,
    notes = $6
`

type UpsertNameMappingParams struct {
	Level             string  `json:"level"`
	Source            string  `json:"source"`
	SourceName        string  `json:"source_name"`
	SourceCountryCode *string `json:"source_country_code"`
	TargetID          int32   `json:"target_id"`
	Notes             *string `json:"notes"`
}

func (q *Queries) UpsertNameMapping(ctx context.Context, arg UpsertNameMappingParams) error {
	_, err := q.db.Exec(ctx, upsertNameMapping,
		arg.Level,
		arg.Source,
		arg.SourceName,
		arg.SourceCountryCode,
		arg.TargetID,
		arg.Notes,
	)
	return err
}

const upsertRegionBoundary = `-- name: UpsertRegionBoundary :exec
INSERT INTO geo_region_boundaries (region_id, boundary, boundary_simplified, area_km2, centroid)
VALUES (
    $1,
    ST_GeomFromGeoJSON($2)::geography,
    CASE WHEN $3::text IS NOT NULL THEN ST_GeomFromGeoJSON($3)::geography ELSE NULL END,
    $4,
    ST_SetSRID(ST_MakePoint($5, $6), 4326)::geography
)
ON CONFLICT (region_id) DO UPDATE SET
    boundary = ST_GeomFromGeoJSON($2)::geography,
    boundary_simplified = CASE WHEN $3::text IS NOT NULL THEN ST_GeomFromGeoJSON($3)::geography ELSE geo_region_boundaries.boundary_simplified END,
    area_km2 = $4,
    centroid = ST_SetSRID(ST_MakePoint($5, $6), 4326)::geography,
    updated_at = now()
`

type UpsertRegionBoundaryParams struct {
	RegionID          int32       `json:"region_id"`
	StGeomfromgeojson interface{} `json:"st_geomfromgeojson"`
	Column3           string      `json:"column_3"`
	AreaKm2           *float64    `json:"area_km2"`
	StMakepoint       interface{} `json:"st_makepoint"`
	StMakepoint_2     interface{} `json:"st_makepoint_2"`
}

func (q *Queries) UpsertRegionBoundary(ctx context.Context, arg UpsertRegionBoundaryParams) error {
	_, err := q.db.Exec(ctx, upsertRegionBoundary,
		arg.RegionID,
		arg.StGeomfromgeojson,
		arg.Column3,
		arg.AreaKm2,
		arg.StMakepoint,
		arg.StMakepoint_2,
	)
	return err
}

const validateAllCityHierarchy = `-- name: ValidateAllCityHierarchy :many
SELECT validate_all_city_hierarchy FROM validate_all_city_hierarchy()
`

// Returns any cities with hierarchy issues
func (q *Queries) ValidateAllCityHierarchy(ctx context.Context) ([]interface{}, error) {
	rows, err := q.db.Query(ctx, validateAllCityHierarchy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []interface{}{}
	for rows.Next() {
		var validate_all_city_hierarchy interface{}
		if err := rows.Scan(&validate_all_city_hierarchy); err != nil {
			return nil, err
		}
		items = append(items, validate_all_city_hierarchy)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
