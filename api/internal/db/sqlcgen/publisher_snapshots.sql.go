// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: publisher_snapshots.sql

package sqlcgen

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPublisherSnapshot = `-- name: CreatePublisherSnapshot :one

INSERT INTO publisher_snapshots (
    publisher_id,
    description,
    snapshot_data,
    created_by
) VALUES (
    $1, $2, $3, $4
)
RETURNING id, publisher_id, description, snapshot_data, created_by, created_at
`

type CreatePublisherSnapshotParams struct {
	PublisherID  string `json:"publisher_id"`
	Description  string `json:"description"`
	SnapshotData []byte `json:"snapshot_data"`
	CreatedBy    string `json:"created_by"`
}

// ============================================
// PUBLISHER SNAPSHOT (ZMANIM-ONLY) QUERIES
// ============================================
// Snapshots store only zmanim data (not profile/coverage)
// Used for version control of publisher algorithms
func (q *Queries) CreatePublisherSnapshot(ctx context.Context, arg CreatePublisherSnapshotParams) (PublisherSnapshot, error) {
	row := q.db.QueryRow(ctx, createPublisherSnapshot,
		arg.PublisherID,
		arg.Description,
		arg.SnapshotData,
		arg.CreatedBy,
	)
	var i PublisherSnapshot
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.Description,
		&i.SnapshotData,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const deletePublisherSnapshot = `-- name: DeletePublisherSnapshot :exec
DELETE FROM publisher_snapshots
WHERE id = $1 AND publisher_id = $2
`

type DeletePublisherSnapshotParams struct {
	ID          string `json:"id"`
	PublisherID string `json:"publisher_id"`
}

func (q *Queries) DeletePublisherSnapshot(ctx context.Context, arg DeletePublisherSnapshotParams) error {
	_, err := q.db.Exec(ctx, deletePublisherSnapshot, arg.ID, arg.PublisherID)
	return err
}

const getAllPublisherZmanimKeys = `-- name: GetAllPublisherZmanimKeys :many
SELECT zman_key
FROM publisher_zmanim
WHERE publisher_id = $1 AND deleted_at IS NULL
`

// Get all active zman keys for a publisher (for diff comparison)
func (q *Queries) GetAllPublisherZmanimKeys(ctx context.Context, publisherID string) ([]string, error) {
	rows, err := q.db.Query(ctx, getAllPublisherZmanimKeys, publisherID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var zman_key string
		if err := rows.Scan(&zman_key); err != nil {
			return nil, err
		}
		items = append(items, zman_key)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDeletedZmanByKey = `-- name: GetDeletedZmanByKey :one
SELECT id, zman_key
FROM publisher_zmanim
WHERE publisher_id = $1 AND zman_key = $2 AND deleted_at IS NOT NULL
`

type GetDeletedZmanByKeyParams struct {
	PublisherID string `json:"publisher_id"`
	ZmanKey     string `json:"zman_key"`
}

type GetDeletedZmanByKeyRow struct {
	ID      string `json:"id"`
	ZmanKey string `json:"zman_key"`
}

// Check if a zman exists in deleted state (for restore decision)
func (q *Queries) GetDeletedZmanByKey(ctx context.Context, arg GetDeletedZmanByKeyParams) (GetDeletedZmanByKeyRow, error) {
	row := q.db.QueryRow(ctx, getDeletedZmanByKey, arg.PublisherID, arg.ZmanKey)
	var i GetDeletedZmanByKeyRow
	err := row.Scan(&i.ID, &i.ZmanKey)
	return i, err
}

const getLatestPublisherSnapshot = `-- name: GetLatestPublisherSnapshot :one
SELECT id, publisher_id, description, snapshot_data, created_by, created_at
FROM publisher_snapshots
WHERE publisher_id = $1
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetLatestPublisherSnapshot(ctx context.Context, publisherID string) (PublisherSnapshot, error) {
	row := q.db.QueryRow(ctx, getLatestPublisherSnapshot, publisherID)
	var i PublisherSnapshot
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.Description,
		&i.SnapshotData,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const getPublisherSnapshot = `-- name: GetPublisherSnapshot :one
SELECT id, publisher_id, description, snapshot_data, created_by, created_at
FROM publisher_snapshots
WHERE id = $1 AND publisher_id = $2
`

type GetPublisherSnapshotParams struct {
	ID          string `json:"id"`
	PublisherID string `json:"publisher_id"`
}

func (q *Queries) GetPublisherSnapshot(ctx context.Context, arg GetPublisherSnapshotParams) (PublisherSnapshot, error) {
	row := q.db.QueryRow(ctx, getPublisherSnapshot, arg.ID, arg.PublisherID)
	var i PublisherSnapshot
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.Description,
		&i.SnapshotData,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const getPublisherZmanForSnapshotCompare = `-- name: GetPublisherZmanForSnapshotCompare :one
SELECT
    id,
    zman_key,
    hebrew_name,
    english_name,
    transliteration,
    description,
    formula_dsl,
    ai_explanation,
    publisher_comment,
    is_enabled,
    is_visible,
    is_published,
    is_beta,
    is_custom,
    category,
    master_zman_id,
    linked_publisher_zman_id,
    source_type,
    current_version
FROM publisher_zmanim
WHERE publisher_id = $1 AND zman_key = $2 AND deleted_at IS NULL
`

type GetPublisherZmanForSnapshotCompareParams struct {
	PublisherID string `json:"publisher_id"`
	ZmanKey     string `json:"zman_key"`
}

type GetPublisherZmanForSnapshotCompareRow struct {
	ID                    string      `json:"id"`
	ZmanKey               string      `json:"zman_key"`
	HebrewName            string      `json:"hebrew_name"`
	EnglishName           string      `json:"english_name"`
	Transliteration       *string     `json:"transliteration"`
	Description           *string     `json:"description"`
	FormulaDsl            string      `json:"formula_dsl"`
	AiExplanation         *string     `json:"ai_explanation"`
	PublisherComment      *string     `json:"publisher_comment"`
	IsEnabled             bool        `json:"is_enabled"`
	IsVisible             bool        `json:"is_visible"`
	IsPublished           bool        `json:"is_published"`
	IsBeta                bool        `json:"is_beta"`
	IsCustom              bool        `json:"is_custom"`
	Category              string      `json:"category"`
	MasterZmanID          pgtype.UUID `json:"master_zman_id"`
	LinkedPublisherZmanID pgtype.UUID `json:"linked_publisher_zman_id"`
	SourceType            *string     `json:"source_type"`
	CurrentVersion        *int32      `json:"current_version"`
}

// Get a specific zman by key for comparison during restore
func (q *Queries) GetPublisherZmanForSnapshotCompare(ctx context.Context, arg GetPublisherZmanForSnapshotCompareParams) (GetPublisherZmanForSnapshotCompareRow, error) {
	row := q.db.QueryRow(ctx, getPublisherZmanForSnapshotCompare, arg.PublisherID, arg.ZmanKey)
	var i GetPublisherZmanForSnapshotCompareRow
	err := row.Scan(
		&i.ID,
		&i.ZmanKey,
		&i.HebrewName,
		&i.EnglishName,
		&i.Transliteration,
		&i.Description,
		&i.FormulaDsl,
		&i.AiExplanation,
		&i.PublisherComment,
		&i.IsEnabled,
		&i.IsVisible,
		&i.IsPublished,
		&i.IsBeta,
		&i.IsCustom,
		&i.Category,
		&i.MasterZmanID,
		&i.LinkedPublisherZmanID,
		&i.SourceType,
		&i.CurrentVersion,
	)
	return i, err
}

const getPublisherZmanimForSnapshot = `-- name: GetPublisherZmanimForSnapshot :many

SELECT
    zman_key,
    hebrew_name,
    english_name,
    transliteration,
    description,
    formula_dsl,
    ai_explanation,
    publisher_comment,
    is_enabled,
    is_visible,
    is_published,
    is_beta,
    is_custom,
    category,
    master_zman_id,
    linked_publisher_zman_id,
    source_type
FROM publisher_zmanim
WHERE publisher_id = $1 AND deleted_at IS NULL
`

type GetPublisherZmanimForSnapshotRow struct {
	ZmanKey               string      `json:"zman_key"`
	HebrewName            string      `json:"hebrew_name"`
	EnglishName           string      `json:"english_name"`
	Transliteration       *string     `json:"transliteration"`
	Description           *string     `json:"description"`
	FormulaDsl            string      `json:"formula_dsl"`
	AiExplanation         *string     `json:"ai_explanation"`
	PublisherComment      *string     `json:"publisher_comment"`
	IsEnabled             bool        `json:"is_enabled"`
	IsVisible             bool        `json:"is_visible"`
	IsPublished           bool        `json:"is_published"`
	IsBeta                bool        `json:"is_beta"`
	IsCustom              bool        `json:"is_custom"`
	Category              string      `json:"category"`
	MasterZmanID          pgtype.UUID `json:"master_zman_id"`
	LinkedPublisherZmanID pgtype.UUID `json:"linked_publisher_zman_id"`
	SourceType            *string     `json:"source_type"`
}

// ============================================
// ZMANIM SNAPSHOT DATA QUERIES
// ============================================
// Get all active (non-deleted) zmanim for snapshot export
func (q *Queries) GetPublisherZmanimForSnapshot(ctx context.Context, publisherID string) ([]GetPublisherZmanimForSnapshotRow, error) {
	rows, err := q.db.Query(ctx, getPublisherZmanimForSnapshot, publisherID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPublisherZmanimForSnapshotRow{}
	for rows.Next() {
		var i GetPublisherZmanimForSnapshotRow
		if err := rows.Scan(
			&i.ZmanKey,
			&i.HebrewName,
			&i.EnglishName,
			&i.Transliteration,
			&i.Description,
			&i.FormulaDsl,
			&i.AiExplanation,
			&i.PublisherComment,
			&i.IsEnabled,
			&i.IsVisible,
			&i.IsPublished,
			&i.IsBeta,
			&i.IsCustom,
			&i.Category,
			&i.MasterZmanID,
			&i.LinkedPublisherZmanID,
			&i.SourceType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertZmanFromSnapshot = `-- name: InsertZmanFromSnapshot :exec
INSERT INTO publisher_zmanim (
    publisher_id,
    zman_key,
    hebrew_name,
    english_name,
    transliteration,
    description,
    formula_dsl,
    ai_explanation,
    publisher_comment,
    is_enabled,
    is_visible,
    is_published,
    is_beta,
    is_custom,
    category,
    master_zman_id,
    linked_publisher_zman_id,
    source_type
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18
)
`

type InsertZmanFromSnapshotParams struct {
	PublisherID           string      `json:"publisher_id"`
	ZmanKey               string      `json:"zman_key"`
	HebrewName            string      `json:"hebrew_name"`
	EnglishName           string      `json:"english_name"`
	Transliteration       *string     `json:"transliteration"`
	Description           *string     `json:"description"`
	FormulaDsl            string      `json:"formula_dsl"`
	AiExplanation         *string     `json:"ai_explanation"`
	PublisherComment      *string     `json:"publisher_comment"`
	IsEnabled             bool        `json:"is_enabled"`
	IsVisible             bool        `json:"is_visible"`
	IsPublished           bool        `json:"is_published"`
	IsBeta                bool        `json:"is_beta"`
	IsCustom              bool        `json:"is_custom"`
	Category              string      `json:"category"`
	MasterZmanID          pgtype.UUID `json:"master_zman_id"`
	LinkedPublisherZmanID pgtype.UUID `json:"linked_publisher_zman_id"`
	SourceType            *string     `json:"source_type"`
}

// Insert a new zman from snapshot (zman doesn't exist at all)
func (q *Queries) InsertZmanFromSnapshot(ctx context.Context, arg InsertZmanFromSnapshotParams) error {
	_, err := q.db.Exec(ctx, insertZmanFromSnapshot,
		arg.PublisherID,
		arg.ZmanKey,
		arg.HebrewName,
		arg.EnglishName,
		arg.Transliteration,
		arg.Description,
		arg.FormulaDsl,
		arg.AiExplanation,
		arg.PublisherComment,
		arg.IsEnabled,
		arg.IsVisible,
		arg.IsPublished,
		arg.IsBeta,
		arg.IsCustom,
		arg.Category,
		arg.MasterZmanID,
		arg.LinkedPublisherZmanID,
		arg.SourceType,
	)
	return err
}

const listPublisherSnapshots = `-- name: ListPublisherSnapshots :many
SELECT
    id,
    publisher_id,
    description,
    created_by,
    created_at
FROM publisher_snapshots
WHERE publisher_id = $1
ORDER BY created_at DESC
LIMIT 20
`

type ListPublisherSnapshotsRow struct {
	ID          string    `json:"id"`
	PublisherID string    `json:"publisher_id"`
	Description string    `json:"description"`
	CreatedBy   string    `json:"created_by"`
	CreatedAt   time.Time `json:"created_at"`
}

func (q *Queries) ListPublisherSnapshots(ctx context.Context, publisherID string) ([]ListPublisherSnapshotsRow, error) {
	rows, err := q.db.Query(ctx, listPublisherSnapshots, publisherID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPublisherSnapshotsRow{}
	for rows.Next() {
		var i ListPublisherSnapshotsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublisherID,
			&i.Description,
			&i.CreatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const restoreDeletedZmanForSnapshot = `-- name: RestoreDeletedZmanForSnapshot :exec
UPDATE publisher_zmanim
SET deleted_at = NULL, deleted_by = NULL, updated_at = NOW()
WHERE publisher_id = $1 AND zman_key = $2 AND deleted_at IS NOT NULL
`

type RestoreDeletedZmanForSnapshotParams struct {
	PublisherID string `json:"publisher_id"`
	ZmanKey     string `json:"zman_key"`
}

// Restore a soft-deleted zman that exists in snapshot being restored
func (q *Queries) RestoreDeletedZmanForSnapshot(ctx context.Context, arg RestoreDeletedZmanForSnapshotParams) error {
	_, err := q.db.Exec(ctx, restoreDeletedZmanForSnapshot, arg.PublisherID, arg.ZmanKey)
	return err
}

const softDeleteZmanForRestore = `-- name: SoftDeleteZmanForRestore :exec

UPDATE publisher_zmanim
SET deleted_at = NOW(), deleted_by = $3, updated_at = NOW()
WHERE publisher_id = $1 AND zman_key = $2 AND deleted_at IS NULL
`

type SoftDeleteZmanForRestoreParams struct {
	PublisherID string  `json:"publisher_id"`
	ZmanKey     string  `json:"zman_key"`
	DeletedBy   *string `json:"deleted_by"`
}

// ============================================
// SNAPSHOT RESTORE QUERIES
// ============================================
// Soft delete a zman that exists in current state but not in snapshot being restored
func (q *Queries) SoftDeleteZmanForRestore(ctx context.Context, arg SoftDeleteZmanForRestoreParams) error {
	_, err := q.db.Exec(ctx, softDeleteZmanForRestore, arg.PublisherID, arg.ZmanKey, arg.DeletedBy)
	return err
}

const updateZmanFromSnapshot = `-- name: UpdateZmanFromSnapshot :exec
UPDATE publisher_zmanim
SET
    hebrew_name = $3,
    english_name = $4,
    transliteration = $5,
    description = $6,
    formula_dsl = $7,
    ai_explanation = $8,
    publisher_comment = $9,
    is_enabled = $10,
    is_visible = $11,
    is_published = $12,
    is_beta = $13,
    is_custom = $14,
    category = $15,
    master_zman_id = $16,
    linked_publisher_zman_id = $17,
    source_type = $18,
    updated_at = NOW()
WHERE publisher_id = $1 AND zman_key = $2 AND deleted_at IS NULL
`

type UpdateZmanFromSnapshotParams struct {
	PublisherID           string      `json:"publisher_id"`
	ZmanKey               string      `json:"zman_key"`
	HebrewName            string      `json:"hebrew_name"`
	EnglishName           string      `json:"english_name"`
	Transliteration       *string     `json:"transliteration"`
	Description           *string     `json:"description"`
	FormulaDsl            string      `json:"formula_dsl"`
	AiExplanation         *string     `json:"ai_explanation"`
	PublisherComment      *string     `json:"publisher_comment"`
	IsEnabled             bool        `json:"is_enabled"`
	IsVisible             bool        `json:"is_visible"`
	IsPublished           bool        `json:"is_published"`
	IsBeta                bool        `json:"is_beta"`
	IsCustom              bool        `json:"is_custom"`
	Category              string      `json:"category"`
	MasterZmanID          pgtype.UUID `json:"master_zman_id"`
	LinkedPublisherZmanID pgtype.UUID `json:"linked_publisher_zman_id"`
	SourceType            *string     `json:"source_type"`
}

// Update an existing zman with data from snapshot (creates new version via trigger)
func (q *Queries) UpdateZmanFromSnapshot(ctx context.Context, arg UpdateZmanFromSnapshotParams) error {
	_, err := q.db.Exec(ctx, updateZmanFromSnapshot,
		arg.PublisherID,
		arg.ZmanKey,
		arg.HebrewName,
		arg.EnglishName,
		arg.Transliteration,
		arg.Description,
		arg.FormulaDsl,
		arg.AiExplanation,
		arg.PublisherComment,
		arg.IsEnabled,
		arg.IsVisible,
		arg.IsPublished,
		arg.IsBeta,
		arg.IsCustom,
		arg.Category,
		arg.MasterZmanID,
		arg.LinkedPublisherZmanID,
		arg.SourceType,
	)
	return err
}
