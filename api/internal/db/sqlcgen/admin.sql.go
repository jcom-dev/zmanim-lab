// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: admin.sql

package sqlcgen

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const acceptInvitation = `-- name: AcceptInvitation :exec
UPDATE publisher_invitations
SET status = 'accepted', accepted_at = NOW()
WHERE id = $1
`

func (q *Queries) AcceptInvitation(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, acceptInvitation, id)
	return err
}

const adminCountAlgorithms = `-- name: AdminCountAlgorithms :one
SELECT COUNT(*)
FROM algorithms
WHERE ($1::text IS NULL OR status = $1)
`

func (q *Queries) AdminCountAlgorithms(ctx context.Context, dollar_1 string) (int64, error) {
	row := q.db.QueryRow(ctx, adminCountAlgorithms, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const adminCountPublishers = `-- name: AdminCountPublishers :one
SELECT COUNT(*)
FROM publishers
WHERE ($1::text IS NULL OR status = $1)
`

func (q *Queries) AdminCountPublishers(ctx context.Context, dollar_1 string) (int64, error) {
	row := q.db.QueryRow(ctx, adminCountPublishers, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const adminDeletePublisher = `-- name: AdminDeletePublisher :exec
DELETE FROM publishers WHERE id = $1
`

func (q *Queries) AdminDeletePublisher(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, adminDeletePublisher, id)
	return err
}

const adminGetPublisher = `-- name: AdminGetPublisher :one
SELECT id, clerk_user_id, name, organization, email, description, bio,
       website, logo_url, status, created_at, updated_at
FROM publishers
WHERE id = $1
`

type AdminGetPublisherRow struct {
	ID           string             `json:"id"`
	ClerkUserID  *string            `json:"clerk_user_id"`
	Name         string             `json:"name"`
	Organization *string            `json:"organization"`
	Email        string             `json:"email"`
	Description  *string            `json:"description"`
	Bio          *string            `json:"bio"`
	Website      *string            `json:"website"`
	LogoUrl      *string            `json:"logo_url"`
	Status       string             `json:"status"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) AdminGetPublisher(ctx context.Context, id string) (AdminGetPublisherRow, error) {
	row := q.db.QueryRow(ctx, adminGetPublisher, id)
	var i AdminGetPublisherRow
	err := row.Scan(
		&i.ID,
		&i.ClerkUserID,
		&i.Name,
		&i.Organization,
		&i.Email,
		&i.Description,
		&i.Bio,
		&i.Website,
		&i.LogoUrl,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const adminGetStatistics = `-- name: AdminGetStatistics :one

SELECT
    (SELECT COUNT(*) FROM publishers) as total_publishers,
    (SELECT COUNT(*) FROM publishers WHERE status = 'active') as active_publishers,
    (SELECT COUNT(*) FROM publishers WHERE status = 'pending') as pending_publishers,
    (SELECT COUNT(*) FROM algorithms WHERE status = 'published') as published_algorithms,
    (SELECT COUNT(*) FROM cities) as total_cities,
    (SELECT COUNT(*) FROM publisher_coverage WHERE is_active = true) as active_coverage_areas
`

type AdminGetStatisticsRow struct {
	TotalPublishers     int64 `json:"total_publishers"`
	ActivePublishers    int64 `json:"active_publishers"`
	PendingPublishers   int64 `json:"pending_publishers"`
	PublishedAlgorithms int64 `json:"published_algorithms"`
	TotalCities         int64 `json:"total_cities"`
	ActiveCoverageAreas int64 `json:"active_coverage_areas"`
}

// Admin Statistics --
func (q *Queries) AdminGetStatistics(ctx context.Context) (AdminGetStatisticsRow, error) {
	row := q.db.QueryRow(ctx, adminGetStatistics)
	var i AdminGetStatisticsRow
	err := row.Scan(
		&i.TotalPublishers,
		&i.ActivePublishers,
		&i.PendingPublishers,
		&i.PublishedAlgorithms,
		&i.TotalCities,
		&i.ActiveCoverageAreas,
	)
	return i, err
}

const adminListAlgorithms = `-- name: AdminListAlgorithms :many

SELECT
    a.id, a.publisher_id, a.name, a.status, a.is_public,
    a.created_at, a.updated_at,
    p.name as publisher_name
FROM algorithms a
JOIN publishers p ON a.publisher_id = p.id
WHERE ($1::text IS NULL OR a.status = $1)
ORDER BY a.updated_at DESC
LIMIT $2 OFFSET $3
`

type AdminListAlgorithmsParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type AdminListAlgorithmsRow struct {
	ID            string             `json:"id"`
	PublisherID   string             `json:"publisher_id"`
	Name          string             `json:"name"`
	Status        *string            `json:"status"`
	IsPublic      *bool              `json:"is_public"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
	PublisherName string             `json:"publisher_name"`
}

// Admin Algorithm Management --
func (q *Queries) AdminListAlgorithms(ctx context.Context, arg AdminListAlgorithmsParams) ([]AdminListAlgorithmsRow, error) {
	rows, err := q.db.Query(ctx, adminListAlgorithms, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AdminListAlgorithmsRow{}
	for rows.Next() {
		var i AdminListAlgorithmsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublisherID,
			&i.Name,
			&i.Status,
			&i.IsPublic,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublisherName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminListPublishers = `-- name: AdminListPublishers :many


SELECT id, clerk_user_id, name, organization, email, status, created_at, updated_at
FROM publishers
WHERE ($1::text IS NULL OR status = $1)
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type AdminListPublishersParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type AdminListPublishersRow struct {
	ID           string             `json:"id"`
	ClerkUserID  *string            `json:"clerk_user_id"`
	Name         string             `json:"name"`
	Organization *string            `json:"organization"`
	Email        string             `json:"email"`
	Status       string             `json:"status"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
}

// Admin SQL Queries
// SQLc will generate type-safe Go code from these queries
// Admin Publisher Management --
func (q *Queries) AdminListPublishers(ctx context.Context, arg AdminListPublishersParams) ([]AdminListPublishersRow, error) {
	rows, err := q.db.Query(ctx, adminListPublishers, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AdminListPublishersRow{}
	for rows.Next() {
		var i AdminListPublishersRow
		if err := rows.Scan(
			&i.ID,
			&i.ClerkUserID,
			&i.Name,
			&i.Organization,
			&i.Email,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminUpdatePublisherStatus = `-- name: AdminUpdatePublisherStatus :one
UPDATE publishers
SET status = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, status
`

type AdminUpdatePublisherStatusParams struct {
	ID     string `json:"id"`
	Status string `json:"status"`
}

type AdminUpdatePublisherStatusRow struct {
	ID     string `json:"id"`
	Status string `json:"status"`
}

func (q *Queries) AdminUpdatePublisherStatus(ctx context.Context, arg AdminUpdatePublisherStatusParams) (AdminUpdatePublisherStatusRow, error) {
	row := q.db.QueryRow(ctx, adminUpdatePublisherStatus, arg.ID, arg.Status)
	var i AdminUpdatePublisherStatusRow
	err := row.Scan(&i.ID, &i.Status)
	return i, err
}

const countPendingInvitationsForEmail = `-- name: CountPendingInvitationsForEmail :one
SELECT COUNT(*)
FROM publisher_invitations
WHERE publisher_id = $1 AND LOWER(email) = LOWER($2) AND status = 'pending'
`

type CountPendingInvitationsForEmailParams struct {
	PublisherID pgtype.UUID `json:"publisher_id"`
	Lower       string      `json:"lower"`
}

func (q *Queries) CountPendingInvitationsForEmail(ctx context.Context, arg CountPendingInvitationsForEmailParams) (int64, error) {
	row := q.db.QueryRow(ctx, countPendingInvitationsForEmail, arg.PublisherID, arg.Lower)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createInvitation = `-- name: CreateInvitation :one
INSERT INTO publisher_invitations (publisher_id, email, token, status, invited_by, expires_at)
VALUES ($1, $2, $3, 'pending', $4, $5)
RETURNING id
`

type CreateInvitationParams struct {
	PublisherID pgtype.UUID `json:"publisher_id"`
	Email       string      `json:"email"`
	Token       string      `json:"token"`
	InvitedBy   string      `json:"invited_by"`
	ExpiresAt   time.Time   `json:"expires_at"`
}

func (q *Queries) CreateInvitation(ctx context.Context, arg CreateInvitationParams) (string, error) {
	row := q.db.QueryRow(ctx, createInvitation,
		arg.PublisherID,
		arg.Email,
		arg.Token,
		arg.InvitedBy,
		arg.ExpiresAt,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}

const deleteInvitation = `-- name: DeleteInvitation :exec
DELETE FROM publisher_invitations
WHERE id = $1 AND status = 'pending'
`

func (q *Queries) DeleteInvitation(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteInvitation, id)
	return err
}

const expireInvitation = `-- name: ExpireInvitation :exec
UPDATE publisher_invitations
SET status = 'expired'
WHERE id = $1
`

func (q *Queries) ExpireInvitation(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, expireInvitation, id)
	return err
}

const getInvitationByToken = `-- name: GetInvitationByToken :one
SELECT pi.id, pi.publisher_id, pi.email, pi.status, pi.expires_at, p.name as publisher_name
FROM publisher_invitations pi
JOIN publishers p ON pi.publisher_id = p.id
WHERE pi.token = $1
`

type GetInvitationByTokenRow struct {
	ID            string      `json:"id"`
	PublisherID   pgtype.UUID `json:"publisher_id"`
	Email         string      `json:"email"`
	Status        string      `json:"status"`
	ExpiresAt     time.Time   `json:"expires_at"`
	PublisherName string      `json:"publisher_name"`
}

func (q *Queries) GetInvitationByToken(ctx context.Context, token string) (GetInvitationByTokenRow, error) {
	row := q.db.QueryRow(ctx, getInvitationByToken, token)
	var i GetInvitationByTokenRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.Email,
		&i.Status,
		&i.ExpiresAt,
		&i.PublisherName,
	)
	return i, err
}

const getPendingInvitations = `-- name: GetPendingInvitations :many

SELECT id, email, status, expires_at, created_at
FROM publisher_invitations
WHERE publisher_id = $1 AND status IN ('pending', 'expired')
ORDER BY created_at DESC
`

type GetPendingInvitationsRow struct {
	ID        string             `json:"id"`
	Email     string             `json:"email"`
	Status    string             `json:"status"`
	ExpiresAt time.Time          `json:"expires_at"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

// Publisher Invitations --
func (q *Queries) GetPendingInvitations(ctx context.Context, publisherID pgtype.UUID) ([]GetPendingInvitationsRow, error) {
	rows, err := q.db.Query(ctx, getPendingInvitations, publisherID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPendingInvitationsRow{}
	for rows.Next() {
		var i GetPendingInvitationsRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Status,
			&i.ExpiresAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublisherOwner = `-- name: GetPublisherOwner :one

SELECT clerk_user_id FROM publishers WHERE id = $1
`

// Team Management --
func (q *Queries) GetPublisherOwner(ctx context.Context, id string) (*string, error) {
	row := q.db.QueryRow(ctx, getPublisherOwner, id)
	var clerk_user_id *string
	err := row.Scan(&clerk_user_id)
	return clerk_user_id, err
}

const getZmanDefinitionByKey = `-- name: GetZmanDefinitionByKey :one
SELECT id, key, name_hebrew, name_english, transliteration, category, sort_order,
       is_standard, created_at, updated_at
FROM zman_definitions
WHERE key = $1
`

type GetZmanDefinitionByKeyRow struct {
	ID              string             `json:"id"`
	Key             string             `json:"key"`
	NameHebrew      string             `json:"name_hebrew"`
	NameEnglish     string             `json:"name_english"`
	Transliteration *string            `json:"transliteration"`
	Category        string             `json:"category"`
	SortOrder       *int32             `json:"sort_order"`
	IsStandard      *bool              `json:"is_standard"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetZmanDefinitionByKey(ctx context.Context, key string) (GetZmanDefinitionByKeyRow, error) {
	row := q.db.QueryRow(ctx, getZmanDefinitionByKey, key)
	var i GetZmanDefinitionByKeyRow
	err := row.Scan(
		&i.ID,
		&i.Key,
		&i.NameHebrew,
		&i.NameEnglish,
		&i.Transliteration,
		&i.Category,
		&i.SortOrder,
		&i.IsStandard,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getZmanDefinitions = `-- name: GetZmanDefinitions :many

SELECT id, key, name_hebrew, name_english, transliteration, category, sort_order,
       is_standard, created_at, updated_at
FROM zman_definitions
ORDER BY category, sort_order, name_hebrew
`

type GetZmanDefinitionsRow struct {
	ID              string             `json:"id"`
	Key             string             `json:"key"`
	NameHebrew      string             `json:"name_hebrew"`
	NameEnglish     string             `json:"name_english"`
	Transliteration *string            `json:"transliteration"`
	Category        string             `json:"category"`
	SortOrder       *int32             `json:"sort_order"`
	IsStandard      *bool              `json:"is_standard"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
}

// Zman Definitions (Global) --
func (q *Queries) GetZmanDefinitions(ctx context.Context) ([]GetZmanDefinitionsRow, error) {
	rows, err := q.db.Query(ctx, getZmanDefinitions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetZmanDefinitionsRow{}
	for rows.Next() {
		var i GetZmanDefinitionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Key,
			&i.NameHebrew,
			&i.NameEnglish,
			&i.Transliteration,
			&i.Category,
			&i.SortOrder,
			&i.IsStandard,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateInvitationToken = `-- name: UpdateInvitationToken :exec
UPDATE publisher_invitations
SET token = $1, expires_at = $2
WHERE id = $3
`

type UpdateInvitationTokenParams struct {
	Token     string    `json:"token"`
	ExpiresAt time.Time `json:"expires_at"`
	ID        string    `json:"id"`
}

func (q *Queries) UpdateInvitationToken(ctx context.Context, arg UpdateInvitationTokenParams) error {
	_, err := q.db.Exec(ctx, updateInvitationToken, arg.Token, arg.ExpiresAt, arg.ID)
	return err
}
