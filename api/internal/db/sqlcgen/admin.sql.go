// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: admin.sql

package sqlcgen

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const adminCountAlgorithms = `-- name: AdminCountAlgorithms :one
SELECT COUNT(*)
FROM algorithms
WHERE ($1::text IS NULL OR status = $1)
`

func (q *Queries) AdminCountAlgorithms(ctx context.Context, dollar_1 string) (int64, error) {
	row := q.db.QueryRow(ctx, adminCountAlgorithms, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const adminCountPublishers = `-- name: AdminCountPublishers :one
SELECT COUNT(*)
FROM publishers
WHERE ($1::text IS NULL OR status = $1)
`

func (q *Queries) AdminCountPublishers(ctx context.Context, dollar_1 string) (int64, error) {
	row := q.db.QueryRow(ctx, adminCountPublishers, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const adminDeletePublisher = `-- name: AdminDeletePublisher :exec
DELETE FROM publishers WHERE id = $1
`

func (q *Queries) AdminDeletePublisher(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, adminDeletePublisher, id)
	return err
}

const adminGetPublisher = `-- name: AdminGetPublisher :one
SELECT id, clerk_user_id, name, email, description, bio,
       website, logo_url, status, created_at, updated_at
FROM publishers
WHERE id = $1
`

type AdminGetPublisherRow struct {
	ID          string             `json:"id"`
	ClerkUserID *string            `json:"clerk_user_id"`
	Name        string             `json:"name"`
	Email       string             `json:"email"`
	Description *string            `json:"description"`
	Bio         *string            `json:"bio"`
	Website     *string            `json:"website"`
	LogoUrl     *string            `json:"logo_url"`
	Status      string             `json:"status"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) AdminGetPublisher(ctx context.Context, id string) (AdminGetPublisherRow, error) {
	row := q.db.QueryRow(ctx, adminGetPublisher, id)
	var i AdminGetPublisherRow
	err := row.Scan(
		&i.ID,
		&i.ClerkUserID,
		&i.Name,
		&i.Email,
		&i.Description,
		&i.Bio,
		&i.Website,
		&i.LogoUrl,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const adminGetStatistics = `-- name: AdminGetStatistics :one

SELECT
    (SELECT COUNT(*) FROM publishers) as total_publishers,
    (SELECT COUNT(*) FROM publishers WHERE status = 'active') as active_publishers,
    (SELECT COUNT(*) FROM publishers WHERE status = 'pending') as pending_publishers,
    (SELECT COUNT(*) FROM algorithms WHERE status = 'published') as published_algorithms,
    (SELECT COUNT(*) FROM geo_cities) as total_cities,
    (SELECT COUNT(*) FROM publisher_coverage WHERE is_active = true) as active_coverage_areas
`

type AdminGetStatisticsRow struct {
	TotalPublishers     int64 `json:"total_publishers"`
	ActivePublishers    int64 `json:"active_publishers"`
	PendingPublishers   int64 `json:"pending_publishers"`
	PublishedAlgorithms int64 `json:"published_algorithms"`
	TotalCities         int64 `json:"total_cities"`
	ActiveCoverageAreas int64 `json:"active_coverage_areas"`
}

// Admin Statistics --
func (q *Queries) AdminGetStatistics(ctx context.Context) (AdminGetStatisticsRow, error) {
	row := q.db.QueryRow(ctx, adminGetStatistics)
	var i AdminGetStatisticsRow
	err := row.Scan(
		&i.TotalPublishers,
		&i.ActivePublishers,
		&i.PendingPublishers,
		&i.PublishedAlgorithms,
		&i.TotalCities,
		&i.ActiveCoverageAreas,
	)
	return i, err
}

const adminListAlgorithms = `-- name: AdminListAlgorithms :many

SELECT
    a.id, a.publisher_id, a.name, a.status, a.is_public,
    a.created_at, a.updated_at,
    p.name as publisher_name
FROM algorithms a
JOIN publishers p ON a.publisher_id = p.id
WHERE ($1::text IS NULL OR a.status = $1)
ORDER BY a.updated_at DESC
LIMIT $2 OFFSET $3
`

type AdminListAlgorithmsParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type AdminListAlgorithmsRow struct {
	ID            string             `json:"id"`
	PublisherID   string             `json:"publisher_id"`
	Name          string             `json:"name"`
	Status        *string            `json:"status"`
	IsPublic      *bool              `json:"is_public"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
	PublisherName string             `json:"publisher_name"`
}

// Admin Algorithm Management --
func (q *Queries) AdminListAlgorithms(ctx context.Context, arg AdminListAlgorithmsParams) ([]AdminListAlgorithmsRow, error) {
	rows, err := q.db.Query(ctx, adminListAlgorithms, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AdminListAlgorithmsRow{}
	for rows.Next() {
		var i AdminListAlgorithmsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublisherID,
			&i.Name,
			&i.Status,
			&i.IsPublic,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublisherName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminListPublishers = `-- name: AdminListPublishers :many


SELECT id, clerk_user_id, name, email, status, created_at, updated_at
FROM publishers
WHERE ($1::text IS NULL OR status = $1)
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type AdminListPublishersParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type AdminListPublishersRow struct {
	ID          string             `json:"id"`
	ClerkUserID *string            `json:"clerk_user_id"`
	Name        string             `json:"name"`
	Email       string             `json:"email"`
	Status      string             `json:"status"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

// Admin SQL Queries
// SQLc will generate type-safe Go code from these queries
// Admin Publisher Management --
func (q *Queries) AdminListPublishers(ctx context.Context, arg AdminListPublishersParams) ([]AdminListPublishersRow, error) {
	rows, err := q.db.Query(ctx, adminListPublishers, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AdminListPublishersRow{}
	for rows.Next() {
		var i AdminListPublishersRow
		if err := rows.Scan(
			&i.ID,
			&i.ClerkUserID,
			&i.Name,
			&i.Email,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminUpdatePublisherStatus = `-- name: AdminUpdatePublisherStatus :one
UPDATE publishers
SET status = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, status
`

type AdminUpdatePublisherStatusParams struct {
	ID     string `json:"id"`
	Status string `json:"status"`
}

type AdminUpdatePublisherStatusRow struct {
	ID     string `json:"id"`
	Status string `json:"status"`
}

func (q *Queries) AdminUpdatePublisherStatus(ctx context.Context, arg AdminUpdatePublisherStatusParams) (AdminUpdatePublisherStatusRow, error) {
	row := q.db.QueryRow(ctx, adminUpdatePublisherStatus, arg.ID, arg.Status)
	var i AdminUpdatePublisherStatusRow
	err := row.Scan(&i.ID, &i.Status)
	return i, err
}

const countPendingInvitationsForEmail = `-- name: CountPendingInvitationsForEmail :one
SELECT COUNT(*)
FROM publisher_invitations
WHERE publisher_id = $1 AND LOWER(email) = LOWER($2) AND expires_at > NOW()
`

type CountPendingInvitationsForEmailParams struct {
	PublisherID string `json:"publisher_id"`
	Lower       string `json:"lower"`
}

func (q *Queries) CountPendingInvitationsForEmail(ctx context.Context, arg CountPendingInvitationsForEmailParams) (int64, error) {
	row := q.db.QueryRow(ctx, countPendingInvitationsForEmail, arg.PublisherID, arg.Lower)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createInvitation = `-- name: CreateInvitation :one
INSERT INTO publisher_invitations (publisher_id, email, role, token, expires_at)
VALUES ($1, $2, $3, $4, $5)
RETURNING id
`

type CreateInvitationParams struct {
	PublisherID string    `json:"publisher_id"`
	Email       string    `json:"email"`
	Role        string    `json:"role"`
	Token       string    `json:"token"`
	ExpiresAt   time.Time `json:"expires_at"`
}

func (q *Queries) CreateInvitation(ctx context.Context, arg CreateInvitationParams) (string, error) {
	row := q.db.QueryRow(ctx, createInvitation,
		arg.PublisherID,
		arg.Email,
		arg.Role,
		arg.Token,
		arg.ExpiresAt,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}

const deleteExpiredInvitations = `-- name: DeleteExpiredInvitations :exec
DELETE FROM publisher_invitations
WHERE publisher_id = $1 AND expires_at <= NOW()
`

func (q *Queries) DeleteExpiredInvitations(ctx context.Context, publisherID string) error {
	_, err := q.db.Exec(ctx, deleteExpiredInvitations, publisherID)
	return err
}

const deleteInvitation = `-- name: DeleteInvitation :exec
DELETE FROM publisher_invitations
WHERE id = $1
`

func (q *Queries) DeleteInvitation(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteInvitation, id)
	return err
}

const getExpiredInvitations = `-- name: GetExpiredInvitations :many
SELECT id, email, role, expires_at, created_at
FROM publisher_invitations
WHERE publisher_id = $1 AND expires_at <= NOW()
ORDER BY created_at DESC
`

type GetExpiredInvitationsRow struct {
	ID        string             `json:"id"`
	Email     string             `json:"email"`
	Role      string             `json:"role"`
	ExpiresAt time.Time          `json:"expires_at"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) GetExpiredInvitations(ctx context.Context, publisherID string) ([]GetExpiredInvitationsRow, error) {
	rows, err := q.db.Query(ctx, getExpiredInvitations, publisherID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetExpiredInvitationsRow{}
	for rows.Next() {
		var i GetExpiredInvitationsRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Role,
			&i.ExpiresAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvitationByToken = `-- name: GetInvitationByToken :one
SELECT pi.id, pi.publisher_id, pi.email, pi.role, pi.expires_at, p.name as publisher_name
FROM publisher_invitations pi
JOIN publishers p ON pi.publisher_id = p.id
WHERE pi.token = $1 AND pi.expires_at > NOW()
`

type GetInvitationByTokenRow struct {
	ID            string    `json:"id"`
	PublisherID   string    `json:"publisher_id"`
	Email         string    `json:"email"`
	Role          string    `json:"role"`
	ExpiresAt     time.Time `json:"expires_at"`
	PublisherName string    `json:"publisher_name"`
}

func (q *Queries) GetInvitationByToken(ctx context.Context, token string) (GetInvitationByTokenRow, error) {
	row := q.db.QueryRow(ctx, getInvitationByToken, token)
	var i GetInvitationByTokenRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.Email,
		&i.Role,
		&i.ExpiresAt,
		&i.PublisherName,
	)
	return i, err
}

const getPendingInvitations = `-- name: GetPendingInvitations :many

SELECT id, email, role, expires_at, created_at
FROM publisher_invitations
WHERE publisher_id = $1 AND expires_at > NOW()
ORDER BY created_at DESC
`

type GetPendingInvitationsRow struct {
	ID        string             `json:"id"`
	Email     string             `json:"email"`
	Role      string             `json:"role"`
	ExpiresAt time.Time          `json:"expires_at"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

// Publisher Invitations --
// Schema: id, publisher_id, email, role, token, expires_at, created_at
func (q *Queries) GetPendingInvitations(ctx context.Context, publisherID string) ([]GetPendingInvitationsRow, error) {
	rows, err := q.db.Query(ctx, getPendingInvitations, publisherID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPendingInvitationsRow{}
	for rows.Next() {
		var i GetPendingInvitationsRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Role,
			&i.ExpiresAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublisherOwner = `-- name: GetPublisherOwner :one

SELECT clerk_user_id FROM publishers WHERE id = $1
`

// Team Management --
func (q *Queries) GetPublisherOwner(ctx context.Context, id string) (*string, error) {
	row := q.db.QueryRow(ctx, getPublisherOwner, id)
	var clerk_user_id *string
	err := row.Scan(&clerk_user_id)
	return clerk_user_id, err
}

const updateInvitationToken = `-- name: UpdateInvitationToken :exec
UPDATE publisher_invitations
SET token = $1, expires_at = $2
WHERE id = $3
`

type UpdateInvitationTokenParams struct {
	Token     string    `json:"token"`
	ExpiresAt time.Time `json:"expires_at"`
	ID        string    `json:"id"`
}

func (q *Queries) UpdateInvitationToken(ctx context.Context, arg UpdateInvitationTokenParams) error {
	_, err := q.db.Exec(ctx, updateInvitationToken, arg.Token, arg.ExpiresAt, arg.ID)
	return err
}
