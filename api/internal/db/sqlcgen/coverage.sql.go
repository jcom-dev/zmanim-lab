// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: coverage.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkDuplicateCoverageCity = `-- name: CheckDuplicateCoverageCity :one
SELECT EXISTS(
    SELECT 1 FROM publisher_coverage
    WHERE publisher_id = $1 AND coverage_level = 'city' AND city_id = $2
) as exists
`

type CheckDuplicateCoverageCityParams struct {
	PublisherID string      `json:"publisher_id"`
	CityID      pgtype.UUID `json:"city_id"`
}

func (q *Queries) CheckDuplicateCoverageCity(ctx context.Context, arg CheckDuplicateCoverageCityParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkDuplicateCoverageCity, arg.PublisherID, arg.CityID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkDuplicateCoverageContinent = `-- name: CheckDuplicateCoverageContinent :one

SELECT EXISTS(
    SELECT 1 FROM publisher_coverage
    WHERE publisher_id = $1 AND coverage_level = 'continent' AND continent_code = $2
) as exists
`

type CheckDuplicateCoverageContinentParams struct {
	PublisherID   string  `json:"publisher_id"`
	ContinentCode *string `json:"continent_code"`
}

// ============================================================================
// Coverage Validation
// ============================================================================
func (q *Queries) CheckDuplicateCoverageContinent(ctx context.Context, arg CheckDuplicateCoverageContinentParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkDuplicateCoverageContinent, arg.PublisherID, arg.ContinentCode)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkDuplicateCoverageCountry = `-- name: CheckDuplicateCoverageCountry :one
SELECT EXISTS(
    SELECT 1 FROM publisher_coverage
    WHERE publisher_id = $1 AND coverage_level = 'country' AND country_id = $2
) as exists
`

type CheckDuplicateCoverageCountryParams struct {
	PublisherID string `json:"publisher_id"`
	CountryID   *int16 `json:"country_id"`
}

func (q *Queries) CheckDuplicateCoverageCountry(ctx context.Context, arg CheckDuplicateCoverageCountryParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkDuplicateCoverageCountry, arg.PublisherID, arg.CountryID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkDuplicateCoverageDistrict = `-- name: CheckDuplicateCoverageDistrict :one
SELECT EXISTS(
    SELECT 1 FROM publisher_coverage
    WHERE publisher_id = $1 AND coverage_level = 'district' AND district_id = $2
) as exists
`

type CheckDuplicateCoverageDistrictParams struct {
	PublisherID string `json:"publisher_id"`
	DistrictID  *int32 `json:"district_id"`
}

func (q *Queries) CheckDuplicateCoverageDistrict(ctx context.Context, arg CheckDuplicateCoverageDistrictParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkDuplicateCoverageDistrict, arg.PublisherID, arg.DistrictID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkDuplicateCoverageRegion = `-- name: CheckDuplicateCoverageRegion :one
SELECT EXISTS(
    SELECT 1 FROM publisher_coverage
    WHERE publisher_id = $1 AND coverage_level = 'region' AND region_id = $2
) as exists
`

type CheckDuplicateCoverageRegionParams struct {
	PublisherID string `json:"publisher_id"`
	RegionID    *int32 `json:"region_id"`
}

func (q *Queries) CheckDuplicateCoverageRegion(ctx context.Context, arg CheckDuplicateCoverageRegionParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkDuplicateCoverageRegion, arg.PublisherID, arg.RegionID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createCoverageCity = `-- name: CreateCoverageCity :one
INSERT INTO publisher_coverage (publisher_id, coverage_level, city_id, priority, is_active)
VALUES ($1, 'city', $2, $3, $4)
RETURNING id, publisher_id, coverage_level, continent_code, country_id, region_id, district_id, city_id, priority, is_active, created_at, updated_at
`

type CreateCoverageCityParams struct {
	PublisherID string      `json:"publisher_id"`
	CityID      pgtype.UUID `json:"city_id"`
	Priority    *int32      `json:"priority"`
	IsActive    bool        `json:"is_active"`
}

type CreateCoverageCityRow struct {
	ID            string             `json:"id"`
	PublisherID   string             `json:"publisher_id"`
	CoverageLevel string             `json:"coverage_level"`
	ContinentCode *string            `json:"continent_code"`
	CountryID     *int16             `json:"country_id"`
	RegionID      *int32             `json:"region_id"`
	DistrictID    *int32             `json:"district_id"`
	CityID        pgtype.UUID        `json:"city_id"`
	Priority      *int32             `json:"priority"`
	IsActive      bool               `json:"is_active"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreateCoverageCity(ctx context.Context, arg CreateCoverageCityParams) (CreateCoverageCityRow, error) {
	row := q.db.QueryRow(ctx, createCoverageCity,
		arg.PublisherID,
		arg.CityID,
		arg.Priority,
		arg.IsActive,
	)
	var i CreateCoverageCityRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.CoverageLevel,
		&i.ContinentCode,
		&i.CountryID,
		&i.RegionID,
		&i.DistrictID,
		&i.CityID,
		&i.Priority,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createCoverageContinent = `-- name: CreateCoverageContinent :one
INSERT INTO publisher_coverage (publisher_id, coverage_level, continent_code, priority, is_active)
VALUES ($1, 'continent', $2, $3, $4)
RETURNING id, publisher_id, coverage_level, continent_code, country_id, region_id, district_id, city_id, priority, is_active, created_at, updated_at
`

type CreateCoverageContinentParams struct {
	PublisherID   string  `json:"publisher_id"`
	ContinentCode *string `json:"continent_code"`
	Priority      *int32  `json:"priority"`
	IsActive      bool    `json:"is_active"`
}

type CreateCoverageContinentRow struct {
	ID            string             `json:"id"`
	PublisherID   string             `json:"publisher_id"`
	CoverageLevel string             `json:"coverage_level"`
	ContinentCode *string            `json:"continent_code"`
	CountryID     *int16             `json:"country_id"`
	RegionID      *int32             `json:"region_id"`
	DistrictID    *int32             `json:"district_id"`
	CityID        pgtype.UUID        `json:"city_id"`
	Priority      *int32             `json:"priority"`
	IsActive      bool               `json:"is_active"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreateCoverageContinent(ctx context.Context, arg CreateCoverageContinentParams) (CreateCoverageContinentRow, error) {
	row := q.db.QueryRow(ctx, createCoverageContinent,
		arg.PublisherID,
		arg.ContinentCode,
		arg.Priority,
		arg.IsActive,
	)
	var i CreateCoverageContinentRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.CoverageLevel,
		&i.ContinentCode,
		&i.CountryID,
		&i.RegionID,
		&i.DistrictID,
		&i.CityID,
		&i.Priority,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createCoverageCountry = `-- name: CreateCoverageCountry :one
INSERT INTO publisher_coverage (publisher_id, coverage_level, country_id, priority, is_active)
VALUES ($1, 'country', $2, $3, $4)
RETURNING id, publisher_id, coverage_level, continent_code, country_id, region_id, district_id, city_id, priority, is_active, created_at, updated_at
`

type CreateCoverageCountryParams struct {
	PublisherID string `json:"publisher_id"`
	CountryID   *int16 `json:"country_id"`
	Priority    *int32 `json:"priority"`
	IsActive    bool   `json:"is_active"`
}

type CreateCoverageCountryRow struct {
	ID            string             `json:"id"`
	PublisherID   string             `json:"publisher_id"`
	CoverageLevel string             `json:"coverage_level"`
	ContinentCode *string            `json:"continent_code"`
	CountryID     *int16             `json:"country_id"`
	RegionID      *int32             `json:"region_id"`
	DistrictID    *int32             `json:"district_id"`
	CityID        pgtype.UUID        `json:"city_id"`
	Priority      *int32             `json:"priority"`
	IsActive      bool               `json:"is_active"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreateCoverageCountry(ctx context.Context, arg CreateCoverageCountryParams) (CreateCoverageCountryRow, error) {
	row := q.db.QueryRow(ctx, createCoverageCountry,
		arg.PublisherID,
		arg.CountryID,
		arg.Priority,
		arg.IsActive,
	)
	var i CreateCoverageCountryRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.CoverageLevel,
		&i.ContinentCode,
		&i.CountryID,
		&i.RegionID,
		&i.DistrictID,
		&i.CityID,
		&i.Priority,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createCoverageDistrict = `-- name: CreateCoverageDistrict :one
INSERT INTO publisher_coverage (publisher_id, coverage_level, district_id, priority, is_active)
VALUES ($1, 'district', $2, $3, $4)
RETURNING id, publisher_id, coverage_level, continent_code, country_id, region_id, district_id, city_id, priority, is_active, created_at, updated_at
`

type CreateCoverageDistrictParams struct {
	PublisherID string `json:"publisher_id"`
	DistrictID  *int32 `json:"district_id"`
	Priority    *int32 `json:"priority"`
	IsActive    bool   `json:"is_active"`
}

type CreateCoverageDistrictRow struct {
	ID            string             `json:"id"`
	PublisherID   string             `json:"publisher_id"`
	CoverageLevel string             `json:"coverage_level"`
	ContinentCode *string            `json:"continent_code"`
	CountryID     *int16             `json:"country_id"`
	RegionID      *int32             `json:"region_id"`
	DistrictID    *int32             `json:"district_id"`
	CityID        pgtype.UUID        `json:"city_id"`
	Priority      *int32             `json:"priority"`
	IsActive      bool               `json:"is_active"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreateCoverageDistrict(ctx context.Context, arg CreateCoverageDistrictParams) (CreateCoverageDistrictRow, error) {
	row := q.db.QueryRow(ctx, createCoverageDistrict,
		arg.PublisherID,
		arg.DistrictID,
		arg.Priority,
		arg.IsActive,
	)
	var i CreateCoverageDistrictRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.CoverageLevel,
		&i.ContinentCode,
		&i.CountryID,
		&i.RegionID,
		&i.DistrictID,
		&i.CityID,
		&i.Priority,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createCoverageRegion = `-- name: CreateCoverageRegion :one
INSERT INTO publisher_coverage (publisher_id, coverage_level, region_id, priority, is_active)
VALUES ($1, 'region', $2, $3, $4)
RETURNING id, publisher_id, coverage_level, continent_code, country_id, region_id, district_id, city_id, priority, is_active, created_at, updated_at
`

type CreateCoverageRegionParams struct {
	PublisherID string `json:"publisher_id"`
	RegionID    *int32 `json:"region_id"`
	Priority    *int32 `json:"priority"`
	IsActive    bool   `json:"is_active"`
}

type CreateCoverageRegionRow struct {
	ID            string             `json:"id"`
	PublisherID   string             `json:"publisher_id"`
	CoverageLevel string             `json:"coverage_level"`
	ContinentCode *string            `json:"continent_code"`
	CountryID     *int16             `json:"country_id"`
	RegionID      *int32             `json:"region_id"`
	DistrictID    *int32             `json:"district_id"`
	CityID        pgtype.UUID        `json:"city_id"`
	Priority      *int32             `json:"priority"`
	IsActive      bool               `json:"is_active"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreateCoverageRegion(ctx context.Context, arg CreateCoverageRegionParams) (CreateCoverageRegionRow, error) {
	row := q.db.QueryRow(ctx, createCoverageRegion,
		arg.PublisherID,
		arg.RegionID,
		arg.Priority,
		arg.IsActive,
	)
	var i CreateCoverageRegionRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.CoverageLevel,
		&i.ContinentCode,
		&i.CountryID,
		&i.RegionID,
		&i.DistrictID,
		&i.CityID,
		&i.Priority,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteCoverage = `-- name: DeleteCoverage :exec
DELETE FROM publisher_coverage
WHERE id = $1
`

func (q *Queries) DeleteCoverage(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteCoverage, id)
	return err
}

const deleteCoverageByPublisher = `-- name: DeleteCoverageByPublisher :exec
DELETE FROM publisher_coverage
WHERE publisher_id = $1
`

func (q *Queries) DeleteCoverageByPublisher(ctx context.Context, publisherID string) error {
	_, err := q.db.Exec(ctx, deleteCoverageByPublisher, publisherID)
	return err
}

const getCitiesCoveredCount = `-- name: GetCitiesCoveredCount :one
SELECT COALESCE(SUM(
    CASE pc.coverage_level
        WHEN 'city' THEN 1
        WHEN 'district' THEN (
            SELECT COUNT(*) FROM geo_cities c WHERE c.district_id = pc.district_id
        )
        WHEN 'region' THEN (
            SELECT COUNT(*) FROM geo_cities c WHERE c.region_id = pc.region_id
        )
        WHEN 'country' THEN (
            SELECT COUNT(*) FROM geo_cities c
            JOIN geo_regions r ON c.region_id = r.id
            WHERE r.country_id = pc.country_id
        )
        WHEN 'continent' THEN (
            SELECT COUNT(*) FROM geo_cities c
            JOIN geo_regions r ON c.region_id = r.id
            JOIN geo_countries co ON r.country_id = co.id
            JOIN geo_continents ct ON co.continent_id = ct.id
            WHERE ct.code = pc.continent_code
        )
        ELSE 0
    END
), 0)::int
FROM publisher_coverage pc
WHERE pc.publisher_id = $1 AND pc.is_active = true
`

// Estimates the number of cities covered by a publisher's coverage areas
// Note: country derived via city.region_id → region.country_id
func (q *Queries) GetCitiesCoveredCount(ctx context.Context, publisherID string) (int32, error) {
	row := q.db.QueryRow(ctx, getCitiesCoveredCount, publisherID)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const getCoverageCountByPublisher = `-- name: GetCoverageCountByPublisher :one
SELECT COUNT(*)
FROM publisher_coverage
WHERE publisher_id = $1 AND is_active = true
`

func (q *Queries) GetCoverageCountByPublisher(ctx context.Context, publisherID string) (int64, error) {
	row := q.db.QueryRow(ctx, getCoverageCountByPublisher, publisherID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getPublisherCoverage = `-- name: GetPublisherCoverage :many

SELECT
    pc.id, pc.publisher_id, pc.coverage_level,
    pc.continent_code, pc.country_id, pc.region_id, pc.district_id, pc.city_id,
    pc.priority, pc.is_active, pc.created_at, pc.updated_at,
    -- Resolved names
    ct.name as continent_name,
    co.code as country_code, co.name as country_name,
    r.code as region_code, r.name as region_name,
    d.code as district_code, d.name as district_name,
    c.name as city_name
FROM publisher_coverage pc
LEFT JOIN geo_continents ct ON pc.continent_code = ct.code
LEFT JOIN geo_countries co ON pc.country_id = co.id
LEFT JOIN geo_regions r ON pc.region_id = r.id
LEFT JOIN geo_districts d ON pc.district_id = d.id
LEFT JOIN geo_cities c ON pc.city_id = c.id
WHERE pc.publisher_id = $1 AND pc.is_active = true
ORDER BY
    CASE pc.coverage_level
        WHEN 'continent' THEN 1
        WHEN 'country' THEN 2
        WHEN 'region' THEN 3
        WHEN 'district' THEN 4
        WHEN 'city' THEN 5
    END,
    pc.priority DESC, pc.created_at DESC
`

type GetPublisherCoverageRow struct {
	ID            string             `json:"id"`
	PublisherID   string             `json:"publisher_id"`
	CoverageLevel string             `json:"coverage_level"`
	ContinentCode *string            `json:"continent_code"`
	CountryID     *int16             `json:"country_id"`
	RegionID      *int32             `json:"region_id"`
	DistrictID    *int32             `json:"district_id"`
	CityID        pgtype.UUID        `json:"city_id"`
	Priority      *int32             `json:"priority"`
	IsActive      bool               `json:"is_active"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
	ContinentName *string            `json:"continent_name"`
	CountryCode   *string            `json:"country_code"`
	CountryName   *string            `json:"country_name"`
	RegionCode    *string            `json:"region_code"`
	RegionName    *string            `json:"region_name"`
	DistrictCode  *string            `json:"district_code"`
	DistrictName  *string            `json:"district_name"`
	CityName      *string            `json:"city_name"`
}

// Coverage SQL Queries (5-Level Hierarchy)
// Supports: continent, country, region, district, city
func (q *Queries) GetPublisherCoverage(ctx context.Context, publisherID string) ([]GetPublisherCoverageRow, error) {
	rows, err := q.db.Query(ctx, getPublisherCoverage, publisherID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPublisherCoverageRow{}
	for rows.Next() {
		var i GetPublisherCoverageRow
		if err := rows.Scan(
			&i.ID,
			&i.PublisherID,
			&i.CoverageLevel,
			&i.ContinentCode,
			&i.CountryID,
			&i.RegionID,
			&i.DistrictID,
			&i.CityID,
			&i.Priority,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ContinentName,
			&i.CountryCode,
			&i.CountryName,
			&i.RegionCode,
			&i.RegionName,
			&i.DistrictCode,
			&i.DistrictName,
			&i.CityName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublisherCoverageByID = `-- name: GetPublisherCoverageByID :one
SELECT
    pc.id, pc.publisher_id, pc.coverage_level,
    pc.continent_code, pc.country_id, pc.region_id, pc.district_id, pc.city_id,
    pc.priority, pc.is_active, pc.created_at, pc.updated_at
FROM publisher_coverage pc
WHERE pc.id = $1
`

type GetPublisherCoverageByIDRow struct {
	ID            string             `json:"id"`
	PublisherID   string             `json:"publisher_id"`
	CoverageLevel string             `json:"coverage_level"`
	ContinentCode *string            `json:"continent_code"`
	CountryID     *int16             `json:"country_id"`
	RegionID      *int32             `json:"region_id"`
	DistrictID    *int32             `json:"district_id"`
	CityID        pgtype.UUID        `json:"city_id"`
	Priority      *int32             `json:"priority"`
	IsActive      bool               `json:"is_active"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetPublisherCoverageByID(ctx context.Context, id string) (GetPublisherCoverageByIDRow, error) {
	row := q.db.QueryRow(ctx, getPublisherCoverageByID, id)
	var i GetPublisherCoverageByIDRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.CoverageLevel,
		&i.ContinentCode,
		&i.CountryID,
		&i.RegionID,
		&i.DistrictID,
		&i.CityID,
		&i.Priority,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPublishersByCountry = `-- name: GetPublishersByCountry :many
SELECT DISTINCT
    p.id, p.name, p.slug, p.is_verified,
    pc.coverage_level, pc.priority
FROM publishers p
JOIN publisher_coverage pc ON p.id = pc.publisher_id
LEFT JOIN geo_countries co ON pc.country_id = co.id
LEFT JOIN geo_regions r ON pc.region_id = r.id
LEFT JOIN geo_districts d ON pc.district_id = d.id
LEFT JOIN geo_cities c ON pc.city_id = c.id
LEFT JOIN geo_regions cr ON c.region_id = cr.id
WHERE p.status = 'active'
  AND pc.is_active = true
  AND (
    pc.country_id = $1
    OR r.country_id = $1
    OR (d.region_id IN (SELECT id FROM geo_regions WHERE country_id = $1))
    OR (cr.country_id = $1)
  )
ORDER BY pc.priority DESC, p.name
`

type GetPublishersByCountryRow struct {
	ID            string  `json:"id"`
	Name          string  `json:"name"`
	Slug          *string `json:"slug"`
	IsVerified    bool    `json:"is_verified"`
	CoverageLevel string  `json:"coverage_level"`
	Priority      *int32  `json:"priority"`
}

// Find publishers with coverage in a specific country
// Note: city country derived via city.region_id → region.country_id
func (q *Queries) GetPublishersByCountry(ctx context.Context, countryID *int16) ([]GetPublishersByCountryRow, error) {
	rows, err := q.db.Query(ctx, getPublishersByCountry, countryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPublishersByCountryRow{}
	for rows.Next() {
		var i GetPublishersByCountryRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.IsVerified,
			&i.CoverageLevel,
			&i.Priority,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublishersByRegion = `-- name: GetPublishersByRegion :many
SELECT DISTINCT
    p.id, p.name, p.slug, p.is_verified,
    pc.coverage_level, pc.priority
FROM publishers p
JOIN publisher_coverage pc ON p.id = pc.publisher_id
LEFT JOIN geo_districts d ON pc.district_id = d.id
LEFT JOIN geo_cities c ON pc.city_id = c.id
WHERE p.status = 'active'
  AND pc.is_active = true
  AND (
    pc.region_id = $1
    OR d.region_id = $1
    OR c.region_id = $1
  )
ORDER BY pc.priority DESC, p.name
`

type GetPublishersByRegionRow struct {
	ID            string  `json:"id"`
	Name          string  `json:"name"`
	Slug          *string `json:"slug"`
	IsVerified    bool    `json:"is_verified"`
	CoverageLevel string  `json:"coverage_level"`
	Priority      *int32  `json:"priority"`
}

// Find publishers with coverage in a specific region
func (q *Queries) GetPublishersByRegion(ctx context.Context, regionID *int32) ([]GetPublishersByRegionRow, error) {
	rows, err := q.db.Query(ctx, getPublishersByRegion, regionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPublishersByRegionRow{}
	for rows.Next() {
		var i GetPublishersByRegionRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.IsVerified,
			&i.CoverageLevel,
			&i.Priority,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublishersForCity = `-- name: GetPublishersForCity :many

SELECT get_publishers_for_city FROM get_publishers_for_city($1)
`

// ============================================================================
// Publisher Lookup by Location
// ============================================================================
// Find publishers that cover a specific city (using the get_publishers_for_city function)
func (q *Queries) GetPublishersForCity(ctx context.Context, pCityID string) ([]interface{}, error) {
	rows, err := q.db.Query(ctx, getPublishersForCity, pCityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []interface{}{}
	for rows.Next() {
		var get_publishers_for_city interface{}
		if err := rows.Scan(&get_publishers_for_city); err != nil {
			return nil, err
		}
		items = append(items, get_publishers_for_city)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCoverageActive = `-- name: UpdateCoverageActive :one
UPDATE publisher_coverage
SET is_active = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, publisher_id, coverage_level, continent_code, country_id, region_id, district_id, city_id, priority, is_active, created_at, updated_at
`

type UpdateCoverageActiveParams struct {
	ID       string `json:"id"`
	IsActive bool   `json:"is_active"`
}

type UpdateCoverageActiveRow struct {
	ID            string             `json:"id"`
	PublisherID   string             `json:"publisher_id"`
	CoverageLevel string             `json:"coverage_level"`
	ContinentCode *string            `json:"continent_code"`
	CountryID     *int16             `json:"country_id"`
	RegionID      *int32             `json:"region_id"`
	DistrictID    *int32             `json:"district_id"`
	CityID        pgtype.UUID        `json:"city_id"`
	Priority      *int32             `json:"priority"`
	IsActive      bool               `json:"is_active"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) UpdateCoverageActive(ctx context.Context, arg UpdateCoverageActiveParams) (UpdateCoverageActiveRow, error) {
	row := q.db.QueryRow(ctx, updateCoverageActive, arg.ID, arg.IsActive)
	var i UpdateCoverageActiveRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.CoverageLevel,
		&i.ContinentCode,
		&i.CountryID,
		&i.RegionID,
		&i.DistrictID,
		&i.CityID,
		&i.Priority,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCoveragePriority = `-- name: UpdateCoveragePriority :one
UPDATE publisher_coverage
SET priority = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, publisher_id, coverage_level, continent_code, country_id, region_id, district_id, city_id, priority, is_active, created_at, updated_at
`

type UpdateCoveragePriorityParams struct {
	ID       string `json:"id"`
	Priority *int32 `json:"priority"`
}

type UpdateCoveragePriorityRow struct {
	ID            string             `json:"id"`
	PublisherID   string             `json:"publisher_id"`
	CoverageLevel string             `json:"coverage_level"`
	ContinentCode *string            `json:"continent_code"`
	CountryID     *int16             `json:"country_id"`
	RegionID      *int32             `json:"region_id"`
	DistrictID    *int32             `json:"district_id"`
	CityID        pgtype.UUID        `json:"city_id"`
	Priority      *int32             `json:"priority"`
	IsActive      bool               `json:"is_active"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) UpdateCoveragePriority(ctx context.Context, arg UpdateCoveragePriorityParams) (UpdateCoveragePriorityRow, error) {
	row := q.db.QueryRow(ctx, updateCoveragePriority, arg.ID, arg.Priority)
	var i UpdateCoveragePriorityRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.CoverageLevel,
		&i.ContinentCode,
		&i.CountryID,
		&i.RegionID,
		&i.DistrictID,
		&i.CityID,
		&i.Priority,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
